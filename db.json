{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/uploads/avatar.png","path":"uploads/avatar.png","modified":1,"renderable":0},{"_id":"source/uploads/hexo.png","path":"uploads/hexo.png","modified":1,"renderable":0},{"_id":"source/uploads/optmini.jpg","path":"uploads/optmini.jpg","modified":1,"renderable":0},{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"423e2feee41f3aa5725879d74f2d9bb6bfdde2c2","modified":1570156104829},{"_id":"source/CNAME","hash":"c7a296adc916f13ef96770f8abe680c17cddb1cc","modified":1569424225206},{"_id":"themes/Anisina/.DS_Store","hash":"954d6d1e698b40b6d78ccfc0a227dd3b8fdcf902","modified":1569424225226},{"_id":"themes/Anisina/_config.yml","hash":"d3f35255f2edc545917f5ecbf74a3e1c3f18bfa2","modified":1570153295044},{"_id":"source/_posts/Babel核心用法记要.md","hash":"734980c1455ec4225051b8ca5b505541fe555a12","modified":1569424225206},{"_id":"source/_posts/FreeCodeCamp初级脚本算法题-笔记.md","hash":"eb40a9152da9e1b19358237be63d337b7fab5d48","modified":1569424225206},{"_id":"source/_posts/Git 问题备忘录.md","hash":"5b544b2e534a747202ac028a4271d6a277cefe16","modified":1569943541158},{"_id":"source/_posts/Git合并多个commit.md","hash":"fbdcfad47f03b00c82b40f3fe86533aa8fdcdb1a","modified":1569424225206},{"_id":"source/_posts/Git如何修改commit提交顺序.md","hash":"a997af0e9fcd1e904fb11010ad823ce9b0f908c7","modified":1569424225207},{"_id":"source/_posts/Git如何修改最新commit的message.md","hash":"686365ef54b1fe19c82ade1785a33632866c7e4d","modified":1569424225207},{"_id":"source/_posts/Git如何修改老旧commit的message.md","hash":"5cb2b0788ab51c75fdc8c80dc0b96f19acfde750","modified":1569424225207},{"_id":"source/_posts/Git如何克隆指定分支.md","hash":"1f3e10be1dd8b5e94ac6f134ff049ae212f83694","modified":1571443405859},{"_id":"source/_posts/Git重命名本地分支名和远程分支名.md","hash":"2f2c624c4e5db9e4593882fa39baa3c30d432c17","modified":1569424225207},{"_id":"source/_posts/JS函数的throttle(节流)和debounce(抖动).md","hash":"3d7e7f877d0dd27863a1d14c66a9485e95b3e325","modified":1569424225207},{"_id":"source/_posts/JS实用技巧(一).md","hash":"758217e33fa7785979c2d40acebf5102ae8b154d","modified":1569424225207},{"_id":"source/_posts/JS实用技巧(三).md","hash":"8248d87240751683747f9b3cb2fa603be93b5d7b","modified":1569914619835},{"_id":"source/_posts/JS实用技巧(五).md","hash":"c04e449a71d58531b32e08384ad443a21e941713","modified":1569424225208},{"_id":"source/_posts/JS实用技巧(二).md","hash":"778164ee56d9c4b6b7fb39c15742683fb9bcb5f5","modified":1569424225208},{"_id":"source/_posts/JS实用技巧(四).md","hash":"2d40fecdecf05e60a39191970a0a3e712e197ba2","modified":1569424225208},{"_id":"source/_posts/JS数组常用的方法总结.md","hash":"ff10b07868bcb45a89558b232c40fe0b4f0bec6e","modified":1569424225208},{"_id":"source/_posts/JS生成随机的由字母数字组合的字符串.md","hash":"729b64fc4e2219dc21f5be3bf9be6701a311c4b6","modified":1569424225208},{"_id":"source/_posts/Javascript函数.md","hash":"36a35178970364af83c4ac17861cc7e3066360a5","modified":1569424225208},{"_id":"source/_posts/Javascript字符串常用方法总结.md","hash":"03a8c4060f6798a1f7f49e9a8a18066c056ec9c8","modified":1569424225209},{"_id":"source/_posts/Javascript开发性能调优(一).md","hash":"8b51be8201aae71c69d8f1b7beabecf0909ad90f","modified":1569424225209},{"_id":"source/_posts/Javascript数组去重效率比较.md","hash":"4d550ee9b40834ec316e5597cdae9b47f7411652","modified":1569424225209},{"_id":"source/_posts/Js上传图片本地预览几种姿势.md","hash":"b7e999f177def16736265d7c4b03d53591eb00a5","modified":1569424225209},{"_id":"source/_posts/Jquery操作select下拉框值.md","hash":"9d8c8756d0d73647870d4af27126037ed947c05d","modified":1569424225209},{"_id":"source/_posts/Js模仿块级作用域与ES6块级作用域.md","hash":"24bed7155623071b380bb0c70a55ad91a40a95cb","modified":1569424225210},{"_id":"source/_posts/Python爬虫框架scrapy安装报错解决办法.md","hash":"7c3fb2f99cf64919ed46479cbcf88fab30e69310","modified":1569424225210},{"_id":"source/_posts/React-Native-常见错误总结.md","hash":"28da1cd1f9067eb1590bc4eade4bfc7679be4818","modified":1569424225211},{"_id":"source/_posts/VSCode打开多tab页.md","hash":"a0eecd801a155bc1a2db20b723d46b5588c590ef","modified":1571443405860},{"_id":"source/_posts/Vue2-X开发Chrome插件记录.md","hash":"6d0c6a679a0fb127df8fa7e611f257193d641d78","modified":1569424225211},{"_id":"source/_posts/Vuex在IE上的报错处理.md","hash":"337d2dc5b518d1ba091f22d17b9fbddaf42db640","modified":1569424225211},{"_id":"source/_posts/Vue起步.md","hash":"50792bd916385b98098333ba1650614ba73fb0dc","modified":1569424225211},{"_id":"source/_posts/github一个远程仓库的某个分支放到一个新的仓库，保留历史提交记录.md","hash":"54a3852dd1f54dbdac4f63fdb4cc82a740e305f3","modified":1569424225211},{"_id":"source/_posts/hello-world.md","hash":"018feaf0ef7ba418eccd3438ee2ed759d2411cf4","modified":1569424225212},{"_id":"source/_posts/linux之bash命令基础.md","hash":"fe126a6dbbc1c32d628f1761d36a8b23e06b1f85","modified":1571556787313},{"_id":"source/_posts/meta标签梳理.md","hash":"1f7366455a72d42d26532a3d54361a18627a9757","modified":1569424225212},{"_id":"source/_posts/react-native-之-React-createClass和extends-React-Component的区别.md","hash":"35426f116ed240b93f988791c22712c81c67465f","modified":1569424225212},{"_id":"source/_posts/shell脚本编程-构建基本脚本令.md","hash":"02e4a225a73ac0059783a66e137a43011e5e44cc","modified":1571557349742},{"_id":"source/_posts/vue写回到顶部组件遇到的一些问题.md","hash":"244b396c33a77d0bc7be9d571cb6255abd56fac8","modified":1569424225212},{"_id":"source/_posts/window下输入javac提示不是内部或外部命令解决方法.md","hash":"717da85f4470f9e29344d9557aa62124402832ae","modified":1569424225212},{"_id":"source/_posts/《你不知道的javascript中》JS宽松相等和严格相等.md","hash":"fd631831014966c55d953eec8701b4102f35f04f","modified":1569424225212},{"_id":"source/_posts/【Vue版】实用js快速复制文本内容.md","hash":"57f21a2f0f3da45eb91820bc812a0abd015917c0","modified":1569424225212},{"_id":"source/_posts/【正则表达式系列】入门篇.md","hash":"845dd09e74ccca5e552e83676777d4ba7dee650e","modified":1569424225214},{"_id":"source/_posts/【正则表达式系列】贪婪与非贪婪模式.md","hash":"a93833935575ab83d9e6ca71a527b3e8b4e4b363","modified":1569424225215},{"_id":"source/_posts/一个有点意思的正则.md","hash":"73f48cd99f8c2b927e496edc4d057e0994d0482f","modified":1569424225215},{"_id":"source/_posts/一些有趣常用的npm包收集.md","hash":"fe16ea6803d212ed73b3982bd90e6f9756d8e8bf","modified":1569424225215},{"_id":"source/_posts/一次FormData递归上传图片小记.md","hash":"40fd977210a4d6dff2193294acedee36ce405145","modified":1569424225216},{"_id":"source/_posts/从今天起写的每条正则都记录在册.md","hash":"01627fb29430c38f6f6e815d6af5661197cc38cc","modified":1569424225216},{"_id":"source/_posts/写个正则匹配url参数的字典-方便提取查询参数.md","hash":"d8cebbbaa5d301181d35c2d73c797603f33ce785","modified":1569424225216},{"_id":"source/_posts/利用TravisCi自动部署博客到gitPage.md","hash":"ef61462960efb067c326b384b3681db4d956185b","modified":1569424225216},{"_id":"source/_posts/原生JS模拟点击事件和自定义事件.md","hash":"824528238badf899170f7490a11726610be6cb5d","modified":1569424225216},{"_id":"source/_posts/原生JavaScript获取CSS样式遇到的一些问题.md","hash":"f1be1eebea07e7ab252f48f05237bf5b292c56d4","modified":1569424225216},{"_id":"source/_posts/原生js实现类似于Jquery的ajax请求方式.md","hash":"21800e360fcc9decd844fa3f9b3ca14fc54b25ce","modified":1569424225216},{"_id":"source/_posts/只执行一次的函数该怎么写.md","hash":"ea3d3718a96313e078dff49b02fede93dc34bfd3","modified":1569424225216},{"_id":"source/_posts/如何优雅的拼接url之GET请求参数.md","hash":"38726acd0191c91104ac2f273cca93f272d6e0f2","modified":1571443405962},{"_id":"source/_posts/学习下如何优雅的写表单验证.md","hash":"2bb380fd57d7d0fdb4be3719963669635466ddaa","modified":1569424225217},{"_id":"source/_posts/实现一个移动端字母导航索引.md","hash":"402866b00ffb12b4f20cb42301d4082e82148ea8","modified":1569424225217},{"_id":"source/_posts/我也来展望下2017.md","hash":"5a07b15e3f6846af7dae4756f9d17657abb35b3f","modified":1569424225217},{"_id":"source/_posts/换电脑后-如何完美迁出hexo博客.md","hash":"59c78596fef4e706dbc770df7ef383ea5d8a6560","modified":1569424225217},{"_id":"source/_posts/来看看select是个什么东东.md","hash":"f58a0e5c0f31b6689778ca31f006547f85a29c6d","modified":1569424225218},{"_id":"source/_posts/正则匹配字符串英文首字母小写转大写.md","hash":"d8bf05884678a980036ffb262ed37625f14ba1d3","modified":1569424225218},{"_id":"source/_posts/正则实现代码高亮.md","hash":"79e14701502b95ad3a9e83dded3c1f1965f3e95a","modified":1569424225218},{"_id":"source/_posts/正则表达式必须包含数字字母两种组合.md","hash":"f8cb05870c843635ddfd25be577aa7b6b1c09d6e","modified":1569424225218},{"_id":"source/_posts/每隔四个字符添加一个空格的正则怎么写.md","hash":"010ffc04f638faf6990f5f7f8debb2ab42f3dc24","modified":1569424225219},{"_id":"source/_posts/浅析js随机数Math.random().md","hash":"3e1566f0c7717e734cee8e214dfefefeac100b02","modified":1569424225219},{"_id":"source/_posts/浅谈LocalStorage响应事件.md","hash":"cb0419042c3f4247bd7cc7356975638cd2d734a4","modified":1569424225219},{"_id":"source/_posts/纯手工打造一款无缝滚动轮播插件.md","hash":"fc6957fd7f1895c3e88929a99ec0a14c25bc3dca","modified":1569424225219},{"_id":"source/_posts/组件.md","hash":"7a5b69fa4d432979536af182598df085620f65f7","modified":1569424225220},{"_id":"source/_posts/解决Vue复用组件切换时组件不更新的问题.md","hash":"8db9a83f8aaecfa9a6718030a68c91a294f9a83c","modified":1569424225220},{"_id":"source/_posts/输入框禁止输入空格.md","hash":"7f4dcc106aef51fe14dbd2e8708d02ee89ffdeab","modified":1569424225220},{"_id":"source/_posts/阿拉伯数字千分位用逗号分隔.md","hash":"1645c55b7819f6ae9731468bed36fc9cfdc73ee9","modified":1569424225220},{"_id":"source/about/index.md","hash":"6770b0ecd89c2244cd3d07e3d4d649afc2d5c746","modified":1569424225221},{"_id":"source/archives/index.md","hash":"60dd8c2ca9145ff2e94745321787302f83226c59","modified":1569424225221},{"_id":"source/categories/index.md","hash":"65b6ebf1d3a02f970e8349bbbffc1fc7ac076e9b","modified":1569424225221},{"_id":"source/tags/index.md","hash":"e9c25a880420a32f99a437e0b68bcdef25559b32","modified":1569424225221},{"_id":"source/uploads/.DS_Store","hash":"038918764b811511f3448b405a77e7657393dfcd","modified":1569424225221},{"_id":"source/uploads/._.DS_Store","hash":"5ab2bf7809050d011ea3edf4466af77fedb26112","modified":1569424225221},{"_id":"source/uploads/._avatar.png","hash":"406aee4ff6c3cea9828234b8862284f98480f634","modified":1569424225221},{"_id":"source/uploads/._optmini.jpg","hash":"658f25cd1ba031b17d5235960b0e2baa9d1dfcea","modified":1569424225222},{"_id":"source/uploads/avatar.png","hash":"ad7ca8d731bb07b3dc255504c21f9a1e342c1ca2","modified":1569424225224},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1569424225228},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1569424225254},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1569424225255},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1569424225255},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1569424225255},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1569424225255},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1569424225255},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1569424225255},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1569424225255},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1569424225256},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1569424225256},{"_id":"themes/Anisina/layout/archive.ejs","hash":"18c85e861db8ec2859f0838cc0ae77a162986537","modified":1569424225262},{"_id":"themes/Anisina/layout/index.ejs","hash":"a94ac678f6b24a46824d45ec058b0ab2105a92c9","modified":1569424225262},{"_id":"themes/Anisina/layout/layout.ejs","hash":"bbcfb7dc3902104fc55316780415a62581c8ecfc","modified":1569424225262},{"_id":"themes/Anisina/layout/page.ejs","hash":"5142019fc0dd7c6fe1692d89a7267d9050482aee","modified":1570156073056},{"_id":"themes/Anisina/layout/post.ejs","hash":"d474e6509de8cbef973208649ec3df8b8302c4f5","modified":1569424225263},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1569424225262},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1569424225263},{"_id":"themes/Anisina/layout/tags.ejs","hash":"a144c3b5f4a70f881333e4de392a265469cdb649","modified":1569424225263},{"_id":"source/uploads/hexo.png","hash":"a583518f65d00e6b4a47659d0b1ff95e4e4f5e7c","modified":1569424225225},{"_id":"source/uploads/optmini.jpg","hash":"b8093efd1c2a44b6971e883de11964084da5c2b5","modified":1569424225226},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1569424225228},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"e54736280f49e2599863392c8d82d6205011df8b","modified":1571667863868},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"191edbb9331ed75b0ae801072cd7a387254382ad","modified":1571669176019},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"bf6815c8b59a1a856f410228fac98b1785a5b25b","modified":1570152255469},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"c9143f4c5a5c7f136ecb75eb87a14030620e105a","modified":1569424225262},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"ab906e962b0c9ae436082d190ebb68c629152513","modified":1570156206022},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"1bc7f9e5226a2ead6774c61fec61f9bab7c36380","modified":1569424225265},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1569424225266},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1569424225267},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1569424225268},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1569424225268},{"_id":"themes/Anisina/source/js/blog.js","hash":"b1dcf98c15f65a660ebb4d4a2491e3764e6fc18e","modified":1570152538409},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1569424225270},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1569424225276},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1569424225277},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1569424225254},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1569424225265},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1569424225267},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1569424225276},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1569424225235},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1569424225276},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1569424225244},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1569424225252}],"Category":[{"name":"Javascript","_id":"ck20j91nr0004la2efobeierl"},{"name":"Git","_id":"ck20j91nw000bla2eodk3985f"},{"name":"Python","_id":"ck20j91on0027la2erkm5gzco"},{"name":"VSCode","_id":"ck20j91or002hla2eyzykipyw"},{"name":"React","_id":"ck20j91ot002nla2evlx50t7r"},{"name":"Vue","_id":"ck20j91ov002tla2ejmt7g6fv"},{"name":"Linux","_id":"ck20j91oy0031la2ewgvc3jep"},{"name":"HTML","_id":"ck20j91p10038la2ee4we7wat"},{"name":"经验","_id":"ck20j91p6003mla2e3s37x8vk"},{"name":"Tool","_id":"ck20j91pb003yla2epe3wsmvh"},{"name":"other","_id":"ck20j91pr0053la2e0phikph1"}],"Data":[],"Page":[{"date":"2017-06-08T13:17:22.000Z","_content":"\n### 基本信息\n  我是小白不懂\n  目前，西安任职 : 前端开发攻城狮\n  一名渴望成为前端攻城狮大牛的程序猿\n\n### 目前\n  努力工作，积极探索\n\n### 联系我\nbiyuqiwan@163.com\n","source":"about/index.md","raw":"---\ndate: 2017-06-08 21:17:22\n---\n\n### 基本信息\n  我是小白不懂\n  目前，西安任职 : 前端开发攻城狮\n  一名渴望成为前端攻城狮大牛的程序猿\n\n### 目前\n  努力工作，积极探索\n\n### 联系我\nbiyuqiwan@163.com\n","updated":"2019-09-25T15:10:25.221Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"ck20j91no0001la2epbajona6","content":"<h3 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h3><p>  我是小白不懂<br>  目前，西安任职 : 前端开发攻城狮<br>  一名渴望成为前端攻城狮大牛的程序猿</p>\n<h3 id=\"目前\"><a href=\"#目前\" class=\"headerlink\" title=\"目前\"></a>目前</h3><p>  努力工作，积极探索</p>\n<h3 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h3><p>biyuqiwan@163.com</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h3><p>  我是小白不懂<br>  目前，西安任职 : 前端开发攻城狮<br>  一名渴望成为前端攻城狮大牛的程序猿</p>\n<h3 id=\"目前\"><a href=\"#目前\" class=\"headerlink\" title=\"目前\"></a>目前</h3><p>  努力工作，积极探索</p>\n<h3 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h3><p>biyuqiwan@163.com</p>\n"},{"title":"archives","date":"2017-06-11T04:07:14.000Z","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2017-06-11 12:07:14\nlayout: archives\n---\n","updated":"2019-09-25T15:10:25.221Z","path":"archives/index.html","comments":1,"_id":"ck20j91nq0003la2ecuf4wb76","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"categories","title":"","date":"2016-12-04T02:07:10.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\nlayout: categories\ntitle:\ndate: 2016-12-04 10:07:10\ntype: \"categories\"\n---\n","updated":"2019-09-25T15:10:25.221Z","path":"categories/index.html","comments":1,"_id":"ck20j91nt0007la2ersz95dnb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-06-08T13:15:06.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-06-08 21:15:06\nlayout: tags\n---\n","updated":"2019-09-25T15:10:25.221Z","path":"tags/index.html","comments":1,"_id":"ck20j91nv0009la2e8ag9vihd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Babel核心用法记要","date":"2016-12-13T10:55:56.000Z","_content":"## 前言\n最近公司项目的需要，开始接触闻名已久的ES6了，学习之前网上看了不少资料，各大浏览器厂商的支持程度不一，遂需要转码器来转换ES6为ES5代码，[Babel](https://babeljs.io/ \"Babel\")是一个广泛使用的转码器,安装学习过程中遇到一些问题，所以有了今天这篇文章，以备查阅。\n## Babel一句话介绍\n一个js编译器，报浏览器不支持js装换成支持的js。 \n```javascript\n//转码前\ninput.map(item => item + 1);\n//转码后\ninput.map(function(item){\n\treturn item + 1;\n})\n```\n<!-- more -->\n## 一、配置文件.babelrc\nBabel的配置文件是.babelrc，存放在项目根目录下，使用Babel第一步就是配置这个文件。（**该文件需要自己创建，随便新建一个txt文档把它重命名为 ** .xxxx. ** 即会最终生成 .xxxx文件，创建.bablerc 则 重命名为 ** .babelrc. ）。  [百度网盘下载](http://pan.baidu.com/s/1qY2cHDq \"百度网盘下载\")\n该文件用来设置转码规则和插件，基本格式如下：  \n```javascript\n{\n\t\"presets\": [],\n\t\"plugins\": []\n}\n```\n**presets**设置转码规则，官方提供以下规则集，可根据需要进行安装。 \n```javascript\n# ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n#react转码规则\n$ npm install --save-dev babel-preset-react\n```\n将规则加入.babelrc\n```javascript\n{\n\t\"presets\": [\n\t\t\"es2015\",\n\t\t\"react\"\n\t],\n\t\"plugins\": []\n}\n```\n! 注意，以下所有Babel工具和模块的使用，都必须先写好.babelrc。\n## 二、安装命令行转码babel-cli\n>Babel提供babel-cli工具，用于命令行转码。\n```javascript\n$ npm install --global babel-cli\n```\n基本用法如下：\n* #### 转码结果输出到标准输出（即 命令行里展现)\n```javascript\n$ babel demo.js\n```\n* #### 转码结果写入一个文件, --out-file 或 -o 参数指定输出文件\n```javascript\n$ babel demo.js --out-file complete.js\n# 或者\n$ babel demo.js -o complete.js\n```\n* #### 转译目录到目录\n```javascript\n$ babel src --out-dir dist\n# 或者\nbabel src -d dist\n```\n* #### 监听文件变化\n```javascript\n$ babel -w src -d dist\n```\n##### 上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel\n\n##参考：[Babel 用户手册](https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md#toc-babel-cli \"Babel 用户手册\")","source":"_posts/Babel核心用法记要.md","raw":"---\ntitle: Babel核心用法记要\ndate: 2016-12-13 18:55:56\ntags: [javascript,Es6]\ncategories: Javascript\n---\n## 前言\n最近公司项目的需要，开始接触闻名已久的ES6了，学习之前网上看了不少资料，各大浏览器厂商的支持程度不一，遂需要转码器来转换ES6为ES5代码，[Babel](https://babeljs.io/ \"Babel\")是一个广泛使用的转码器,安装学习过程中遇到一些问题，所以有了今天这篇文章，以备查阅。\n## Babel一句话介绍\n一个js编译器，报浏览器不支持js装换成支持的js。 \n```javascript\n//转码前\ninput.map(item => item + 1);\n//转码后\ninput.map(function(item){\n\treturn item + 1;\n})\n```\n<!-- more -->\n## 一、配置文件.babelrc\nBabel的配置文件是.babelrc，存放在项目根目录下，使用Babel第一步就是配置这个文件。（**该文件需要自己创建，随便新建一个txt文档把它重命名为 ** .xxxx. ** 即会最终生成 .xxxx文件，创建.bablerc 则 重命名为 ** .babelrc. ）。  [百度网盘下载](http://pan.baidu.com/s/1qY2cHDq \"百度网盘下载\")\n该文件用来设置转码规则和插件，基本格式如下：  \n```javascript\n{\n\t\"presets\": [],\n\t\"plugins\": []\n}\n```\n**presets**设置转码规则，官方提供以下规则集，可根据需要进行安装。 \n```javascript\n# ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n#react转码规则\n$ npm install --save-dev babel-preset-react\n```\n将规则加入.babelrc\n```javascript\n{\n\t\"presets\": [\n\t\t\"es2015\",\n\t\t\"react\"\n\t],\n\t\"plugins\": []\n}\n```\n! 注意，以下所有Babel工具和模块的使用，都必须先写好.babelrc。\n## 二、安装命令行转码babel-cli\n>Babel提供babel-cli工具，用于命令行转码。\n```javascript\n$ npm install --global babel-cli\n```\n基本用法如下：\n* #### 转码结果输出到标准输出（即 命令行里展现)\n```javascript\n$ babel demo.js\n```\n* #### 转码结果写入一个文件, --out-file 或 -o 参数指定输出文件\n```javascript\n$ babel demo.js --out-file complete.js\n# 或者\n$ babel demo.js -o complete.js\n```\n* #### 转译目录到目录\n```javascript\n$ babel src --out-dir dist\n# 或者\nbabel src -d dist\n```\n* #### 监听文件变化\n```javascript\n$ babel -w src -d dist\n```\n##### 上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel\n\n##参考：[Babel 用户手册](https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md#toc-babel-cli \"Babel 用户手册\")","slug":"Babel核心用法记要","published":1,"updated":"2019-09-25T15:10:25.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91nl0000la2evozba44x","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近公司项目的需要，开始接触闻名已久的ES6了，学习之前网上看了不少资料，各大浏览器厂商的支持程度不一，遂需要转码器来转换ES6为ES5代码，<a href=\"https://babeljs.io/\" title=\"Babel\" target=\"_blank\" rel=\"external\">Babel</a>是一个广泛使用的转码器,安装学习过程中遇到一些问题，所以有了今天这篇文章，以备查阅。</p>\n<h2 id=\"Babel一句话介绍\"><a href=\"#Babel一句话介绍\" class=\"headerlink\" title=\"Babel一句话介绍\"></a>Babel一句话介绍</h2><p>一个js编译器，报浏览器不支持js装换成支持的js。 </p>\n<pre><code class=\"javascript\">//转码前\ninput.map(item =&gt; item + 1);\n//转码后\ninput.map(function(item){\n    return item + 1;\n})\n</code></pre>\n<a id=\"more\"></a>\n<h2 id=\"一、配置文件-babelrc\"><a href=\"#一、配置文件-babelrc\" class=\"headerlink\" title=\"一、配置文件.babelrc\"></a>一、配置文件.babelrc</h2><p>Babel的配置文件是.babelrc，存放在项目根目录下，使用Babel第一步就是配置这个文件。（<strong>该文件需要自己创建，随便新建一个txt文档把它重命名为 </strong> .xxxx. <strong> 即会最终生成 .xxxx文件，创建.bablerc 则 重命名为 </strong> .babelrc. ）。  <a href=\"http://pan.baidu.com/s/1qY2cHDq\" title=\"百度网盘下载\" target=\"_blank\" rel=\"external\">百度网盘下载</a><br>该文件用来设置转码规则和插件，基本格式如下：  </p>\n<pre><code class=\"javascript\">{\n    &quot;presets&quot;: [],\n    &quot;plugins&quot;: []\n}\n</code></pre>\n<p><strong>presets</strong>设置转码规则，官方提供以下规则集，可根据需要进行安装。 </p>\n<pre><code class=\"javascript\"># ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n#react转码规则\n$ npm install --save-dev babel-preset-react\n</code></pre>\n<p>将规则加入.babelrc</p>\n<pre><code class=\"javascript\">{\n    &quot;presets&quot;: [\n        &quot;es2015&quot;,\n        &quot;react&quot;\n    ],\n    &quot;plugins&quot;: []\n}\n</code></pre>\n<p>! 注意，以下所有Babel工具和模块的使用，都必须先写好.babelrc。</p>\n<h2 id=\"二、安装命令行转码babel-cli\"><a href=\"#二、安装命令行转码babel-cli\" class=\"headerlink\" title=\"二、安装命令行转码babel-cli\"></a>二、安装命令行转码babel-cli</h2><blockquote>\n<p>Babel提供babel-cli工具，用于命令行转码。</p>\n<pre><code class=\"javascript\">$ npm install --global babel-cli\n</code></pre>\n<p>基本用法如下：</p>\n<ul>\n<li><h4 id=\"转码结果输出到标准输出（即-命令行里展现\"><a href=\"#转码结果输出到标准输出（即-命令行里展现\" class=\"headerlink\" title=\"转码结果输出到标准输出（即 命令行里展现)\"></a>转码结果输出到标准输出（即 命令行里展现)</h4><pre><code class=\"javascript\">$ babel demo.js\n</code></pre>\n</li>\n<li><h4 id=\"转码结果写入一个文件-–out-file-或-o-参数指定输出文件\"><a href=\"#转码结果写入一个文件-–out-file-或-o-参数指定输出文件\" class=\"headerlink\" title=\"转码结果写入一个文件, –out-file 或 -o 参数指定输出文件\"></a>转码结果写入一个文件, –out-file 或 -o 参数指定输出文件</h4><pre><code class=\"javascript\">$ babel demo.js --out-file complete.js\n# 或者\n$ babel demo.js -o complete.js\n</code></pre>\n</li>\n<li><h4 id=\"转译目录到目录\"><a href=\"#转译目录到目录\" class=\"headerlink\" title=\"转译目录到目录\"></a>转译目录到目录</h4><pre><code class=\"javascript\">$ babel src --out-dir dist\n# 或者\nbabel src -d dist\n</code></pre>\n</li>\n<li><h4 id=\"监听文件变化\"><a href=\"#监听文件变化\" class=\"headerlink\" title=\"监听文件变化\"></a>监听文件变化</h4><pre><code class=\"javascript\">$ babel -w src -d dist\n</code></pre>\n<h5 id=\"上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel\"><a href=\"#上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel\" class=\"headerlink\" title=\"上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel\"></a>上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel</h5></li>\n</ul>\n</blockquote>\n<p>##参考：<a href=\"https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md#toc-babel-cli\" title=\"Babel 用户手册\" target=\"_blank\" rel=\"external\">Babel 用户手册</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近公司项目的需要，开始接触闻名已久的ES6了，学习之前网上看了不少资料，各大浏览器厂商的支持程度不一，遂需要转码器来转换ES6为ES5代码，<a href=\"https://babeljs.io/\" title=\"Babel\" target=\"_blank\" rel=\"external\">Babel</a>是一个广泛使用的转码器,安装学习过程中遇到一些问题，所以有了今天这篇文章，以备查阅。</p>\n<h2 id=\"Babel一句话介绍\"><a href=\"#Babel一句话介绍\" class=\"headerlink\" title=\"Babel一句话介绍\"></a>Babel一句话介绍</h2><p>一个js编译器，报浏览器不支持js装换成支持的js。 </p>\n<pre><code class=\"javascript\">//转码前\ninput.map(item =&gt; item + 1);\n//转码后\ninput.map(function(item){\n    return item + 1;\n})\n</code></pre>","more":"<h2 id=\"一、配置文件-babelrc\"><a href=\"#一、配置文件-babelrc\" class=\"headerlink\" title=\"一、配置文件.babelrc\"></a>一、配置文件.babelrc</h2><p>Babel的配置文件是.babelrc，存放在项目根目录下，使用Babel第一步就是配置这个文件。（<strong>该文件需要自己创建，随便新建一个txt文档把它重命名为 </strong> .xxxx. <strong> 即会最终生成 .xxxx文件，创建.bablerc 则 重命名为 </strong> .babelrc. ）。  <a href=\"http://pan.baidu.com/s/1qY2cHDq\" title=\"百度网盘下载\" target=\"_blank\" rel=\"external\">百度网盘下载</a><br>该文件用来设置转码规则和插件，基本格式如下：  </p>\n<pre><code class=\"javascript\">{\n    &quot;presets&quot;: [],\n    &quot;plugins&quot;: []\n}\n</code></pre>\n<p><strong>presets</strong>设置转码规则，官方提供以下规则集，可根据需要进行安装。 </p>\n<pre><code class=\"javascript\"># ES2015转码规则\n$ npm install --save-dev babel-preset-es2015\n\n#react转码规则\n$ npm install --save-dev babel-preset-react\n</code></pre>\n<p>将规则加入.babelrc</p>\n<pre><code class=\"javascript\">{\n    &quot;presets&quot;: [\n        &quot;es2015&quot;,\n        &quot;react&quot;\n    ],\n    &quot;plugins&quot;: []\n}\n</code></pre>\n<p>! 注意，以下所有Babel工具和模块的使用，都必须先写好.babelrc。</p>\n<h2 id=\"二、安装命令行转码babel-cli\"><a href=\"#二、安装命令行转码babel-cli\" class=\"headerlink\" title=\"二、安装命令行转码babel-cli\"></a>二、安装命令行转码babel-cli</h2><blockquote>\n<p>Babel提供babel-cli工具，用于命令行转码。</p>\n<pre><code class=\"javascript\">$ npm install --global babel-cli\n</code></pre>\n<p>基本用法如下：</p>\n<ul>\n<li><h4 id=\"转码结果输出到标准输出（即-命令行里展现\"><a href=\"#转码结果输出到标准输出（即-命令行里展现\" class=\"headerlink\" title=\"转码结果输出到标准输出（即 命令行里展现)\"></a>转码结果输出到标准输出（即 命令行里展现)</h4><pre><code class=\"javascript\">$ babel demo.js\n</code></pre>\n</li>\n<li><h4 id=\"转码结果写入一个文件-–out-file-或-o-参数指定输出文件\"><a href=\"#转码结果写入一个文件-–out-file-或-o-参数指定输出文件\" class=\"headerlink\" title=\"转码结果写入一个文件, –out-file 或 -o 参数指定输出文件\"></a>转码结果写入一个文件, –out-file 或 -o 参数指定输出文件</h4><pre><code class=\"javascript\">$ babel demo.js --out-file complete.js\n# 或者\n$ babel demo.js -o complete.js\n</code></pre>\n</li>\n<li><h4 id=\"转译目录到目录\"><a href=\"#转译目录到目录\" class=\"headerlink\" title=\"转译目录到目录\"></a>转译目录到目录</h4><pre><code class=\"javascript\">$ babel src --out-dir dist\n# 或者\nbabel src -d dist\n</code></pre>\n</li>\n<li><h4 id=\"监听文件变化\"><a href=\"#监听文件变化\" class=\"headerlink\" title=\"监听文件变化\"></a>监听文件变化</h4><pre><code class=\"javascript\">$ babel -w src -d dist\n</code></pre>\n<h5 id=\"上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel\"><a href=\"#上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel\" class=\"headerlink\" title=\"上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel\"></a>上面代码是在全局环境下，进行Babel转码。这意味着，如果项目要运行，全局环境必须有Babel</h5></li>\n</ul>\n</blockquote>\n<p>##参考：<a href=\"https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md#toc-babel-cli\" title=\"Babel 用户手册\" target=\"_blank\" rel=\"external\">Babel 用户手册</a></p>"},{"title":"FreeCodeCamp初级脚本算法题-笔记","date":"2017-06-11T16:03:36.000Z","author":"Yuqi Bi","header-img":"form-opts.png","cdn":"header-on","_content":"> [FreeCodeCamp](http://www.freecodecamp.cn/)是一个学习编程的开源社区,里面有面向前端方面的基础知识，也有一些脚本算法相关的题目，今天花了2个小时把初级脚本算法题16道，研究了一下(我刚做了15,还有一道需要研究下...后面补上+注释),通过几个小时的学习，领会到FCC是在实践练习中掌握知识，而不是学习背记理论了解知识,前端本身也是一种技术，所以多实践，多研究，才能加深对这门语言的理解.\n\n## 翻转字符串算法挑战\n```js\nconst reverseString = function (str) {\n    return str.split('').reverse().join('')\n}\n```\n## 阶乘算法挑战\n```js\nconst factorialize = function (num) {\n    let res = 1;\n    for(let i=num;i>0;i--){\n        res *= i\n    }\n    return res\n}\n```\n```js\n// 递归\nconst factorialize2 = function (num) {\n    if(num <= 1){\n        return 1\n    }\n    return num * factorialize2(num-1)\n}\n```\n## 回文算法挑战\n如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)\n```js\nconst palindrome = function (str) {\n    str = str.replace(/[^0-9a-zA-Z]/gi,'').toLowerCase()\n    const len = str.length\n    for(let i=0,j=len-1;i<len;i++,j--){\n        if(str[i] !== str[j]){\n            return false\n        }\n    }\n    return true\n}\nconsole.log(palindrome('mnnm'))\n```\n## 寻找最长的单词算法挑战\n```js\nconst findLongestWord = function (word) {\n    let words = word.split(' '),\n        max = 0,\n        len = words.length;\n    for(let i=0;i<len;i++){\n        if(words[i].length > max){\n            max = words.length\n        }\n    }\n    return max\n}\nconsole.log(findLongestWord(\"The quick brown fox jumped over the lazy dog\"))\n```\n## 设置首字母大写算法挑战.\n```js\nconst titleCase = function (w) {\n    let word = w.toLowerCase().split(' '),\n        len = word.length;\n    for(let i=0;i<len;i++){\n        let filter = word[i].charAt(0).toUpperCase()\n        word[i] = word[i].replace(word[i].charAt(0),filter)\n    }\n    return word.join(' ')\n}\nconsole.log(titleCase('I\"m a little tea pot'))\n```\n## 寻找数组中的最大值算法挑战\n大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。\n```js\nconst largestOfFour = function (arr) {\n    let len = arr.length,\n        res = [];\n    // 写个执行解析出每个数组大值得函数\n    function getMax(s){\n        let ss = s.sort(function(a,b){\n            return b - a\n        })\n        return ss[0]\n    }\n    for(let i=0;i<len;i++){\n        // 动态添加每个最大值\n        res.push(getMax(arr[i]))\n    }\n    // 返回\n    return res\n}\n\nvar stt = [[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]\nconsole.log(largestOfFour(stt))\n// [5, 27, 39, 1001]\n```\n## 确认末尾字符算法挑战\n检查一个字符串(str)是否以指定的字符串(target)结尾。\n如果是，返回true;如果不是，返回false。\n```js\nconst confirmEnding = function (str,target) {\n    let reg = new RegExp(\"\"+target+\"$\",'gi')\n    if(reg.test(str)){\n        return true\n    }\n    return false\n}\nconsole.log(confirmEnding(\"He has to give me a new name\", \"me\"))\n```\n## 重复操作算法挑战\n重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。\n```js\nconst repeat = function(str,num){\n    let res = '';\n    if(num < 0){\n        return ''\n    }\n    for(let i=0;i<=num;i++){\n        res += str\n    }\n    return res\n}\nconsole.log(repeat('ser',3))\n// serserser\n```\n## 符串截取算法挑战\n如果字符串的长度比指定的参数num长，则把多余的部分用...来表示。\n如果字符串的长度比指定的参数num短 返回原字符串\n切记，插入到字符串尾部的三个点号也会计入字符串的长度。\n但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。\n```js\nconst truncate = function(str,num){\n    let ss = '',\n        tips = '...';\n    if(str.length > num){\n        if(num > 3){\n            return str.substr(0,(num-3))+tips\n        }\n        return str.substr(0,num)+tips\n    }else{\n        return str\n    }\n}\nconsole.log(truncate(\"A-tisket a-tasket A green and yellow basket\", 8))\n// A-tis...\n```\n## 数组分割算法挑战\n把一个数组arr按照指定的数组大小size分割成若干个数组块。\n例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];\nchunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]]\nchunk([0, 1, 2, 3, 4, 5], 4) 应该返回 [[0, 1, 2, 3], [4, 5]].\n```js\n/**\n*   Math.ceil 目的是未来算出能分多少组\n*   start 每组的起始索引\n*   end 每一组的末尾索引值\n*   通过循环不停地改变启起始末尾索引，\n*   动态的截取 arr.slice 返回一个截取后的数组\n*/\nconst chunk = function (arr,size) {\n    let result = [],\n        groups = Math.ceil(arr.length/size);\n    for(let i=0;i<groups;i++){\n        let start = i * size,\n            end = start + size;\n        result.push(arr.slice(start,end))\n    }\n    return result\n}\nconsole.log(chunk([1,24,3,4,5],3)) //[Array(3), Array(2)]\n```\n## 数组截断算法挑战\n返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。\n```js\nconst slasher = function(arr,howMany){\n    if(howMany > arr.length){\n        return []\n    }\n    // 换个思路,利用slice的负数从后面截取\n    return arr.slice(howMany-arr.length)\n}\nconsole.log(slasher([1, 2, 3], 0))\n// [1, 2, 3]\n```\n## 数组查询算法挑战\n蛤蟆可以吃队友，也可以吃对手。\n如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。\n举例，[\"hello\", \"Hello\"]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。\n[\"hello\", \"hey\"]应该返回false，因为字符串\"hello\"并不包含字符\"y\"。\n[\"Alien\", \"line\"]应该返回true，因为\"line\"中所有字符都可以在\"Alien\"找到。\n```js\nconst mutation = function(arr){\n    let flag = 0,//变量 后面存储匹配ok的数量\n        left = arr[0].toLowerCase(),// 数组第一个元素\n        right = arr[1].toLowerCase();//数组第二个元素\n    for(var i=0;i<right.length;i++){\n        if(left.indexOf(right[i]) > -1){\n            // 匹配即加加\n            flag++\n        }\n    }\n    // 看是否完全匹配\n    if(flag === right.length){\n        return true\n    }\n    return false\n}\nconsole.log(mutation([\"hello\", \"llop\"]))\n```\n## 删除数组中特定值算法挑战\n真假美猴王！\n删除数组中的所有假值。\n在JavaScript中，假值有false、null、0、\"\"、undefined 和 NaN\n```js\nconst bouncer = function(arr){\n    return arr.filter((item)=>{\n        return !!item // !!返回布尔值 用过滤器过滤出为true值\n    })\n}\nconsole.log(bouncer([1, null, NaN, 2, undefined]))\n```\n## 去除数组中任意多个值算法挑战\n实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。\n```js\nconst destroyer = function(data){\n    let arr = arguments[0],\n        oData = [].slice.call(arguments,1);\n\n    for(let i=0;i<oData.length;i++){\n        for(let j=0;j<arr.length;j++){\n            if(arr[j] === oData[i]){\n                arr.splice(j,1);\n                j--;\n            }\n        }\n    }\n    return arr;\n}\nconsole.log(destroyer([3, 5, 1, 2, 2], 2, 3, 5))// [1]\n```\n## 数组排序并插入值算法挑战\n先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。\n举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。\n同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。\n```js\nconst where = function (arr,num) {\n    // 先合并\n    let res = arr.concat(num);\n    // 排序 导出索引\n    return res.sort(function(a,b){\n        return a - b\n    }).indexOf(num)\n}\nconsole.log(where([1,2,3,4],1.5))// 1\n```\n## 位移密码算法挑战(待补)\n让上帝的归上帝，凯撒的归凯撒。\n下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。\n移位密码也就是密码中的字母会按照指定的数量来做移位。\n一个常见的案例就是ROT13密码，字母会移位13个位置。由'A' ↔ 'N', 'B' ↔'O'，以此类推。\n写一个ROT13函数，实现输入加密字符串，输出解密字符串。\n所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。\nex:\nrot13(\"SERR PBQR PNZC\") 应该解码为 \"FREE CODE CAMP\"\nrot13(\"SERR CVMMN!\") 应该解码为 \"FREE PIZZA!\"\n```js\n占位\n```\n## 结语\n大家如何有更好的解决方法或者疑惑，欢迎补充和交流，可以直接联系我biyuqiwan@163.com\n","source":"_posts/FreeCodeCamp初级脚本算法题-笔记.md","raw":"---\ntitle: FreeCodeCamp初级脚本算法题-笔记\ndate: 2017-06-12 00:03:36\ntags: [javascript,'算法']\nauthor: \"Yuqi Bi\"\nheader-img: \"form-opts.png\"\ncdn: 'header-on'\n---\n> [FreeCodeCamp](http://www.freecodecamp.cn/)是一个学习编程的开源社区,里面有面向前端方面的基础知识，也有一些脚本算法相关的题目，今天花了2个小时把初级脚本算法题16道，研究了一下(我刚做了15,还有一道需要研究下...后面补上+注释),通过几个小时的学习，领会到FCC是在实践练习中掌握知识，而不是学习背记理论了解知识,前端本身也是一种技术，所以多实践，多研究，才能加深对这门语言的理解.\n\n## 翻转字符串算法挑战\n```js\nconst reverseString = function (str) {\n    return str.split('').reverse().join('')\n}\n```\n## 阶乘算法挑战\n```js\nconst factorialize = function (num) {\n    let res = 1;\n    for(let i=num;i>0;i--){\n        res *= i\n    }\n    return res\n}\n```\n```js\n// 递归\nconst factorialize2 = function (num) {\n    if(num <= 1){\n        return 1\n    }\n    return num * factorialize2(num-1)\n}\n```\n## 回文算法挑战\n如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)\n```js\nconst palindrome = function (str) {\n    str = str.replace(/[^0-9a-zA-Z]/gi,'').toLowerCase()\n    const len = str.length\n    for(let i=0,j=len-1;i<len;i++,j--){\n        if(str[i] !== str[j]){\n            return false\n        }\n    }\n    return true\n}\nconsole.log(palindrome('mnnm'))\n```\n## 寻找最长的单词算法挑战\n```js\nconst findLongestWord = function (word) {\n    let words = word.split(' '),\n        max = 0,\n        len = words.length;\n    for(let i=0;i<len;i++){\n        if(words[i].length > max){\n            max = words.length\n        }\n    }\n    return max\n}\nconsole.log(findLongestWord(\"The quick brown fox jumped over the lazy dog\"))\n```\n## 设置首字母大写算法挑战.\n```js\nconst titleCase = function (w) {\n    let word = w.toLowerCase().split(' '),\n        len = word.length;\n    for(let i=0;i<len;i++){\n        let filter = word[i].charAt(0).toUpperCase()\n        word[i] = word[i].replace(word[i].charAt(0),filter)\n    }\n    return word.join(' ')\n}\nconsole.log(titleCase('I\"m a little tea pot'))\n```\n## 寻找数组中的最大值算法挑战\n大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。\n```js\nconst largestOfFour = function (arr) {\n    let len = arr.length,\n        res = [];\n    // 写个执行解析出每个数组大值得函数\n    function getMax(s){\n        let ss = s.sort(function(a,b){\n            return b - a\n        })\n        return ss[0]\n    }\n    for(let i=0;i<len;i++){\n        // 动态添加每个最大值\n        res.push(getMax(arr[i]))\n    }\n    // 返回\n    return res\n}\n\nvar stt = [[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]\nconsole.log(largestOfFour(stt))\n// [5, 27, 39, 1001]\n```\n## 确认末尾字符算法挑战\n检查一个字符串(str)是否以指定的字符串(target)结尾。\n如果是，返回true;如果不是，返回false。\n```js\nconst confirmEnding = function (str,target) {\n    let reg = new RegExp(\"\"+target+\"$\",'gi')\n    if(reg.test(str)){\n        return true\n    }\n    return false\n}\nconsole.log(confirmEnding(\"He has to give me a new name\", \"me\"))\n```\n## 重复操作算法挑战\n重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。\n```js\nconst repeat = function(str,num){\n    let res = '';\n    if(num < 0){\n        return ''\n    }\n    for(let i=0;i<=num;i++){\n        res += str\n    }\n    return res\n}\nconsole.log(repeat('ser',3))\n// serserser\n```\n## 符串截取算法挑战\n如果字符串的长度比指定的参数num长，则把多余的部分用...来表示。\n如果字符串的长度比指定的参数num短 返回原字符串\n切记，插入到字符串尾部的三个点号也会计入字符串的长度。\n但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。\n```js\nconst truncate = function(str,num){\n    let ss = '',\n        tips = '...';\n    if(str.length > num){\n        if(num > 3){\n            return str.substr(0,(num-3))+tips\n        }\n        return str.substr(0,num)+tips\n    }else{\n        return str\n    }\n}\nconsole.log(truncate(\"A-tisket a-tasket A green and yellow basket\", 8))\n// A-tis...\n```\n## 数组分割算法挑战\n把一个数组arr按照指定的数组大小size分割成若干个数组块。\n例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];\nchunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]]\nchunk([0, 1, 2, 3, 4, 5], 4) 应该返回 [[0, 1, 2, 3], [4, 5]].\n```js\n/**\n*   Math.ceil 目的是未来算出能分多少组\n*   start 每组的起始索引\n*   end 每一组的末尾索引值\n*   通过循环不停地改变启起始末尾索引，\n*   动态的截取 arr.slice 返回一个截取后的数组\n*/\nconst chunk = function (arr,size) {\n    let result = [],\n        groups = Math.ceil(arr.length/size);\n    for(let i=0;i<groups;i++){\n        let start = i * size,\n            end = start + size;\n        result.push(arr.slice(start,end))\n    }\n    return result\n}\nconsole.log(chunk([1,24,3,4,5],3)) //[Array(3), Array(2)]\n```\n## 数组截断算法挑战\n返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。\n```js\nconst slasher = function(arr,howMany){\n    if(howMany > arr.length){\n        return []\n    }\n    // 换个思路,利用slice的负数从后面截取\n    return arr.slice(howMany-arr.length)\n}\nconsole.log(slasher([1, 2, 3], 0))\n// [1, 2, 3]\n```\n## 数组查询算法挑战\n蛤蟆可以吃队友，也可以吃对手。\n如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。\n举例，[\"hello\", \"Hello\"]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。\n[\"hello\", \"hey\"]应该返回false，因为字符串\"hello\"并不包含字符\"y\"。\n[\"Alien\", \"line\"]应该返回true，因为\"line\"中所有字符都可以在\"Alien\"找到。\n```js\nconst mutation = function(arr){\n    let flag = 0,//变量 后面存储匹配ok的数量\n        left = arr[0].toLowerCase(),// 数组第一个元素\n        right = arr[1].toLowerCase();//数组第二个元素\n    for(var i=0;i<right.length;i++){\n        if(left.indexOf(right[i]) > -1){\n            // 匹配即加加\n            flag++\n        }\n    }\n    // 看是否完全匹配\n    if(flag === right.length){\n        return true\n    }\n    return false\n}\nconsole.log(mutation([\"hello\", \"llop\"]))\n```\n## 删除数组中特定值算法挑战\n真假美猴王！\n删除数组中的所有假值。\n在JavaScript中，假值有false、null、0、\"\"、undefined 和 NaN\n```js\nconst bouncer = function(arr){\n    return arr.filter((item)=>{\n        return !!item // !!返回布尔值 用过滤器过滤出为true值\n    })\n}\nconsole.log(bouncer([1, null, NaN, 2, undefined]))\n```\n## 去除数组中任意多个值算法挑战\n实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。\n```js\nconst destroyer = function(data){\n    let arr = arguments[0],\n        oData = [].slice.call(arguments,1);\n\n    for(let i=0;i<oData.length;i++){\n        for(let j=0;j<arr.length;j++){\n            if(arr[j] === oData[i]){\n                arr.splice(j,1);\n                j--;\n            }\n        }\n    }\n    return arr;\n}\nconsole.log(destroyer([3, 5, 1, 2, 2], 2, 3, 5))// [1]\n```\n## 数组排序并插入值算法挑战\n先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。\n举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。\n同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。\n```js\nconst where = function (arr,num) {\n    // 先合并\n    let res = arr.concat(num);\n    // 排序 导出索引\n    return res.sort(function(a,b){\n        return a - b\n    }).indexOf(num)\n}\nconsole.log(where([1,2,3,4],1.5))// 1\n```\n## 位移密码算法挑战(待补)\n让上帝的归上帝，凯撒的归凯撒。\n下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。\n移位密码也就是密码中的字母会按照指定的数量来做移位。\n一个常见的案例就是ROT13密码，字母会移位13个位置。由'A' ↔ 'N', 'B' ↔'O'，以此类推。\n写一个ROT13函数，实现输入加密字符串，输出解密字符串。\n所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。\nex:\nrot13(\"SERR PBQR PNZC\") 应该解码为 \"FREE CODE CAMP\"\nrot13(\"SERR CVMMN!\") 应该解码为 \"FREE PIZZA!\"\n```js\n占位\n```\n## 结语\n大家如何有更好的解决方法或者疑惑，欢迎补充和交流，可以直接联系我biyuqiwan@163.com\n","slug":"FreeCodeCamp初级脚本算法题-笔记","published":1,"updated":"2019-09-25T15:10:25.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91np0002la2e5zy1fn06","content":"<blockquote>\n<p><a href=\"http://www.freecodecamp.cn/\" target=\"_blank\" rel=\"external\">FreeCodeCamp</a>是一个学习编程的开源社区,里面有面向前端方面的基础知识，也有一些脚本算法相关的题目，今天花了2个小时把初级脚本算法题16道，研究了一下(我刚做了15,还有一道需要研究下…后面补上+注释),通过几个小时的学习，领会到FCC是在实践练习中掌握知识，而不是学习背记理论了解知识,前端本身也是一种技术，所以多实践，多研究，才能加深对这门语言的理解.</p>\n</blockquote>\n<h2 id=\"翻转字符串算法挑战\"><a href=\"#翻转字符串算法挑战\" class=\"headerlink\" title=\"翻转字符串算法挑战\"></a>翻转字符串算法挑战</h2><pre><code class=\"js\">const reverseString = function (str) {\n    return str.split(&#39;&#39;).reverse().join(&#39;&#39;)\n}\n</code></pre>\n<h2 id=\"阶乘算法挑战\"><a href=\"#阶乘算法挑战\" class=\"headerlink\" title=\"阶乘算法挑战\"></a>阶乘算法挑战</h2><pre><code class=\"js\">const factorialize = function (num) {\n    let res = 1;\n    for(let i=num;i&gt;0;i--){\n        res *= i\n    }\n    return res\n}\n</code></pre>\n<pre><code class=\"js\">// 递归\nconst factorialize2 = function (num) {\n    if(num &lt;= 1){\n        return 1\n    }\n    return num * factorialize2(num-1)\n}\n</code></pre>\n<h2 id=\"回文算法挑战\"><a href=\"#回文算法挑战\" class=\"headerlink\" title=\"回文算法挑战\"></a>回文算法挑战</h2><p>如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)</p>\n<pre><code class=\"js\">const palindrome = function (str) {\n    str = str.replace(/[^0-9a-zA-Z]/gi,&#39;&#39;).toLowerCase()\n    const len = str.length\n    for(let i=0,j=len-1;i&lt;len;i++,j--){\n        if(str[i] !== str[j]){\n            return false\n        }\n    }\n    return true\n}\nconsole.log(palindrome(&#39;mnnm&#39;))\n</code></pre>\n<h2 id=\"寻找最长的单词算法挑战\"><a href=\"#寻找最长的单词算法挑战\" class=\"headerlink\" title=\"寻找最长的单词算法挑战\"></a>寻找最长的单词算法挑战</h2><pre><code class=\"js\">const findLongestWord = function (word) {\n    let words = word.split(&#39; &#39;),\n        max = 0,\n        len = words.length;\n    for(let i=0;i&lt;len;i++){\n        if(words[i].length &gt; max){\n            max = words.length\n        }\n    }\n    return max\n}\nconsole.log(findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;))\n</code></pre>\n<h2 id=\"设置首字母大写算法挑战\"><a href=\"#设置首字母大写算法挑战\" class=\"headerlink\" title=\"设置首字母大写算法挑战.\"></a>设置首字母大写算法挑战.</h2><pre><code class=\"js\">const titleCase = function (w) {\n    let word = w.toLowerCase().split(&#39; &#39;),\n        len = word.length;\n    for(let i=0;i&lt;len;i++){\n        let filter = word[i].charAt(0).toUpperCase()\n        word[i] = word[i].replace(word[i].charAt(0),filter)\n    }\n    return word.join(&#39; &#39;)\n}\nconsole.log(titleCase(&#39;I&quot;m a little tea pot&#39;))\n</code></pre>\n<h2 id=\"寻找数组中的最大值算法挑战\"><a href=\"#寻找数组中的最大值算法挑战\" class=\"headerlink\" title=\"寻找数组中的最大值算法挑战\"></a>寻找数组中的最大值算法挑战</h2><p>大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。</p>\n<pre><code class=\"js\">const largestOfFour = function (arr) {\n    let len = arr.length,\n        res = [];\n    // 写个执行解析出每个数组大值得函数\n    function getMax(s){\n        let ss = s.sort(function(a,b){\n            return b - a\n        })\n        return ss[0]\n    }\n    for(let i=0;i&lt;len;i++){\n        // 动态添加每个最大值\n        res.push(getMax(arr[i]))\n    }\n    // 返回\n    return res\n}\n\nvar stt = [[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]\nconsole.log(largestOfFour(stt))\n// [5, 27, 39, 1001]\n</code></pre>\n<h2 id=\"确认末尾字符算法挑战\"><a href=\"#确认末尾字符算法挑战\" class=\"headerlink\" title=\"确认末尾字符算法挑战\"></a>确认末尾字符算法挑战</h2><p>检查一个字符串(str)是否以指定的字符串(target)结尾。<br>如果是，返回true;如果不是，返回false。</p>\n<pre><code class=\"js\">const confirmEnding = function (str,target) {\n    let reg = new RegExp(&quot;&quot;+target+&quot;$&quot;,&#39;gi&#39;)\n    if(reg.test(str)){\n        return true\n    }\n    return false\n}\nconsole.log(confirmEnding(&quot;He has to give me a new name&quot;, &quot;me&quot;))\n</code></pre>\n<h2 id=\"重复操作算法挑战\"><a href=\"#重复操作算法挑战\" class=\"headerlink\" title=\"重复操作算法挑战\"></a>重复操作算法挑战</h2><p>重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。</p>\n<pre><code class=\"js\">const repeat = function(str,num){\n    let res = &#39;&#39;;\n    if(num &lt; 0){\n        return &#39;&#39;\n    }\n    for(let i=0;i&lt;=num;i++){\n        res += str\n    }\n    return res\n}\nconsole.log(repeat(&#39;ser&#39;,3))\n// serserser\n</code></pre>\n<h2 id=\"符串截取算法挑战\"><a href=\"#符串截取算法挑战\" class=\"headerlink\" title=\"符串截取算法挑战\"></a>符串截取算法挑战</h2><p>如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。<br>如果字符串的长度比指定的参数num短 返回原字符串<br>切记，插入到字符串尾部的三个点号也会计入字符串的长度。<br>但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。</p>\n<pre><code class=\"js\">const truncate = function(str,num){\n    let ss = &#39;&#39;,\n        tips = &#39;...&#39;;\n    if(str.length &gt; num){\n        if(num &gt; 3){\n            return str.substr(0,(num-3))+tips\n        }\n        return str.substr(0,num)+tips\n    }else{\n        return str\n    }\n}\nconsole.log(truncate(&quot;A-tisket a-tasket A green and yellow basket&quot;, 8))\n// A-tis...\n</code></pre>\n<h2 id=\"数组分割算法挑战\"><a href=\"#数组分割算法挑战\" class=\"headerlink\" title=\"数组分割算法挑战\"></a>数组分割算法挑战</h2><p>把一个数组arr按照指定的数组大小size分割成若干个数组块。<br>例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];<br>chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]]<br>chunk([0, 1, 2, 3, 4, 5], 4) 应该返回 [[0, 1, 2, 3], [4, 5]].</p>\n<pre><code class=\"js\">/**\n*   Math.ceil 目的是未来算出能分多少组\n*   start 每组的起始索引\n*   end 每一组的末尾索引值\n*   通过循环不停地改变启起始末尾索引，\n*   动态的截取 arr.slice 返回一个截取后的数组\n*/\nconst chunk = function (arr,size) {\n    let result = [],\n        groups = Math.ceil(arr.length/size);\n    for(let i=0;i&lt;groups;i++){\n        let start = i * size,\n            end = start + size;\n        result.push(arr.slice(start,end))\n    }\n    return result\n}\nconsole.log(chunk([1,24,3,4,5],3)) //[Array(3), Array(2)]\n</code></pre>\n<h2 id=\"数组截断算法挑战\"><a href=\"#数组截断算法挑战\" class=\"headerlink\" title=\"数组截断算法挑战\"></a>数组截断算法挑战</h2><p>返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。</p>\n<pre><code class=\"js\">const slasher = function(arr,howMany){\n    if(howMany &gt; arr.length){\n        return []\n    }\n    // 换个思路,利用slice的负数从后面截取\n    return arr.slice(howMany-arr.length)\n}\nconsole.log(slasher([1, 2, 3], 0))\n// [1, 2, 3]\n</code></pre>\n<h2 id=\"数组查询算法挑战\"><a href=\"#数组查询算法挑战\" class=\"headerlink\" title=\"数组查询算法挑战\"></a>数组查询算法挑战</h2><p>蛤蟆可以吃队友，也可以吃对手。<br>如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。<br>举例，[“hello”, “Hello”]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。<br>[“hello”, “hey”]应该返回false，因为字符串”hello”并不包含字符”y”。<br>[“Alien”, “line”]应该返回true，因为”line”中所有字符都可以在”Alien”找到。</p>\n<pre><code class=\"js\">const mutation = function(arr){\n    let flag = 0,//变量 后面存储匹配ok的数量\n        left = arr[0].toLowerCase(),// 数组第一个元素\n        right = arr[1].toLowerCase();//数组第二个元素\n    for(var i=0;i&lt;right.length;i++){\n        if(left.indexOf(right[i]) &gt; -1){\n            // 匹配即加加\n            flag++\n        }\n    }\n    // 看是否完全匹配\n    if(flag === right.length){\n        return true\n    }\n    return false\n}\nconsole.log(mutation([&quot;hello&quot;, &quot;llop&quot;]))\n</code></pre>\n<h2 id=\"删除数组中特定值算法挑战\"><a href=\"#删除数组中特定值算法挑战\" class=\"headerlink\" title=\"删除数组中特定值算法挑战\"></a>删除数组中特定值算法挑战</h2><p>真假美猴王！<br>删除数组中的所有假值。<br>在JavaScript中，假值有false、null、0、””、undefined 和 NaN</p>\n<pre><code class=\"js\">const bouncer = function(arr){\n    return arr.filter((item)=&gt;{\n        return !!item // !!返回布尔值 用过滤器过滤出为true值\n    })\n}\nconsole.log(bouncer([1, null, NaN, 2, undefined]))\n</code></pre>\n<h2 id=\"去除数组中任意多个值算法挑战\"><a href=\"#去除数组中任意多个值算法挑战\" class=\"headerlink\" title=\"去除数组中任意多个值算法挑战\"></a>去除数组中任意多个值算法挑战</h2><p>实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。</p>\n<pre><code class=\"js\">const destroyer = function(data){\n    let arr = arguments[0],\n        oData = [].slice.call(arguments,1);\n\n    for(let i=0;i&lt;oData.length;i++){\n        for(let j=0;j&lt;arr.length;j++){\n            if(arr[j] === oData[i]){\n                arr.splice(j,1);\n                j--;\n            }\n        }\n    }\n    return arr;\n}\nconsole.log(destroyer([3, 5, 1, 2, 2], 2, 3, 5))// [1]\n</code></pre>\n<h2 id=\"数组排序并插入值算法挑战\"><a href=\"#数组排序并插入值算法挑战\" class=\"headerlink\" title=\"数组排序并插入值算法挑战\"></a>数组排序并插入值算法挑战</h2><p>先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。<br>举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。<br>同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。</p>\n<pre><code class=\"js\">const where = function (arr,num) {\n    // 先合并\n    let res = arr.concat(num);\n    // 排序 导出索引\n    return res.sort(function(a,b){\n        return a - b\n    }).indexOf(num)\n}\nconsole.log(where([1,2,3,4],1.5))// 1\n</code></pre>\n<h2 id=\"位移密码算法挑战-待补\"><a href=\"#位移密码算法挑战-待补\" class=\"headerlink\" title=\"位移密码算法挑战(待补)\"></a>位移密码算法挑战(待补)</h2><p>让上帝的归上帝，凯撒的归凯撒。<br>下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。<br>移位密码也就是密码中的字母会按照指定的数量来做移位。<br>一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔’O’，以此类推。<br>写一个ROT13函数，实现输入加密字符串，输出解密字符串。<br>所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。<br>ex:<br>rot13(“SERR PBQR PNZC”) 应该解码为 “FREE CODE CAMP”<br>rot13(“SERR CVMMN!”) 应该解码为 “FREE PIZZA!”</p>\n<pre><code class=\"js\">占位\n</code></pre>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>大家如何有更好的解决方法或者疑惑，欢迎补充和交流，可以直接联系我biyuqiwan@163.com</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"http://www.freecodecamp.cn/\" target=\"_blank\" rel=\"external\">FreeCodeCamp</a>是一个学习编程的开源社区,里面有面向前端方面的基础知识，也有一些脚本算法相关的题目，今天花了2个小时把初级脚本算法题16道，研究了一下(我刚做了15,还有一道需要研究下…后面补上+注释),通过几个小时的学习，领会到FCC是在实践练习中掌握知识，而不是学习背记理论了解知识,前端本身也是一种技术，所以多实践，多研究，才能加深对这门语言的理解.</p>\n</blockquote>\n<h2 id=\"翻转字符串算法挑战\"><a href=\"#翻转字符串算法挑战\" class=\"headerlink\" title=\"翻转字符串算法挑战\"></a>翻转字符串算法挑战</h2><pre><code class=\"js\">const reverseString = function (str) {\n    return str.split(&#39;&#39;).reverse().join(&#39;&#39;)\n}\n</code></pre>\n<h2 id=\"阶乘算法挑战\"><a href=\"#阶乘算法挑战\" class=\"headerlink\" title=\"阶乘算法挑战\"></a>阶乘算法挑战</h2><pre><code class=\"js\">const factorialize = function (num) {\n    let res = 1;\n    for(let i=num;i&gt;0;i--){\n        res *= i\n    }\n    return res\n}\n</code></pre>\n<pre><code class=\"js\">// 递归\nconst factorialize2 = function (num) {\n    if(num &lt;= 1){\n        return 1\n    }\n    return num * factorialize2(num-1)\n}\n</code></pre>\n<h2 id=\"回文算法挑战\"><a href=\"#回文算法挑战\" class=\"headerlink\" title=\"回文算法挑战\"></a>回文算法挑战</h2><p>如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)</p>\n<pre><code class=\"js\">const palindrome = function (str) {\n    str = str.replace(/[^0-9a-zA-Z]/gi,&#39;&#39;).toLowerCase()\n    const len = str.length\n    for(let i=0,j=len-1;i&lt;len;i++,j--){\n        if(str[i] !== str[j]){\n            return false\n        }\n    }\n    return true\n}\nconsole.log(palindrome(&#39;mnnm&#39;))\n</code></pre>\n<h2 id=\"寻找最长的单词算法挑战\"><a href=\"#寻找最长的单词算法挑战\" class=\"headerlink\" title=\"寻找最长的单词算法挑战\"></a>寻找最长的单词算法挑战</h2><pre><code class=\"js\">const findLongestWord = function (word) {\n    let words = word.split(&#39; &#39;),\n        max = 0,\n        len = words.length;\n    for(let i=0;i&lt;len;i++){\n        if(words[i].length &gt; max){\n            max = words.length\n        }\n    }\n    return max\n}\nconsole.log(findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;))\n</code></pre>\n<h2 id=\"设置首字母大写算法挑战\"><a href=\"#设置首字母大写算法挑战\" class=\"headerlink\" title=\"设置首字母大写算法挑战.\"></a>设置首字母大写算法挑战.</h2><pre><code class=\"js\">const titleCase = function (w) {\n    let word = w.toLowerCase().split(&#39; &#39;),\n        len = word.length;\n    for(let i=0;i&lt;len;i++){\n        let filter = word[i].charAt(0).toUpperCase()\n        word[i] = word[i].replace(word[i].charAt(0),filter)\n    }\n    return word.join(&#39; &#39;)\n}\nconsole.log(titleCase(&#39;I&quot;m a little tea pot&#39;))\n</code></pre>\n<h2 id=\"寻找数组中的最大值算法挑战\"><a href=\"#寻找数组中的最大值算法挑战\" class=\"headerlink\" title=\"寻找数组中的最大值算法挑战\"></a>寻找数组中的最大值算法挑战</h2><p>大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。</p>\n<pre><code class=\"js\">const largestOfFour = function (arr) {\n    let len = arr.length,\n        res = [];\n    // 写个执行解析出每个数组大值得函数\n    function getMax(s){\n        let ss = s.sort(function(a,b){\n            return b - a\n        })\n        return ss[0]\n    }\n    for(let i=0;i&lt;len;i++){\n        // 动态添加每个最大值\n        res.push(getMax(arr[i]))\n    }\n    // 返回\n    return res\n}\n\nvar stt = [[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]\nconsole.log(largestOfFour(stt))\n// [5, 27, 39, 1001]\n</code></pre>\n<h2 id=\"确认末尾字符算法挑战\"><a href=\"#确认末尾字符算法挑战\" class=\"headerlink\" title=\"确认末尾字符算法挑战\"></a>确认末尾字符算法挑战</h2><p>检查一个字符串(str)是否以指定的字符串(target)结尾。<br>如果是，返回true;如果不是，返回false。</p>\n<pre><code class=\"js\">const confirmEnding = function (str,target) {\n    let reg = new RegExp(&quot;&quot;+target+&quot;$&quot;,&#39;gi&#39;)\n    if(reg.test(str)){\n        return true\n    }\n    return false\n}\nconsole.log(confirmEnding(&quot;He has to give me a new name&quot;, &quot;me&quot;))\n</code></pre>\n<h2 id=\"重复操作算法挑战\"><a href=\"#重复操作算法挑战\" class=\"headerlink\" title=\"重复操作算法挑战\"></a>重复操作算法挑战</h2><p>重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。</p>\n<pre><code class=\"js\">const repeat = function(str,num){\n    let res = &#39;&#39;;\n    if(num &lt; 0){\n        return &#39;&#39;\n    }\n    for(let i=0;i&lt;=num;i++){\n        res += str\n    }\n    return res\n}\nconsole.log(repeat(&#39;ser&#39;,3))\n// serserser\n</code></pre>\n<h2 id=\"符串截取算法挑战\"><a href=\"#符串截取算法挑战\" class=\"headerlink\" title=\"符串截取算法挑战\"></a>符串截取算法挑战</h2><p>如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。<br>如果字符串的长度比指定的参数num短 返回原字符串<br>切记，插入到字符串尾部的三个点号也会计入字符串的长度。<br>但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。</p>\n<pre><code class=\"js\">const truncate = function(str,num){\n    let ss = &#39;&#39;,\n        tips = &#39;...&#39;;\n    if(str.length &gt; num){\n        if(num &gt; 3){\n            return str.substr(0,(num-3))+tips\n        }\n        return str.substr(0,num)+tips\n    }else{\n        return str\n    }\n}\nconsole.log(truncate(&quot;A-tisket a-tasket A green and yellow basket&quot;, 8))\n// A-tis...\n</code></pre>\n<h2 id=\"数组分割算法挑战\"><a href=\"#数组分割算法挑战\" class=\"headerlink\" title=\"数组分割算法挑战\"></a>数组分割算法挑战</h2><p>把一个数组arr按照指定的数组大小size分割成若干个数组块。<br>例如:chunk([1,2,3,4],2)=[[1,2],[3,4]];<br>chunk([1,2,3,4,5],2)=[[1,2],[3,4],[5]]<br>chunk([0, 1, 2, 3, 4, 5], 4) 应该返回 [[0, 1, 2, 3], [4, 5]].</p>\n<pre><code class=\"js\">/**\n*   Math.ceil 目的是未来算出能分多少组\n*   start 每组的起始索引\n*   end 每一组的末尾索引值\n*   通过循环不停地改变启起始末尾索引，\n*   动态的截取 arr.slice 返回一个截取后的数组\n*/\nconst chunk = function (arr,size) {\n    let result = [],\n        groups = Math.ceil(arr.length/size);\n    for(let i=0;i&lt;groups;i++){\n        let start = i * size,\n            end = start + size;\n        result.push(arr.slice(start,end))\n    }\n    return result\n}\nconsole.log(chunk([1,24,3,4,5],3)) //[Array(3), Array(2)]\n</code></pre>\n<h2 id=\"数组截断算法挑战\"><a href=\"#数组截断算法挑战\" class=\"headerlink\" title=\"数组截断算法挑战\"></a>数组截断算法挑战</h2><p>返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。</p>\n<pre><code class=\"js\">const slasher = function(arr,howMany){\n    if(howMany &gt; arr.length){\n        return []\n    }\n    // 换个思路,利用slice的负数从后面截取\n    return arr.slice(howMany-arr.length)\n}\nconsole.log(slasher([1, 2, 3], 0))\n// [1, 2, 3]\n</code></pre>\n<h2 id=\"数组查询算法挑战\"><a href=\"#数组查询算法挑战\" class=\"headerlink\" title=\"数组查询算法挑战\"></a>数组查询算法挑战</h2><p>蛤蟆可以吃队友，也可以吃对手。<br>如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。<br>举例，[“hello”, “Hello”]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。<br>[“hello”, “hey”]应该返回false，因为字符串”hello”并不包含字符”y”。<br>[“Alien”, “line”]应该返回true，因为”line”中所有字符都可以在”Alien”找到。</p>\n<pre><code class=\"js\">const mutation = function(arr){\n    let flag = 0,//变量 后面存储匹配ok的数量\n        left = arr[0].toLowerCase(),// 数组第一个元素\n        right = arr[1].toLowerCase();//数组第二个元素\n    for(var i=0;i&lt;right.length;i++){\n        if(left.indexOf(right[i]) &gt; -1){\n            // 匹配即加加\n            flag++\n        }\n    }\n    // 看是否完全匹配\n    if(flag === right.length){\n        return true\n    }\n    return false\n}\nconsole.log(mutation([&quot;hello&quot;, &quot;llop&quot;]))\n</code></pre>\n<h2 id=\"删除数组中特定值算法挑战\"><a href=\"#删除数组中特定值算法挑战\" class=\"headerlink\" title=\"删除数组中特定值算法挑战\"></a>删除数组中特定值算法挑战</h2><p>真假美猴王！<br>删除数组中的所有假值。<br>在JavaScript中，假值有false、null、0、””、undefined 和 NaN</p>\n<pre><code class=\"js\">const bouncer = function(arr){\n    return arr.filter((item)=&gt;{\n        return !!item // !!返回布尔值 用过滤器过滤出为true值\n    })\n}\nconsole.log(bouncer([1, null, NaN, 2, undefined]))\n</code></pre>\n<h2 id=\"去除数组中任意多个值算法挑战\"><a href=\"#去除数组中任意多个值算法挑战\" class=\"headerlink\" title=\"去除数组中任意多个值算法挑战\"></a>去除数组中任意多个值算法挑战</h2><p>实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。</p>\n<pre><code class=\"js\">const destroyer = function(data){\n    let arr = arguments[0],\n        oData = [].slice.call(arguments,1);\n\n    for(let i=0;i&lt;oData.length;i++){\n        for(let j=0;j&lt;arr.length;j++){\n            if(arr[j] === oData[i]){\n                arr.splice(j,1);\n                j--;\n            }\n        }\n    }\n    return arr;\n}\nconsole.log(destroyer([3, 5, 1, 2, 2], 2, 3, 5))// [1]\n</code></pre>\n<h2 id=\"数组排序并插入值算法挑战\"><a href=\"#数组排序并插入值算法挑战\" class=\"headerlink\" title=\"数组排序并插入值算法挑战\"></a>数组排序并插入值算法挑战</h2><p>先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。<br>举例：where([1,2,3,4], 1.5) 应该返回 1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。<br>同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2。</p>\n<pre><code class=\"js\">const where = function (arr,num) {\n    // 先合并\n    let res = arr.concat(num);\n    // 排序 导出索引\n    return res.sort(function(a,b){\n        return a - b\n    }).indexOf(num)\n}\nconsole.log(where([1,2,3,4],1.5))// 1\n</code></pre>\n<h2 id=\"位移密码算法挑战-待补\"><a href=\"#位移密码算法挑战-待补\" class=\"headerlink\" title=\"位移密码算法挑战(待补)\"></a>位移密码算法挑战(待补)</h2><p>让上帝的归上帝，凯撒的归凯撒。<br>下面我们来介绍风靡全球的凯撒密码Caesar cipher，又叫移位密码。<br>移位密码也就是密码中的字母会按照指定的数量来做移位。<br>一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔’O’，以此类推。<br>写一个ROT13函数，实现输入加密字符串，输出解密字符串。<br>所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，跳过它们。<br>ex:<br>rot13(“SERR PBQR PNZC”) 应该解码为 “FREE CODE CAMP”<br>rot13(“SERR CVMMN!”) 应该解码为 “FREE PIZZA!”</p>\n<pre><code class=\"js\">占位\n</code></pre>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>大家如何有更好的解决方法或者疑惑，欢迎补充和交流，可以直接联系我biyuqiwan@163.com</p>\n"},{"title":"Git问题备忘录","date":"2019-10-01T15:30:30.000Z","_content":"\n> 日常开发，难免会遇到各种Git问题，特此记录.\n\n- fatal: Unable to create '/path/my_project/.git/index.lock': File exists\n\n```bash\nrm -f ./.git/index.lock\n```\n\n- 重置所有commit提交信息\n\n```basj\ngit rebase -i --root\n```\n\n- 大小写敏感\n```bash\ngit config core.ignorecase false\n```\n\n- 新增远程仓库地址\n\n```bash\ngit remote add origin [url]\n```\n","source":"_posts/Git 问题备忘录.md","raw":"---\ntitle: Git问题备忘录\ndate: 2019-10-01 23:30:30\ntags: [git, 'github']\ncategories: Git\n---\n\n> 日常开发，难免会遇到各种Git问题，特此记录.\n\n- fatal: Unable to create '/path/my_project/.git/index.lock': File exists\n\n```bash\nrm -f ./.git/index.lock\n```\n\n- 重置所有commit提交信息\n\n```basj\ngit rebase -i --root\n```\n\n- 大小写敏感\n```bash\ngit config core.ignorecase false\n```\n\n- 新增远程仓库地址\n\n```bash\ngit remote add origin [url]\n```\n","slug":"Git 问题备忘录","published":1,"updated":"2019-10-01T15:25:41.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ns0006la2ekpu8swb4","content":"<blockquote>\n<p>日常开发，难免会遇到各种Git问题，特此记录.</p>\n</blockquote>\n<ul>\n<li>fatal: Unable to create ‘/path/my_project/.git/index.lock’: File exists</li>\n</ul>\n<pre><code class=\"bash\">rm -f ./.git/index.lock\n</code></pre>\n<ul>\n<li>重置所有commit提交信息</li>\n</ul>\n<pre><code class=\"basj\">git rebase -i --root\n</code></pre>\n<ul>\n<li><p>大小写敏感</p>\n<pre><code class=\"bash\">git config core.ignorecase false\n</code></pre>\n</li>\n<li><p>新增远程仓库地址</p>\n</li>\n</ul>\n<pre><code class=\"bash\">git remote add origin [url]\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>日常开发，难免会遇到各种Git问题，特此记录.</p>\n</blockquote>\n<ul>\n<li>fatal: Unable to create ‘/path/my_project/.git/index.lock’: File exists</li>\n</ul>\n<pre><code class=\"bash\">rm -f ./.git/index.lock\n</code></pre>\n<ul>\n<li>重置所有commit提交信息</li>\n</ul>\n<pre><code class=\"basj\">git rebase -i --root\n</code></pre>\n<ul>\n<li><p>大小写敏感</p>\n<pre><code class=\"bash\">git config core.ignorecase false\n</code></pre>\n</li>\n<li><p>新增远程仓库地址</p>\n</li>\n</ul>\n<pre><code class=\"bash\">git remote add origin [url]\n</code></pre>\n"},{"title":"Git如何合并多个commit","date":"2018-12-16T03:30:30.000Z","_content":"\n> 项目开发中，很多时候都是单独开一个新的分支，完成一个模块，在该分支上由于功能较大，或者保险起见，我们可能会多次commit我们的文件,但是在提交的时候，我们不希望一个功能出现多次commit,导致review代码不便，所以经常在提交前，合并下我们的commit记录. 特此记录\n\n### 前言\n\n`git rebase`的黄金法则便是: 绝不要在公共的分支上使用它\n\n### 假设我们有四个commit\n\n`git log` 查看提交日志.\n\n> 注: `glgg` 命令为`oh-my-zsh`附带aliases, 如果没有安装可自动忽略, 采用git原生操作即可, 下面不多做解释\n\n![这是图片位置](http://loadingmore-1254319003.file.myqcloud.com/git-commit-compose.png)\n\n### 通过 git rebase -i <commit hash> 执行合并操作\n\n* 我们将commit为 `Add four part` `Add third part` `Add two part` 合并到 `Add first part`\n* 并修改最后的commit信息\n\n![这是执行命令的图片](http://loadingmore-1254319003.file.myqcloud.com/git-rebase-i-hash.png)\n\n> 进入rebase时可以指定一个commit范围，比如：\n> git rebase -i HEAD~5. 这样也是\b可行的\n\n解释下，-i选项用来交互式地运行变基, 必须指定想要重写多久远的历史，即指定commit hash, 本例是指定到第一条commit hash 接着我们就进入到vim的编辑模式\n\n> --interactive let the user edit the list of commits to rebase\n\n> vim下 i是进入编辑模式, esc退出编辑模式, :wq 退出并保存\n\n![进入vim编辑模式图片](http://loadingmore-1254319003.file.myqcloud.com/git-rebase-i-vim.png)\n\n图中上半部分为主注释的是可编辑部分,下半部分是指令的说明. 由指令名称, commit hash, commit message组成\n\n### 修改指令\n\n`squash`命令会合并到前一个commit\n\n![选中s](http://loadingmore-1254319003.file.myqcloud.com/git-squash.png)\n\n命令行中`pick` 改为 `s`或`squash` 然后保存退出(esc, :wq)回车即可\n\n\b再次出现命令行，提示让重新修改提交commit message\n![](http://loadingmore-1254319003.file.myqcloud.com/git-tip-edit.png)\n\n其中, 非注释部分就是三次的 commit message, 你要做的就是删除最后留一个,写成你想提交的message, 保存退出即可\n\n该处我们修改为: `Add compose feature`\n\n保存退出(esc, :wq)回车 显示如下， 已经成功修改\n\n![](http://loadingmore-1254319003.file.myqcloud.com/git-edit-rename.png)\n\n查看下本地是否合并：\n![](http://loadingmore-1254319003.file.myqcloud.com/git-last.png)\n可以看到已经修改成功了，write-blog分支上只有一条提交记录了\n\n最后：\n`git push origin <your branch>`\n\n注意：\n如果该分支上是已经提交server的\bcommit,提交的时候需要 `git push origin <your branch> -f`\n\n","source":"_posts/Git合并多个commit.md","raw":"---\ntitle: Git如何合并多个commit\ndate: 2018-12-16 11:30:30\ntags: [git, 'github']\ncategories: Git\n---\n\n> 项目开发中，很多时候都是单独开一个新的分支，完成一个模块，在该分支上由于功能较大，或者保险起见，我们可能会多次commit我们的文件,但是在提交的时候，我们不希望一个功能出现多次commit,导致review代码不便，所以经常在提交前，合并下我们的commit记录. 特此记录\n\n### 前言\n\n`git rebase`的黄金法则便是: 绝不要在公共的分支上使用它\n\n### 假设我们有四个commit\n\n`git log` 查看提交日志.\n\n> 注: `glgg` 命令为`oh-my-zsh`附带aliases, 如果没有安装可自动忽略, 采用git原生操作即可, 下面不多做解释\n\n![这是图片位置](http://loadingmore-1254319003.file.myqcloud.com/git-commit-compose.png)\n\n### 通过 git rebase -i <commit hash> 执行合并操作\n\n* 我们将commit为 `Add four part` `Add third part` `Add two part` 合并到 `Add first part`\n* 并修改最后的commit信息\n\n![这是执行命令的图片](http://loadingmore-1254319003.file.myqcloud.com/git-rebase-i-hash.png)\n\n> 进入rebase时可以指定一个commit范围，比如：\n> git rebase -i HEAD~5. 这样也是\b可行的\n\n解释下，-i选项用来交互式地运行变基, 必须指定想要重写多久远的历史，即指定commit hash, 本例是指定到第一条commit hash 接着我们就进入到vim的编辑模式\n\n> --interactive let the user edit the list of commits to rebase\n\n> vim下 i是进入编辑模式, esc退出编辑模式, :wq 退出并保存\n\n![进入vim编辑模式图片](http://loadingmore-1254319003.file.myqcloud.com/git-rebase-i-vim.png)\n\n图中上半部分为主注释的是可编辑部分,下半部分是指令的说明. 由指令名称, commit hash, commit message组成\n\n### 修改指令\n\n`squash`命令会合并到前一个commit\n\n![选中s](http://loadingmore-1254319003.file.myqcloud.com/git-squash.png)\n\n命令行中`pick` 改为 `s`或`squash` 然后保存退出(esc, :wq)回车即可\n\n\b再次出现命令行，提示让重新修改提交commit message\n![](http://loadingmore-1254319003.file.myqcloud.com/git-tip-edit.png)\n\n其中, 非注释部分就是三次的 commit message, 你要做的就是删除最后留一个,写成你想提交的message, 保存退出即可\n\n该处我们修改为: `Add compose feature`\n\n保存退出(esc, :wq)回车 显示如下， 已经成功修改\n\n![](http://loadingmore-1254319003.file.myqcloud.com/git-edit-rename.png)\n\n查看下本地是否合并：\n![](http://loadingmore-1254319003.file.myqcloud.com/git-last.png)\n可以看到已经修改成功了，write-blog分支上只有一条提交记录了\n\n最后：\n`git push origin <your branch>`\n\n注意：\n如果该分支上是已经提交server的\bcommit,提交的时候需要 `git push origin <your branch> -f`\n\n","slug":"Git合并多个commit","published":1,"updated":"2019-09-25T15:10:25.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91nu0008la2e5kdto8oa","content":"<blockquote>\n<p>项目开发中，很多时候都是单独开一个新的分支，完成一个模块，在该分支上由于功能较大，或者保险起见，我们可能会多次commit我们的文件,但是在提交的时候，我们不希望一个功能出现多次commit,导致review代码不便，所以经常在提交前，合并下我们的commit记录. 特此记录</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>git rebase</code>的黄金法则便是: 绝不要在公共的分支上使用它</p>\n<h3 id=\"假设我们有四个commit\"><a href=\"#假设我们有四个commit\" class=\"headerlink\" title=\"假设我们有四个commit\"></a>假设我们有四个commit</h3><p><code>git log</code> 查看提交日志.</p>\n<blockquote>\n<p>注: <code>glgg</code> 命令为<code>oh-my-zsh</code>附带aliases, 如果没有安装可自动忽略, 采用git原生操作即可, 下面不多做解释</p>\n</blockquote>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-commit-compose.png\" alt=\"这是图片位置\"></p>\n<h3 id=\"通过-git-rebase-i-执行合并操作\"><a href=\"#通过-git-rebase-i-执行合并操作\" class=\"headerlink\" title=\"通过 git rebase -i  执行合并操作\"></a>通过 git rebase -i <commit hash=\"\"> 执行合并操作</commit></h3><ul>\n<li>我们将commit为 <code>Add four part</code> <code>Add third part</code> <code>Add two part</code> 合并到 <code>Add first part</code></li>\n<li>并修改最后的commit信息</li>\n</ul>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-rebase-i-hash.png\" alt=\"这是执行命令的图片\"></p>\n<blockquote>\n<p>进入rebase时可以指定一个commit范围，比如：<br>git rebase -i HEAD~5. 这样也是\b可行的</p>\n</blockquote>\n<p>解释下，-i选项用来交互式地运行变基, 必须指定想要重写多久远的历史，即指定commit hash, 本例是指定到第一条commit hash 接着我们就进入到vim的编辑模式</p>\n<blockquote>\n<p>–interactive let the user edit the list of commits to rebase</p>\n<p>vim下 i是进入编辑模式, esc退出编辑模式, :wq 退出并保存</p>\n</blockquote>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-rebase-i-vim.png\" alt=\"进入vim编辑模式图片\"></p>\n<p>图中上半部分为主注释的是可编辑部分,下半部分是指令的说明. 由指令名称, commit hash, commit message组成</p>\n<h3 id=\"修改指令\"><a href=\"#修改指令\" class=\"headerlink\" title=\"修改指令\"></a>修改指令</h3><p><code>squash</code>命令会合并到前一个commit</p>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-squash.png\" alt=\"选中s\"></p>\n<p>命令行中<code>pick</code> 改为 <code>s</code>或<code>squash</code> 然后保存退出(esc, :wq)回车即可</p>\n<p>\b再次出现命令行，提示让重新修改提交commit message<br><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-tip-edit.png\" alt=\"\"></p>\n<p>其中, 非注释部分就是三次的 commit message, 你要做的就是删除最后留一个,写成你想提交的message, 保存退出即可</p>\n<p>该处我们修改为: <code>Add compose feature</code></p>\n<p>保存退出(esc, :wq)回车 显示如下， 已经成功修改</p>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-edit-rename.png\" alt=\"\"></p>\n<p>查看下本地是否合并：<br><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-last.png\" alt=\"\"><br>可以看到已经修改成功了，write-blog分支上只有一条提交记录了</p>\n<p>最后：<br><code>git push origin &lt;your branch&gt;</code></p>\n<p>注意：<br>如果该分支上是已经提交server的\bcommit,提交的时候需要 <code>git push origin &lt;your branch&gt; -f</code></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>项目开发中，很多时候都是单独开一个新的分支，完成一个模块，在该分支上由于功能较大，或者保险起见，我们可能会多次commit我们的文件,但是在提交的时候，我们不希望一个功能出现多次commit,导致review代码不便，所以经常在提交前，合并下我们的commit记录. 特此记录</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>git rebase</code>的黄金法则便是: 绝不要在公共的分支上使用它</p>\n<h3 id=\"假设我们有四个commit\"><a href=\"#假设我们有四个commit\" class=\"headerlink\" title=\"假设我们有四个commit\"></a>假设我们有四个commit</h3><p><code>git log</code> 查看提交日志.</p>\n<blockquote>\n<p>注: <code>glgg</code> 命令为<code>oh-my-zsh</code>附带aliases, 如果没有安装可自动忽略, 采用git原生操作即可, 下面不多做解释</p>\n</blockquote>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-commit-compose.png\" alt=\"这是图片位置\"></p>\n<h3 id=\"通过-git-rebase-i-执行合并操作\"><a href=\"#通过-git-rebase-i-执行合并操作\" class=\"headerlink\" title=\"通过 git rebase -i  执行合并操作\"></a>通过 git rebase -i <commit hash=\"\"> 执行合并操作</commit></h3><ul>\n<li>我们将commit为 <code>Add four part</code> <code>Add third part</code> <code>Add two part</code> 合并到 <code>Add first part</code></li>\n<li>并修改最后的commit信息</li>\n</ul>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-rebase-i-hash.png\" alt=\"这是执行命令的图片\"></p>\n<blockquote>\n<p>进入rebase时可以指定一个commit范围，比如：<br>git rebase -i HEAD~5. 这样也是\b可行的</p>\n</blockquote>\n<p>解释下，-i选项用来交互式地运行变基, 必须指定想要重写多久远的历史，即指定commit hash, 本例是指定到第一条commit hash 接着我们就进入到vim的编辑模式</p>\n<blockquote>\n<p>–interactive let the user edit the list of commits to rebase</p>\n<p>vim下 i是进入编辑模式, esc退出编辑模式, :wq 退出并保存</p>\n</blockquote>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-rebase-i-vim.png\" alt=\"进入vim编辑模式图片\"></p>\n<p>图中上半部分为主注释的是可编辑部分,下半部分是指令的说明. 由指令名称, commit hash, commit message组成</p>\n<h3 id=\"修改指令\"><a href=\"#修改指令\" class=\"headerlink\" title=\"修改指令\"></a>修改指令</h3><p><code>squash</code>命令会合并到前一个commit</p>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-squash.png\" alt=\"选中s\"></p>\n<p>命令行中<code>pick</code> 改为 <code>s</code>或<code>squash</code> 然后保存退出(esc, :wq)回车即可</p>\n<p>\b再次出现命令行，提示让重新修改提交commit message<br><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-tip-edit.png\" alt=\"\"></p>\n<p>其中, 非注释部分就是三次的 commit message, 你要做的就是删除最后留一个,写成你想提交的message, 保存退出即可</p>\n<p>该处我们修改为: <code>Add compose feature</code></p>\n<p>保存退出(esc, :wq)回车 显示如下， 已经成功修改</p>\n<p><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-edit-rename.png\" alt=\"\"></p>\n<p>查看下本地是否合并：<br><img src=\"http://loadingmore-1254319003.file.myqcloud.com/git-last.png\" alt=\"\"><br>可以看到已经修改成功了，write-blog分支上只有一条提交记录了</p>\n<p>最后：<br><code>git push origin &lt;your branch&gt;</code></p>\n<p>注意：<br>如果该分支上是已经提交server的\bcommit,提交的时候需要 <code>git push origin &lt;your branch&gt; -f</code></p>\n"},{"title":"Git如何修改commit提交顺序","date":"2018-12-16T10:23:30.000Z","_content":"\n> 有时候也会遇到需要把commit的顺序调整的情况，比较小众的需求 记录下\n\n### 前言\n\n`git rebase`的黄金法则便是: 绝不要在公共的分支上使用它\n\n### 分类\n\n* 单个文件，或者单一功能(耦合性低)的commit移动\n* 同一个文件的移动(冲突概率比较大)\n\n### 开始\n\n首先我们准备几个提交记录:\n可以看到提交的顺序 `add skip merge` `add skip merge2` `add skip merge3`, 我们的目标是颠倒下顺序 `add skip merge3` `add skip merge2` `add skip merge`\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge0.png)\n\n首先进行变基操作 `git rebase -i HEAD~3`, 进入\b交互页面执行可编辑命令字母`i`\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge1.png)\n\n进行移动操作`command + c` `command + v` or `ctrl + c` `ctrl + v` 等\b一系列操作后如下:\n\n可以看到已经调了顺序\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge3.png)\n\n退出编辑`esc`,保存`:wq`\n显示操作成功\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge4.png)\n\n查看日志`git log`\n可以看到已经成功的修改了commit提交顺序\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge5.png)\n\n### 遇到冲突\n\n\n","source":"_posts/Git如何修改commit提交顺序.md","raw":"---\ntitle: Git如何修改commit提交顺序\ndate: 2018-12-16 18:23:30\ntags: [git, 'github']\ncategories: Git\n---\n\n> 有时候也会遇到需要把commit的顺序调整的情况，比较小众的需求 记录下\n\n### 前言\n\n`git rebase`的黄金法则便是: 绝不要在公共的分支上使用它\n\n### 分类\n\n* 单个文件，或者单一功能(耦合性低)的commit移动\n* 同一个文件的移动(冲突概率比较大)\n\n### 开始\n\n首先我们准备几个提交记录:\n可以看到提交的顺序 `add skip merge` `add skip merge2` `add skip merge3`, 我们的目标是颠倒下顺序 `add skip merge3` `add skip merge2` `add skip merge`\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge0.png)\n\n首先进行变基操作 `git rebase -i HEAD~3`, 进入\b交互页面执行可编辑命令字母`i`\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge1.png)\n\n进行移动操作`command + c` `command + v` or `ctrl + c` `ctrl + v` 等\b一系列操作后如下:\n\n可以看到已经调了顺序\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge3.png)\n\n退出编辑`esc`,保存`:wq`\n显示操作成功\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge4.png)\n\n查看日志`git log`\n可以看到已经成功的修改了commit提交顺序\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge5.png)\n\n### 遇到冲突\n\n\n","slug":"Git如何修改commit提交顺序","published":1,"updated":"2019-09-25T15:10:25.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91nw000ala2ea2etgqyw","content":"<blockquote>\n<p>有时候也会遇到需要把commit的顺序调整的情况，比较小众的需求 记录下</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>git rebase</code>的黄金法则便是: 绝不要在公共的分支上使用它</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>单个文件，或者单一功能(耦合性低)的commit移动</li>\n<li>同一个文件的移动(冲突概率比较大)</li>\n</ul>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>首先我们准备几个提交记录:<br>可以看到提交的顺序 <code>add skip merge</code> <code>add skip merge2</code> <code>add skip merge3</code>, 我们的目标是颠倒下顺序 <code>add skip merge3</code> <code>add skip merge2</code> <code>add skip merge</code></p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge0.png\" alt=\"\"></p>\n<p>首先进行变基操作 <code>git rebase -i HEAD~3</code>, 进入\b交互页面执行可编辑命令字母<code>i</code><br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge1.png\" alt=\"\"></p>\n<p>进行移动操作<code>command + c</code> <code>command + v</code> or <code>ctrl + c</code> <code>ctrl + v</code> 等\b一系列操作后如下:</p>\n<p>可以看到已经调了顺序<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge3.png\" alt=\"\"></p>\n<p>退出编辑<code>esc</code>,保存<code>:wq</code><br>显示操作成功</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge4.png\" alt=\"\"></p>\n<p>查看日志<code>git log</code><br>可以看到已经成功的修改了commit提交顺序</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge5.png\" alt=\"\"></p>\n<h3 id=\"遇到冲突\"><a href=\"#遇到冲突\" class=\"headerlink\" title=\"遇到冲突\"></a>遇到冲突</h3>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>有时候也会遇到需要把commit的顺序调整的情况，比较小众的需求 记录下</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>git rebase</code>的黄金法则便是: 绝不要在公共的分支上使用它</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><ul>\n<li>单个文件，或者单一功能(耦合性低)的commit移动</li>\n<li>同一个文件的移动(冲突概率比较大)</li>\n</ul>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>首先我们准备几个提交记录:<br>可以看到提交的顺序 <code>add skip merge</code> <code>add skip merge2</code> <code>add skip merge3</code>, 我们的目标是颠倒下顺序 <code>add skip merge3</code> <code>add skip merge2</code> <code>add skip merge</code></p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge0.png\" alt=\"\"></p>\n<p>首先进行变基操作 <code>git rebase -i HEAD~3</code>, 进入\b交互页面执行可编辑命令字母<code>i</code><br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge1.png\" alt=\"\"></p>\n<p>进行移动操作<code>command + c</code> <code>command + v</code> or <code>ctrl + c</code> <code>ctrl + v</code> 等\b一系列操作后如下:</p>\n<p>可以看到已经调了顺序<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge3.png\" alt=\"\"></p>\n<p>退出编辑<code>esc</code>,保存<code>:wq</code><br>显示操作成功</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge4.png\" alt=\"\"></p>\n<p>查看日志<code>git log</code><br>可以看到已经成功的修改了commit提交顺序</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/skip-merge5.png\" alt=\"\"></p>\n<h3 id=\"遇到冲突\"><a href=\"#遇到冲突\" class=\"headerlink\" title=\"遇到冲突\"></a>遇到冲突</h3>"},{"title":"Git如何修改最新commit的message","date":"2018-12-17T15:17:30.000Z","_content":"> 项目开发中经常会有修改已经提交commit信息的情况,这里做分析下修改最后一次的提交记录.\n\n### 前言\n\n`git rebase`的黄金法则便是: 绝不要在公共的分支上使用它\n\n### 准备commit提交信息\n\n这里我们准备了两个提交记录: `I am the second commit on edit-new-commit branch`, `I am the first commit on edit-new-commit branch`.\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit0.png)\n\n我们准备把最后一条记录`I am the second commit on edit-new-commit branch`修改为`I am the last commit on edit-new-commit branch`.  即`second` > `last`.\n\n### 执行命令\n\n首先我们执行命令:\n\n`git commit --amend`\n\n进入到如下界面：\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit1.png)\n\n执行回车，会看到如下页面, 即最后一次commit的\b界面\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit2.png)\n\n然后回到熟悉的节奏, 进入编辑状态`i`, 然后把信息修改即可\n\n![修改后的界面](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit3.png)\n\n然后退出`esc`, 保存`:wq`, 回车即可\n\n### 查看\n\n成功\b操作:\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit4.png)\n\n最后查看我们的log验证, 已经成功修改\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit5.png)\n\n### 提交\n最后的提交\n`git push origin <your branch name>`\n\nNote: \n如果是修改server端最后一条记录，\b则需要执行最后的提交\n`git push origin <your branch name> -f`\n\n\n","source":"_posts/Git如何修改最新commit的message.md","raw":"---\ntitle: Git如何修改最新commit的message\ndate: 2018-12-17 23:17:30\ntags: [git, 'github']\ncategories: Git\n---\n> 项目开发中经常会有修改已经提交commit信息的情况,这里做分析下修改最后一次的提交记录.\n\n### 前言\n\n`git rebase`的黄金法则便是: 绝不要在公共的分支上使用它\n\n### 准备commit提交信息\n\n这里我们准备了两个提交记录: `I am the second commit on edit-new-commit branch`, `I am the first commit on edit-new-commit branch`.\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit0.png)\n\n我们准备把最后一条记录`I am the second commit on edit-new-commit branch`修改为`I am the last commit on edit-new-commit branch`.  即`second` > `last`.\n\n### 执行命令\n\n首先我们执行命令:\n\n`git commit --amend`\n\n进入到如下界面：\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit1.png)\n\n执行回车，会看到如下页面, 即最后一次commit的\b界面\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit2.png)\n\n然后回到熟悉的节奏, 进入编辑状态`i`, 然后把信息修改即可\n\n![修改后的界面](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit3.png)\n\n然后退出`esc`, 保存`:wq`, 回车即可\n\n### 查看\n\n成功\b操作:\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit4.png)\n\n最后查看我们的log验证, 已经成功修改\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit5.png)\n\n### 提交\n最后的提交\n`git push origin <your branch name>`\n\nNote: \n如果是修改server端最后一条记录，\b则需要执行最后的提交\n`git push origin <your branch name> -f`\n\n\n","slug":"Git如何修改最新commit的message","published":1,"updated":"2019-09-25T15:10:25.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91nx000dla2ehlr9k796","content":"<blockquote>\n<p>项目开发中经常会有修改已经提交commit信息的情况,这里做分析下修改最后一次的提交记录.</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>git rebase</code>的黄金法则便是: 绝不要在公共的分支上使用它</p>\n<h3 id=\"准备commit提交信息\"><a href=\"#准备commit提交信息\" class=\"headerlink\" title=\"准备commit提交信息\"></a>准备commit提交信息</h3><p>这里我们准备了两个提交记录: <code>I am the second commit on edit-new-commit branch</code>, <code>I am the first commit on edit-new-commit branch</code>.</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit0.png\" alt=\"\"></p>\n<p>我们准备把最后一条记录<code>I am the second commit on edit-new-commit branch</code>修改为<code>I am the last commit on edit-new-commit branch</code>.  即<code>second</code> &gt; <code>last</code>.</p>\n<h3 id=\"执行命令\"><a href=\"#执行命令\" class=\"headerlink\" title=\"执行命令\"></a>执行命令</h3><p>首先我们执行命令:</p>\n<p><code>git commit --amend</code></p>\n<p>进入到如下界面：<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit1.png\" alt=\"\"></p>\n<p>执行回车，会看到如下页面, 即最后一次commit的\b界面<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit2.png\" alt=\"\"></p>\n<p>然后回到熟悉的节奏, 进入编辑状态<code>i</code>, 然后把信息修改即可</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit3.png\" alt=\"修改后的界面\"></p>\n<p>然后退出<code>esc</code>, 保存<code>:wq</code>, 回车即可</p>\n<h3 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h3><p>成功\b操作:<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit4.png\" alt=\"\"></p>\n<p>最后查看我们的log验证, 已经成功修改<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit5.png\" alt=\"\"></p>\n<h3 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h3><p>最后的提交<br><code>git push origin &lt;your branch name&gt;</code></p>\n<p>Note:<br>如果是修改server端最后一条记录，\b则需要执行最后的提交<br><code>git push origin &lt;your branch name&gt; -f</code></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>项目开发中经常会有修改已经提交commit信息的情况,这里做分析下修改最后一次的提交记录.</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>git rebase</code>的黄金法则便是: 绝不要在公共的分支上使用它</p>\n<h3 id=\"准备commit提交信息\"><a href=\"#准备commit提交信息\" class=\"headerlink\" title=\"准备commit提交信息\"></a>准备commit提交信息</h3><p>这里我们准备了两个提交记录: <code>I am the second commit on edit-new-commit branch</code>, <code>I am the first commit on edit-new-commit branch</code>.</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit0.png\" alt=\"\"></p>\n<p>我们准备把最后一条记录<code>I am the second commit on edit-new-commit branch</code>修改为<code>I am the last commit on edit-new-commit branch</code>.  即<code>second</code> &gt; <code>last</code>.</p>\n<h3 id=\"执行命令\"><a href=\"#执行命令\" class=\"headerlink\" title=\"执行命令\"></a>执行命令</h3><p>首先我们执行命令:</p>\n<p><code>git commit --amend</code></p>\n<p>进入到如下界面：<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit1.png\" alt=\"\"></p>\n<p>执行回车，会看到如下页面, 即最后一次commit的\b界面<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit2.png\" alt=\"\"></p>\n<p>然后回到熟悉的节奏, 进入编辑状态<code>i</code>, 然后把信息修改即可</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit3.png\" alt=\"修改后的界面\"></p>\n<p>然后退出<code>esc</code>, 保存<code>:wq</code>, 回车即可</p>\n<h3 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h3><p>成功\b操作:<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit4.png\" alt=\"\"></p>\n<p>最后查看我们的log验证, 已经成功修改<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-new-commit5.png\" alt=\"\"></p>\n<h3 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h3><p>最后的提交<br><code>git push origin &lt;your branch name&gt;</code></p>\n<p>Note:<br>如果是修改server端最后一条记录，\b则需要执行最后的提交<br><code>git push origin &lt;your branch name&gt; -f</code></p>\n"},{"title":"Git如何修改老旧commit的message","date":"2018-12-18T12:30:30.000Z","_content":"\n> 项目开发中经常会有修改已经提交commit信息的情况,这里做分析下修改老旧commit(非最新)的提交记录.\n\n### 前言\n\n`git rebase`的黄金法则便是: 绝不要在公共的分支上使用它\n\n### 准备commit提交信息\n\n老规矩，先准备几条commit信息\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old0.png)\n\n然后执行命令`git rebase -i HEAD~3`进入修改模式\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old1.png)\n\n接下来我们修改第一次提交的commit信息`Change the eslint config`, 我们改为`Change the eslint base config`\n\n进入编辑`i`模式, 注意一行\b注释命令`# e, edit = use commit, but stop for amending\n` 用edit来实现我们的功能\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old2.png)\n\n退出`esc`, `:wq`保存\n\n会弹出以下信息\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old3.png)\n\n不要惊慌，我们根据提示进行操作\n`You can amend the commit now, with git commit --amend`, 意思是如果要修改commit, 那么就执行这个命令吧.\n\n> 当然了，如果你是手抖，或者不想修改了就执行 `Once you are satisfied with your changes, run git rebase --continue`\n\n![执行--ammend](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old4.png)\n\n然后回到熟悉的节奏\n![有木有很熟悉](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old5.png)\n\n### 开始修改\n接下来按照最初的设想开始修改吧\n\n照旧执行`i`，进入编辑模式修改\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old6.png)\n\n完了,退出`esc`,保存`:wq`\n\n![显示已经修改成功](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old7.png)\n\n现在已经commit，但是rebase操作还没结束。若要通知这个提交的操作已经结束，请指定 --continue选项执行rebase。\n`git rebase --continue`\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old8.png)\n\n至此我们修改大业才算完成。\n\n### 验收\n打个log验收下成果吧\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old9.png)\n\n\n### 最后\n\n提交代码\n\n`git push origin <your branch>`\n\n如果修改的是server端需要加`-f`\n\n`git push origin <your branch> -f`\n\n> `-f` 是 --force的缩写\n\n\n\n\n","source":"_posts/Git如何修改老旧commit的message.md","raw":"---\ntitle: Git如何修改老旧commit的message\ndate: 2018-12-18 20:30:30\ntags: [git, 'github']\ncategories: Git\n---\n\n> 项目开发中经常会有修改已经提交commit信息的情况,这里做分析下修改老旧commit(非最新)的提交记录.\n\n### 前言\n\n`git rebase`的黄金法则便是: 绝不要在公共的分支上使用它\n\n### 准备commit提交信息\n\n老规矩，先准备几条commit信息\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old0.png)\n\n然后执行命令`git rebase -i HEAD~3`进入修改模式\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old1.png)\n\n接下来我们修改第一次提交的commit信息`Change the eslint config`, 我们改为`Change the eslint base config`\n\n进入编辑`i`模式, 注意一行\b注释命令`# e, edit = use commit, but stop for amending\n` 用edit来实现我们的功能\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old2.png)\n\n退出`esc`, `:wq`保存\n\n会弹出以下信息\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old3.png)\n\n不要惊慌，我们根据提示进行操作\n`You can amend the commit now, with git commit --amend`, 意思是如果要修改commit, 那么就执行这个命令吧.\n\n> 当然了，如果你是手抖，或者不想修改了就执行 `Once you are satisfied with your changes, run git rebase --continue`\n\n![执行--ammend](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old4.png)\n\n然后回到熟悉的节奏\n![有木有很熟悉](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old5.png)\n\n### 开始修改\n接下来按照最初的设想开始修改吧\n\n照旧执行`i`，进入编辑模式修改\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old6.png)\n\n完了,退出`esc`,保存`:wq`\n\n![显示已经修改成功](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old7.png)\n\n现在已经commit，但是rebase操作还没结束。若要通知这个提交的操作已经结束，请指定 --continue选项执行rebase。\n`git rebase --continue`\n\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old8.png)\n\n至此我们修改大业才算完成。\n\n### 验收\n打个log验收下成果吧\n![](http://loadingmore-1254319003.coscd.myqcloud.com/edit-old9.png)\n\n\n### 最后\n\n提交代码\n\n`git push origin <your branch>`\n\n如果修改的是server端需要加`-f`\n\n`git push origin <your branch> -f`\n\n> `-f` 是 --force的缩写\n\n\n\n\n","slug":"Git如何修改老旧commit的message","published":1,"updated":"2019-09-25T15:10:25.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ny000fla2emmdr2hna","content":"<blockquote>\n<p>项目开发中经常会有修改已经提交commit信息的情况,这里做分析下修改老旧commit(非最新)的提交记录.</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>git rebase</code>的黄金法则便是: 绝不要在公共的分支上使用它</p>\n<h3 id=\"准备commit提交信息\"><a href=\"#准备commit提交信息\" class=\"headerlink\" title=\"准备commit提交信息\"></a>准备commit提交信息</h3><p>老规矩，先准备几条commit信息</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old0.png\" alt=\"\"></p>\n<p>然后执行命令<code>git rebase -i HEAD~3</code>进入修改模式</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old1.png\" alt=\"\"></p>\n<p>接下来我们修改第一次提交的commit信息<code>Change the eslint config</code>, 我们改为<code>Change the eslint base config</code></p>\n<p>进入编辑<code>i</code>模式, 注意一行\b注释命令<code># e, edit = use commit, but stop for amending</code> 用edit来实现我们的功能</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old2.png\" alt=\"\"></p>\n<p>退出<code>esc</code>, <code>:wq</code>保存</p>\n<p>会弹出以下信息</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old3.png\" alt=\"\"></p>\n<p>不要惊慌，我们根据提示进行操作<br><code>You can amend the commit now, with git commit --amend</code>, 意思是如果要修改commit, 那么就执行这个命令吧.</p>\n<blockquote>\n<p>当然了，如果你是手抖，或者不想修改了就执行 <code>Once you are satisfied with your changes, run git rebase --continue</code></p>\n</blockquote>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old4.png\" alt=\"执行--ammend\"></p>\n<p>然后回到熟悉的节奏<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old5.png\" alt=\"有木有很熟悉\"></p>\n<h3 id=\"开始修改\"><a href=\"#开始修改\" class=\"headerlink\" title=\"开始修改\"></a>开始修改</h3><p>接下来按照最初的设想开始修改吧</p>\n<p>照旧执行<code>i</code>，进入编辑模式修改</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old6.png\" alt=\"\"></p>\n<p>完了,退出<code>esc</code>,保存<code>:wq</code></p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old7.png\" alt=\"显示已经修改成功\"></p>\n<p>现在已经commit，但是rebase操作还没结束。若要通知这个提交的操作已经结束，请指定 –continue选项执行rebase。<br><code>git rebase --continue</code></p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old8.png\" alt=\"\"></p>\n<p>至此我们修改大业才算完成。</p>\n<h3 id=\"验收\"><a href=\"#验收\" class=\"headerlink\" title=\"验收\"></a>验收</h3><p>打个log验收下成果吧<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old9.png\" alt=\"\"></p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>提交代码</p>\n<p><code>git push origin &lt;your branch&gt;</code></p>\n<p>如果修改的是server端需要加<code>-f</code></p>\n<p><code>git push origin &lt;your branch&gt; -f</code></p>\n<blockquote>\n<p><code>-f</code> 是 –force的缩写</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>项目开发中经常会有修改已经提交commit信息的情况,这里做分析下修改老旧commit(非最新)的提交记录.</p>\n</blockquote>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><code>git rebase</code>的黄金法则便是: 绝不要在公共的分支上使用它</p>\n<h3 id=\"准备commit提交信息\"><a href=\"#准备commit提交信息\" class=\"headerlink\" title=\"准备commit提交信息\"></a>准备commit提交信息</h3><p>老规矩，先准备几条commit信息</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old0.png\" alt=\"\"></p>\n<p>然后执行命令<code>git rebase -i HEAD~3</code>进入修改模式</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old1.png\" alt=\"\"></p>\n<p>接下来我们修改第一次提交的commit信息<code>Change the eslint config</code>, 我们改为<code>Change the eslint base config</code></p>\n<p>进入编辑<code>i</code>模式, 注意一行\b注释命令<code># e, edit = use commit, but stop for amending</code> 用edit来实现我们的功能</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old2.png\" alt=\"\"></p>\n<p>退出<code>esc</code>, <code>:wq</code>保存</p>\n<p>会弹出以下信息</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old3.png\" alt=\"\"></p>\n<p>不要惊慌，我们根据提示进行操作<br><code>You can amend the commit now, with git commit --amend</code>, 意思是如果要修改commit, 那么就执行这个命令吧.</p>\n<blockquote>\n<p>当然了，如果你是手抖，或者不想修改了就执行 <code>Once you are satisfied with your changes, run git rebase --continue</code></p>\n</blockquote>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old4.png\" alt=\"执行--ammend\"></p>\n<p>然后回到熟悉的节奏<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old5.png\" alt=\"有木有很熟悉\"></p>\n<h3 id=\"开始修改\"><a href=\"#开始修改\" class=\"headerlink\" title=\"开始修改\"></a>开始修改</h3><p>接下来按照最初的设想开始修改吧</p>\n<p>照旧执行<code>i</code>，进入编辑模式修改</p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old6.png\" alt=\"\"></p>\n<p>完了,退出<code>esc</code>,保存<code>:wq</code></p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old7.png\" alt=\"显示已经修改成功\"></p>\n<p>现在已经commit，但是rebase操作还没结束。若要通知这个提交的操作已经结束，请指定 –continue选项执行rebase。<br><code>git rebase --continue</code></p>\n<p><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old8.png\" alt=\"\"></p>\n<p>至此我们修改大业才算完成。</p>\n<h3 id=\"验收\"><a href=\"#验收\" class=\"headerlink\" title=\"验收\"></a>验收</h3><p>打个log验收下成果吧<br><img src=\"http://loadingmore-1254319003.coscd.myqcloud.com/edit-old9.png\" alt=\"\"></p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>提交代码</p>\n<p><code>git push origin &lt;your branch&gt;</code></p>\n<p>如果修改的是server端需要加<code>-f</code></p>\n<p><code>git push origin &lt;your branch&gt; -f</code></p>\n<blockquote>\n<p><code>-f</code> 是 –force的缩写</p>\n</blockquote>\n"},{"title":"Git如何克隆指定的分支","date":"2019-10-12T15:54:16.000Z","_content":"\n> 偶尔会遇到只想克隆指定分支的情况，不想下载主分支，所以有了这篇文章.\n\n## 使用\n\n在Git`1.7.10`及更高版本中，添加`--single-branch`以防止提取所有分支.\n`<folder>` 可以指定克隆岛某个文件夹\n`branchname` 需要克隆的分支名\n`url` 远程仓库地址\n`--branch` 创建分支， 亦可用`-b`代替\n\n```js\ngit clone --branch  <branchname> <url> --single-branch [<folder>]\n```\n","source":"_posts/Git如何克隆指定分支.md","raw":"---\ntitle: Git如何克隆指定的分支\ndate: 2019-10-12 23:54:16\ntags: [Git, single-clone]\ncategories: Git\n---\n\n> 偶尔会遇到只想克隆指定分支的情况，不想下载主分支，所以有了这篇文章.\n\n## 使用\n\n在Git`1.7.10`及更高版本中，添加`--single-branch`以防止提取所有分支.\n`<folder>` 可以指定克隆岛某个文件夹\n`branchname` 需要克隆的分支名\n`url` 远程仓库地址\n`--branch` 创建分支， 亦可用`-b`代替\n\n```js\ngit clone --branch  <branchname> <url> --single-branch [<folder>]\n```\n","slug":"Git如何克隆指定分支","published":1,"updated":"2019-10-19T00:03:25.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o1000ila2erbu52add","content":"<blockquote>\n<p>偶尔会遇到只想克隆指定分支的情况，不想下载主分支，所以有了这篇文章.</p>\n</blockquote>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>在Git<code>1.7.10</code>及更高版本中，添加<code>--single-branch</code>以防止提取所有分支.<br><code>&lt;folder&gt;</code> 可以指定克隆岛某个文件夹<br><code>branchname</code> 需要克隆的分支名<br><code>url</code> 远程仓库地址<br><code>--branch</code> 创建分支， 亦可用<code>-b</code>代替</p>\n<pre><code class=\"js\">git clone --branch  &lt;branchname&gt; &lt;url&gt; --single-branch [&lt;folder&gt;]\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>偶尔会遇到只想克隆指定分支的情况，不想下载主分支，所以有了这篇文章.</p>\n</blockquote>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>在Git<code>1.7.10</code>及更高版本中，添加<code>--single-branch</code>以防止提取所有分支.<br><code>&lt;folder&gt;</code> 可以指定克隆岛某个文件夹<br><code>branchname</code> 需要克隆的分支名<br><code>url</code> 远程仓库地址<br><code>--branch</code> 创建分支， 亦可用<code>-b</code>代替</p>\n<pre><code class=\"js\">git clone --branch  &lt;branchname&gt; &lt;url&gt; --single-branch [&lt;folder&gt;]\n</code></pre>\n"},{"title":"Git重命名本地分支名和远程分支名","date":"2019-06-12T15:30:30.000Z","_content":"> 如果你错误的命名了一个分支名并且推送到了远端服务器，你可以在被发现之前得到修正\n\n##### 1.重命名本地分支\n如果你在你想要改名的分支上：\n```js\ngit branch -m new-name\n```\n如果你在其他分支上：\n```js\ngit branch -m old-name new-name\n```\n\n##### 2.删除远端分支并推送本地的新分支\n```js\ngit push origin :old-name new-name\n```\n\n##### 3.重命名本地分支的上游分支：\n切换到该分支然后：\n```js\ngit push origin -u new-name\n```\n\n","source":"_posts/Git重命名本地分支名和远程分支名.md","raw":"---\ntitle: Git重命名本地分支名和远程分支名\ndate: 2019-06-12 23:30:30\ntags: [git, 'github']\ncategories: Git\n---\n> 如果你错误的命名了一个分支名并且推送到了远端服务器，你可以在被发现之前得到修正\n\n##### 1.重命名本地分支\n如果你在你想要改名的分支上：\n```js\ngit branch -m new-name\n```\n如果你在其他分支上：\n```js\ngit branch -m old-name new-name\n```\n\n##### 2.删除远端分支并推送本地的新分支\n```js\ngit push origin :old-name new-name\n```\n\n##### 3.重命名本地分支的上游分支：\n切换到该分支然后：\n```js\ngit push origin -u new-name\n```\n\n","slug":"Git重命名本地分支名和远程分支名","published":1,"updated":"2019-09-25T15:10:25.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o2000lla2edchljveb","content":"<blockquote>\n<p>如果你错误的命名了一个分支名并且推送到了远端服务器，你可以在被发现之前得到修正</p>\n</blockquote>\n<h5 id=\"1-重命名本地分支\"><a href=\"#1-重命名本地分支\" class=\"headerlink\" title=\"1.重命名本地分支\"></a>1.重命名本地分支</h5><p>如果你在你想要改名的分支上：</p>\n<pre><code class=\"js\">git branch -m new-name\n</code></pre>\n<p>如果你在其他分支上：</p>\n<pre><code class=\"js\">git branch -m old-name new-name\n</code></pre>\n<h5 id=\"2-删除远端分支并推送本地的新分支\"><a href=\"#2-删除远端分支并推送本地的新分支\" class=\"headerlink\" title=\"2.删除远端分支并推送本地的新分支\"></a>2.删除远端分支并推送本地的新分支</h5><pre><code class=\"js\">git push origin :old-name new-name\n</code></pre>\n<h5 id=\"3-重命名本地分支的上游分支：\"><a href=\"#3-重命名本地分支的上游分支：\" class=\"headerlink\" title=\"3.重命名本地分支的上游分支：\"></a>3.重命名本地分支的上游分支：</h5><p>切换到该分支然后：</p>\n<pre><code class=\"js\">git push origin -u new-name\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>如果你错误的命名了一个分支名并且推送到了远端服务器，你可以在被发现之前得到修正</p>\n</blockquote>\n<h5 id=\"1-重命名本地分支\"><a href=\"#1-重命名本地分支\" class=\"headerlink\" title=\"1.重命名本地分支\"></a>1.重命名本地分支</h5><p>如果你在你想要改名的分支上：</p>\n<pre><code class=\"js\">git branch -m new-name\n</code></pre>\n<p>如果你在其他分支上：</p>\n<pre><code class=\"js\">git branch -m old-name new-name\n</code></pre>\n<h5 id=\"2-删除远端分支并推送本地的新分支\"><a href=\"#2-删除远端分支并推送本地的新分支\" class=\"headerlink\" title=\"2.删除远端分支并推送本地的新分支\"></a>2.删除远端分支并推送本地的新分支</h5><pre><code class=\"js\">git push origin :old-name new-name\n</code></pre>\n<h5 id=\"3-重命名本地分支的上游分支：\"><a href=\"#3-重命名本地分支的上游分支：\" class=\"headerlink\" title=\"3.重命名本地分支的上游分支：\"></a>3.重命名本地分支的上游分支：</h5><p>切换到该分支然后：</p>\n<pre><code class=\"js\">git push origin -u new-name\n</code></pre>\n"},{"title":"Js函数的throttle(节流)和debounce(防抖)","date":"2017-03-02T05:00:12.000Z","_content":"> ** 某些场景下，比如响应鼠标移动或者影响窗口大小的resize事件,scroll事件,导致频繁的触发DOM操作，资源加载等重行为，导致页面卡顿甚至浏览器崩溃;网上看到一些解决的方案，遂做记录 **\n\n![sdf][3]\n<!-- more -->\n### 什么是debounce? 什么场景用? 怎么实现?\n** 关键词查询**\n\n解释这个函数前，先想想如下场景：网站我们的网站有个搜索框，用户输入文本我们会自动联想匹配一些结果呈现给给用户，我们可能首先想到的就是监听keypress事件,然后进行一步查询结果,该方法本身没有问题，但是如果用户哭诉输入一连串几十个字符，那就要瞬间触发几十次请求，无疑,我们不想要这样的结果，我们要的是用户停止输入的时候才去触发查询请求,这个时候函数防抖就可以帮到我们.\n\n**电梯超时**\n\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。\n\n**函数防抖**\n\n就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。\n* 如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。\n* 也就是说当调用动作n毫秒后，才会执行该动作，\n* 若在这n毫秒内又调用此动作则将重新计算执行时间。\n\n**实现**\n```javascript\n/**\n* 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 delay,callback 才会执行\n* @param delay   {number}    空闲时间，单位毫秒\n* @param callback {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nfunction debounce(delay,callback){\n    var timer = null;\n    return function(){\n        var that = this,\n            args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(function(){\n            callback.apply(that,args);\n        },delay)\n    }\n}\n//demo\n//keypress时间结束200毫秒后执行相关回调事件\n$('.input').addEventListener('keypress',debounce(200,function(){\n    //do somecode\n},false))\n```\n### 什么是throttle? 什么场景用? 怎么实现?\n**scroll事件**\n\n网站开发中经常会遇到这样的需求就是滚动浏览器滚动条的时候，更新页面上的某些布局或者数据或者调用后台的某些接口,同样，如果不对scroll函数加以限制的话,我们滚动一次滚动条就会产生N多次的调用了,throttle跟debounce不同,不是在等待某个时间后去执行函数，二是每间隔某个时间去执行函数\n\n**自助饮料机**\n\n好比一台自动的饮料机，按拿铁按钮，在出饮料的过程中，不管按多少这个按钮，都不会连续出饮料，中间按钮的响应会被忽略，必须要等这一杯的容量全部出完之后，再按拿铁按钮才会出下一杯。\n\n**函数节流**\n\n每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。\n* 形像的比喻是水龙头或机枪，你可以控制它的流量或频率。\n* throttle 的关注点是连续的执行间隔时间。\n* 也就是会说预先设定一个执行周期，当调用动作的时刻大于\n* 等于执行周期则执行该动作，然后进入下一个新周期。\n\n**实现**\n```javascript\n/**\n* 频率控制 返回函数连续调用时，callback 执行频率限定为 次/delay  \n* 不满足间隔时间,延迟times后必须执行一次\n* @param delay  {number}    间隔时间，单位毫秒\n* @param times  {number}    延迟时间，单位毫秒\n* @param callback {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nfunction throttle(delay,times,callback){\n    var startTime = (new Date()).getTime(),\n        timer = null;\n    return function(){\n        var currTime = (new Date()).getTime(),\n            that = this,\n            args = arguments;\n        clearTimeout(timer);\n        if(currTime - startTime >= delay){\n            callback.apply(that,args);\n            startTime = currTime;\n        }else{\n            timer = setTimeout(function(){\n                callback.apply(that,args);\n            },times)\n        }\n    }\n}\n\n```\n```javascript\n//Demo\n//图片懒加,就是一个不断需要滚动条来判断距离的一个解决方案;\n//通过scroll时间不断的判断,为了避免大量的scroll触发,\n//我们可以用throttle对其进行节流操作\n//仅仅做演示 html css均不提供，后文会给出demo\nfunction lazyload(){\n    var okSeeHeight = document.documentElement.clientHeight;//可视区域高度\n    var curScrollTop = document.body.scrollTop || document.documentElement.scrollTop;//滚动条高度\n    var imgNums = document.querySelectorAll('img'),\n        len = imgNums.length,\n        sn = 0;//初始化图片位置 避免每次都重新计算\n    for(var i=sn; i<len; i++){\n        //到达可视区域\n        if(imgNums[i].offsetTop < okSeeHeight + curScrollTop){\n            //替换scr\n            imgNums[i].src = imgNums[i].getAttribute('data-src');\n            sn = i + 1;\n        }\n    }\n}\n//调用即可\n//可以大大减少scroll的触发量,而不影响体验\n//500毫秒执行  不满足就强制500毫秒运行一次回调函数\nwindow.addEventListener('scroll',throttle(500,500,lazyload))\n```\n### 使用场景\n只要牵涉到连续事件或频率控制相关的应用都可以考虑到这两个函数，比如：\n\n* 游戏射击，keydown 事件\n* 文本输入、自动完成，keyup 事件\n* 鼠标移动，mousemove 事件\n* DOM 元素动态定位，window 对象的 resize 和 scroll 事件\n\n前两者 debounce 和 throttle 都可以按需使用；后两者肯定是用 throttle 了。如果不做过滤处理，每秒种甚至会触发数十次相应的事件。尤其是 mousemove 事件，每移动一像素都可能触发一次事件。如果是在一个画布上做一个鼠标相关的应用，过滤事件处理是必须的，否则肯定会造成糟糕的体验。\n\n### 图片懒加载演示DEMO\n**[图片懒加载节流优化][4]**\n\n**[github地址][1]**\n### 参考\n* [肥仔John][2]\n* [高阶函数 debounce 和 throttle][5]\n\n\n\n[1]: https://github.com/BiYuqi/lazyloading-img\n[2]: http://www.cnblogs.com/fsjohnhuang/p/4147810.html\n[3]: http://oiukswkar.bkt.clouddn.com/throttle.jpg\n[4]: http://loadingmore.com/demo/src/html/lazyload.html\n[5]: http://www.cnblogs.com/ambar/archive/2011/10/08/throttle-and-debounce.html\n","source":"_posts/JS函数的throttle(节流)和debounce(抖动).md","raw":"---\ntitle: Js函数的throttle(节流)和debounce(防抖)\ndate: 2017-03-02 13:00:12\ntags: [javascript,'函数']\ncategories: Javascript\n---\n> ** 某些场景下，比如响应鼠标移动或者影响窗口大小的resize事件,scroll事件,导致频繁的触发DOM操作，资源加载等重行为，导致页面卡顿甚至浏览器崩溃;网上看到一些解决的方案，遂做记录 **\n\n![sdf][3]\n<!-- more -->\n### 什么是debounce? 什么场景用? 怎么实现?\n** 关键词查询**\n\n解释这个函数前，先想想如下场景：网站我们的网站有个搜索框，用户输入文本我们会自动联想匹配一些结果呈现给给用户，我们可能首先想到的就是监听keypress事件,然后进行一步查询结果,该方法本身没有问题，但是如果用户哭诉输入一连串几十个字符，那就要瞬间触发几十次请求，无疑,我们不想要这样的结果，我们要的是用户停止输入的时候才去触发查询请求,这个时候函数防抖就可以帮到我们.\n\n**电梯超时**\n\n想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。\n\n**函数防抖**\n\n就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。\n* 如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。\n* 也就是说当调用动作n毫秒后，才会执行该动作，\n* 若在这n毫秒内又调用此动作则将重新计算执行时间。\n\n**实现**\n```javascript\n/**\n* 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 delay,callback 才会执行\n* @param delay   {number}    空闲时间，单位毫秒\n* @param callback {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nfunction debounce(delay,callback){\n    var timer = null;\n    return function(){\n        var that = this,\n            args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(function(){\n            callback.apply(that,args);\n        },delay)\n    }\n}\n//demo\n//keypress时间结束200毫秒后执行相关回调事件\n$('.input').addEventListener('keypress',debounce(200,function(){\n    //do somecode\n},false))\n```\n### 什么是throttle? 什么场景用? 怎么实现?\n**scroll事件**\n\n网站开发中经常会遇到这样的需求就是滚动浏览器滚动条的时候，更新页面上的某些布局或者数据或者调用后台的某些接口,同样，如果不对scroll函数加以限制的话,我们滚动一次滚动条就会产生N多次的调用了,throttle跟debounce不同,不是在等待某个时间后去执行函数，二是每间隔某个时间去执行函数\n\n**自助饮料机**\n\n好比一台自动的饮料机，按拿铁按钮，在出饮料的过程中，不管按多少这个按钮，都不会连续出饮料，中间按钮的响应会被忽略，必须要等这一杯的容量全部出完之后，再按拿铁按钮才会出下一杯。\n\n**函数节流**\n\n每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。\n* 形像的比喻是水龙头或机枪，你可以控制它的流量或频率。\n* throttle 的关注点是连续的执行间隔时间。\n* 也就是会说预先设定一个执行周期，当调用动作的时刻大于\n* 等于执行周期则执行该动作，然后进入下一个新周期。\n\n**实现**\n```javascript\n/**\n* 频率控制 返回函数连续调用时，callback 执行频率限定为 次/delay  \n* 不满足间隔时间,延迟times后必须执行一次\n* @param delay  {number}    间隔时间，单位毫秒\n* @param times  {number}    延迟时间，单位毫秒\n* @param callback {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nfunction throttle(delay,times,callback){\n    var startTime = (new Date()).getTime(),\n        timer = null;\n    return function(){\n        var currTime = (new Date()).getTime(),\n            that = this,\n            args = arguments;\n        clearTimeout(timer);\n        if(currTime - startTime >= delay){\n            callback.apply(that,args);\n            startTime = currTime;\n        }else{\n            timer = setTimeout(function(){\n                callback.apply(that,args);\n            },times)\n        }\n    }\n}\n\n```\n```javascript\n//Demo\n//图片懒加,就是一个不断需要滚动条来判断距离的一个解决方案;\n//通过scroll时间不断的判断,为了避免大量的scroll触发,\n//我们可以用throttle对其进行节流操作\n//仅仅做演示 html css均不提供，后文会给出demo\nfunction lazyload(){\n    var okSeeHeight = document.documentElement.clientHeight;//可视区域高度\n    var curScrollTop = document.body.scrollTop || document.documentElement.scrollTop;//滚动条高度\n    var imgNums = document.querySelectorAll('img'),\n        len = imgNums.length,\n        sn = 0;//初始化图片位置 避免每次都重新计算\n    for(var i=sn; i<len; i++){\n        //到达可视区域\n        if(imgNums[i].offsetTop < okSeeHeight + curScrollTop){\n            //替换scr\n            imgNums[i].src = imgNums[i].getAttribute('data-src');\n            sn = i + 1;\n        }\n    }\n}\n//调用即可\n//可以大大减少scroll的触发量,而不影响体验\n//500毫秒执行  不满足就强制500毫秒运行一次回调函数\nwindow.addEventListener('scroll',throttle(500,500,lazyload))\n```\n### 使用场景\n只要牵涉到连续事件或频率控制相关的应用都可以考虑到这两个函数，比如：\n\n* 游戏射击，keydown 事件\n* 文本输入、自动完成，keyup 事件\n* 鼠标移动，mousemove 事件\n* DOM 元素动态定位，window 对象的 resize 和 scroll 事件\n\n前两者 debounce 和 throttle 都可以按需使用；后两者肯定是用 throttle 了。如果不做过滤处理，每秒种甚至会触发数十次相应的事件。尤其是 mousemove 事件，每移动一像素都可能触发一次事件。如果是在一个画布上做一个鼠标相关的应用，过滤事件处理是必须的，否则肯定会造成糟糕的体验。\n\n### 图片懒加载演示DEMO\n**[图片懒加载节流优化][4]**\n\n**[github地址][1]**\n### 参考\n* [肥仔John][2]\n* [高阶函数 debounce 和 throttle][5]\n\n\n\n[1]: https://github.com/BiYuqi/lazyloading-img\n[2]: http://www.cnblogs.com/fsjohnhuang/p/4147810.html\n[3]: http://oiukswkar.bkt.clouddn.com/throttle.jpg\n[4]: http://loadingmore.com/demo/src/html/lazyload.html\n[5]: http://www.cnblogs.com/ambar/archive/2011/10/08/throttle-and-debounce.html\n","slug":"JS函数的throttle(节流)和debounce(抖动)","published":1,"updated":"2019-09-25T15:10:25.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o3000qla2ekq0xjc6q","content":"<blockquote>\n<p><strong> 某些场景下，比如响应鼠标移动或者影响窗口大小的resize事件,scroll事件,导致频繁的触发DOM操作，资源加载等重行为，导致页面卡顿甚至浏览器崩溃;网上看到一些解决的方案，遂做记录 </strong></p>\n</blockquote>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/throttle.jpg\" alt=\"sdf\"><br><a id=\"more\"></a></p>\n<h3 id=\"什么是debounce-什么场景用-怎么实现\"><a href=\"#什么是debounce-什么场景用-怎么实现\" class=\"headerlink\" title=\"什么是debounce? 什么场景用? 怎么实现?\"></a>什么是debounce? 什么场景用? 怎么实现?</h3><p><strong> 关键词查询</strong></p>\n<p>解释这个函数前，先想想如下场景：网站我们的网站有个搜索框，用户输入文本我们会自动联想匹配一些结果呈现给给用户，我们可能首先想到的就是监听keypress事件,然后进行一步查询结果,该方法本身没有问题，但是如果用户哭诉输入一连串几十个字符，那就要瞬间触发几十次请求，无疑,我们不想要这样的结果，我们要的是用户停止输入的时候才去触发查询请求,这个时候函数防抖就可以帮到我们.</p>\n<p><strong>电梯超时</strong></p>\n<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。</p>\n<p><strong>函数防抖</strong></p>\n<p>就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。</p>\n<ul>\n<li>如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。</li>\n<li>也就是说当调用动作n毫秒后，才会执行该动作，</li>\n<li>若在这n毫秒内又调用此动作则将重新计算执行时间。</li>\n</ul>\n<p><strong>实现</strong></p>\n<pre><code class=\"javascript\">/**\n* 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 delay,callback 才会执行\n* @param delay   {number}    空闲时间，单位毫秒\n* @param callback {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nfunction debounce(delay,callback){\n    var timer = null;\n    return function(){\n        var that = this,\n            args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(function(){\n            callback.apply(that,args);\n        },delay)\n    }\n}\n//demo\n//keypress时间结束200毫秒后执行相关回调事件\n$(&#39;.input&#39;).addEventListener(&#39;keypress&#39;,debounce(200,function(){\n    //do somecode\n},false))\n</code></pre>\n<h3 id=\"什么是throttle-什么场景用-怎么实现\"><a href=\"#什么是throttle-什么场景用-怎么实现\" class=\"headerlink\" title=\"什么是throttle? 什么场景用? 怎么实现?\"></a>什么是throttle? 什么场景用? 怎么实现?</h3><p><strong>scroll事件</strong></p>\n<p>网站开发中经常会遇到这样的需求就是滚动浏览器滚动条的时候，更新页面上的某些布局或者数据或者调用后台的某些接口,同样，如果不对scroll函数加以限制的话,我们滚动一次滚动条就会产生N多次的调用了,throttle跟debounce不同,不是在等待某个时间后去执行函数，二是每间隔某个时间去执行函数</p>\n<p><strong>自助饮料机</strong></p>\n<p>好比一台自动的饮料机，按拿铁按钮，在出饮料的过程中，不管按多少这个按钮，都不会连续出饮料，中间按钮的响应会被忽略，必须要等这一杯的容量全部出完之后，再按拿铁按钮才会出下一杯。</p>\n<p><strong>函数节流</strong></p>\n<p>每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。</p>\n<ul>\n<li>形像的比喻是水龙头或机枪，你可以控制它的流量或频率。</li>\n<li>throttle 的关注点是连续的执行间隔时间。</li>\n<li>也就是会说预先设定一个执行周期，当调用动作的时刻大于</li>\n<li>等于执行周期则执行该动作，然后进入下一个新周期。</li>\n</ul>\n<p><strong>实现</strong></p>\n<pre><code class=\"javascript\">/**\n* 频率控制 返回函数连续调用时，callback 执行频率限定为 次/delay  \n* 不满足间隔时间,延迟times后必须执行一次\n* @param delay  {number}    间隔时间，单位毫秒\n* @param times  {number}    延迟时间，单位毫秒\n* @param callback {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nfunction throttle(delay,times,callback){\n    var startTime = (new Date()).getTime(),\n        timer = null;\n    return function(){\n        var currTime = (new Date()).getTime(),\n            that = this,\n            args = arguments;\n        clearTimeout(timer);\n        if(currTime - startTime &gt;= delay){\n            callback.apply(that,args);\n            startTime = currTime;\n        }else{\n            timer = setTimeout(function(){\n                callback.apply(that,args);\n            },times)\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"javascript\">//Demo\n//图片懒加,就是一个不断需要滚动条来判断距离的一个解决方案;\n//通过scroll时间不断的判断,为了避免大量的scroll触发,\n//我们可以用throttle对其进行节流操作\n//仅仅做演示 html css均不提供，后文会给出demo\nfunction lazyload(){\n    var okSeeHeight = document.documentElement.clientHeight;//可视区域高度\n    var curScrollTop = document.body.scrollTop || document.documentElement.scrollTop;//滚动条高度\n    var imgNums = document.querySelectorAll(&#39;img&#39;),\n        len = imgNums.length,\n        sn = 0;//初始化图片位置 避免每次都重新计算\n    for(var i=sn; i&lt;len; i++){\n        //到达可视区域\n        if(imgNums[i].offsetTop &lt; okSeeHeight + curScrollTop){\n            //替换scr\n            imgNums[i].src = imgNums[i].getAttribute(&#39;data-src&#39;);\n            sn = i + 1;\n        }\n    }\n}\n//调用即可\n//可以大大减少scroll的触发量,而不影响体验\n//500毫秒执行  不满足就强制500毫秒运行一次回调函数\nwindow.addEventListener(&#39;scroll&#39;,throttle(500,500,lazyload))\n</code></pre>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>只要牵涉到连续事件或频率控制相关的应用都可以考虑到这两个函数，比如：</p>\n<ul>\n<li>游戏射击，keydown 事件</li>\n<li>文本输入、自动完成，keyup 事件</li>\n<li>鼠标移动，mousemove 事件</li>\n<li>DOM 元素动态定位，window 对象的 resize 和 scroll 事件</li>\n</ul>\n<p>前两者 debounce 和 throttle 都可以按需使用；后两者肯定是用 throttle 了。如果不做过滤处理，每秒种甚至会触发数十次相应的事件。尤其是 mousemove 事件，每移动一像素都可能触发一次事件。如果是在一个画布上做一个鼠标相关的应用，过滤事件处理是必须的，否则肯定会造成糟糕的体验。</p>\n<h3 id=\"图片懒加载演示DEMO\"><a href=\"#图片懒加载演示DEMO\" class=\"headerlink\" title=\"图片懒加载演示DEMO\"></a>图片懒加载演示DEMO</h3><p><strong><a href=\"http://loadingmore.com/demo/src/html/lazyload.html\">图片懒加载节流优化</a></strong></p>\n<p><strong><a href=\"https://github.com/BiYuqi/lazyloading-img\" target=\"_blank\" rel=\"external\">github地址</a></strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.cnblogs.com/fsjohnhuang/p/4147810.html\" target=\"_blank\" rel=\"external\">肥仔John</a></li>\n<li><a href=\"http://www.cnblogs.com/ambar/archive/2011/10/08/throttle-and-debounce.html\" target=\"_blank\" rel=\"external\">高阶函数 debounce 和 throttle</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong> 某些场景下，比如响应鼠标移动或者影响窗口大小的resize事件,scroll事件,导致频繁的触发DOM操作，资源加载等重行为，导致页面卡顿甚至浏览器崩溃;网上看到一些解决的方案，遂做记录 </strong></p>\n</blockquote>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/throttle.jpg\" alt=\"sdf\"><br>","more":"</p>\n<h3 id=\"什么是debounce-什么场景用-怎么实现\"><a href=\"#什么是debounce-什么场景用-怎么实现\" class=\"headerlink\" title=\"什么是debounce? 什么场景用? 怎么实现?\"></a>什么是debounce? 什么场景用? 怎么实现?</h3><p><strong> 关键词查询</strong></p>\n<p>解释这个函数前，先想想如下场景：网站我们的网站有个搜索框，用户输入文本我们会自动联想匹配一些结果呈现给给用户，我们可能首先想到的就是监听keypress事件,然后进行一步查询结果,该方法本身没有问题，但是如果用户哭诉输入一连串几十个字符，那就要瞬间触发几十次请求，无疑,我们不想要这样的结果，我们要的是用户停止输入的时候才去触发查询请求,这个时候函数防抖就可以帮到我们.</p>\n<p><strong>电梯超时</strong></p>\n<p>想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应。如果电梯里有人进来，等待15秒。如果又人进来，15秒等待重新计时，直到15秒超时，开始运送。</p>\n<p><strong>函数防抖</strong></p>\n<p>就是让某个函数在上一次执行后，满足等待某个时间内不再触发此函数后再执行，而在这个等待时间内再次触发此函数，等待时间会重新计算。</p>\n<ul>\n<li>如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。</li>\n<li>也就是说当调用动作n毫秒后，才会执行该动作，</li>\n<li>若在这n毫秒内又调用此动作则将重新计算执行时间。</li>\n</ul>\n<p><strong>实现</strong></p>\n<pre><code class=\"javascript\">/**\n* 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 delay,callback 才会执行\n* @param delay   {number}    空闲时间，单位毫秒\n* @param callback {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nfunction debounce(delay,callback){\n    var timer = null;\n    return function(){\n        var that = this,\n            args = arguments;\n        clearTimeout(timer);\n        timer = setTimeout(function(){\n            callback.apply(that,args);\n        },delay)\n    }\n}\n//demo\n//keypress时间结束200毫秒后执行相关回调事件\n$(&#39;.input&#39;).addEventListener(&#39;keypress&#39;,debounce(200,function(){\n    //do somecode\n},false))\n</code></pre>\n<h3 id=\"什么是throttle-什么场景用-怎么实现\"><a href=\"#什么是throttle-什么场景用-怎么实现\" class=\"headerlink\" title=\"什么是throttle? 什么场景用? 怎么实现?\"></a>什么是throttle? 什么场景用? 怎么实现?</h3><p><strong>scroll事件</strong></p>\n<p>网站开发中经常会遇到这样的需求就是滚动浏览器滚动条的时候，更新页面上的某些布局或者数据或者调用后台的某些接口,同样，如果不对scroll函数加以限制的话,我们滚动一次滚动条就会产生N多次的调用了,throttle跟debounce不同,不是在等待某个时间后去执行函数，二是每间隔某个时间去执行函数</p>\n<p><strong>自助饮料机</strong></p>\n<p>好比一台自动的饮料机，按拿铁按钮，在出饮料的过程中，不管按多少这个按钮，都不会连续出饮料，中间按钮的响应会被忽略，必须要等这一杯的容量全部出完之后，再按拿铁按钮才会出下一杯。</p>\n<p><strong>函数节流</strong></p>\n<p>每间隔某个时间去执行某函数，避免函数的过多执行，这个方式就叫函数节流。</p>\n<ul>\n<li>形像的比喻是水龙头或机枪，你可以控制它的流量或频率。</li>\n<li>throttle 的关注点是连续的执行间隔时间。</li>\n<li>也就是会说预先设定一个执行周期，当调用动作的时刻大于</li>\n<li>等于执行周期则执行该动作，然后进入下一个新周期。</li>\n</ul>\n<p><strong>实现</strong></p>\n<pre><code class=\"javascript\">/**\n* 频率控制 返回函数连续调用时，callback 执行频率限定为 次/delay  \n* 不满足间隔时间,延迟times后必须执行一次\n* @param delay  {number}    间隔时间，单位毫秒\n* @param times  {number}    延迟时间，单位毫秒\n* @param callback {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nfunction throttle(delay,times,callback){\n    var startTime = (new Date()).getTime(),\n        timer = null;\n    return function(){\n        var currTime = (new Date()).getTime(),\n            that = this,\n            args = arguments;\n        clearTimeout(timer);\n        if(currTime - startTime &gt;= delay){\n            callback.apply(that,args);\n            startTime = currTime;\n        }else{\n            timer = setTimeout(function(){\n                callback.apply(that,args);\n            },times)\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"javascript\">//Demo\n//图片懒加,就是一个不断需要滚动条来判断距离的一个解决方案;\n//通过scroll时间不断的判断,为了避免大量的scroll触发,\n//我们可以用throttle对其进行节流操作\n//仅仅做演示 html css均不提供，后文会给出demo\nfunction lazyload(){\n    var okSeeHeight = document.documentElement.clientHeight;//可视区域高度\n    var curScrollTop = document.body.scrollTop || document.documentElement.scrollTop;//滚动条高度\n    var imgNums = document.querySelectorAll(&#39;img&#39;),\n        len = imgNums.length,\n        sn = 0;//初始化图片位置 避免每次都重新计算\n    for(var i=sn; i&lt;len; i++){\n        //到达可视区域\n        if(imgNums[i].offsetTop &lt; okSeeHeight + curScrollTop){\n            //替换scr\n            imgNums[i].src = imgNums[i].getAttribute(&#39;data-src&#39;);\n            sn = i + 1;\n        }\n    }\n}\n//调用即可\n//可以大大减少scroll的触发量,而不影响体验\n//500毫秒执行  不满足就强制500毫秒运行一次回调函数\nwindow.addEventListener(&#39;scroll&#39;,throttle(500,500,lazyload))\n</code></pre>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>只要牵涉到连续事件或频率控制相关的应用都可以考虑到这两个函数，比如：</p>\n<ul>\n<li>游戏射击，keydown 事件</li>\n<li>文本输入、自动完成，keyup 事件</li>\n<li>鼠标移动，mousemove 事件</li>\n<li>DOM 元素动态定位，window 对象的 resize 和 scroll 事件</li>\n</ul>\n<p>前两者 debounce 和 throttle 都可以按需使用；后两者肯定是用 throttle 了。如果不做过滤处理，每秒种甚至会触发数十次相应的事件。尤其是 mousemove 事件，每移动一像素都可能触发一次事件。如果是在一个画布上做一个鼠标相关的应用，过滤事件处理是必须的，否则肯定会造成糟糕的体验。</p>\n<h3 id=\"图片懒加载演示DEMO\"><a href=\"#图片懒加载演示DEMO\" class=\"headerlink\" title=\"图片懒加载演示DEMO\"></a>图片懒加载演示DEMO</h3><p><strong><a href=\"http://loadingmore.com/demo/src/html/lazyload.html\">图片懒加载节流优化</a></strong></p>\n<p><strong><a href=\"https://github.com/BiYuqi/lazyloading-img\" target=\"_blank\" rel=\"external\">github地址</a></strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.cnblogs.com/fsjohnhuang/p/4147810.html\" target=\"_blank\" rel=\"external\">肥仔John</a></li>\n<li><a href=\"http://www.cnblogs.com/ambar/archive/2011/10/08/throttle-and-debounce.html\" target=\"_blank\" rel=\"external\">高阶函数 debounce 和 throttle</a></li>\n</ul>"},{"title":"JS实用技巧(一)","date":"2016-12-13T01:07:03.000Z","_content":"> 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n\n<!-- more -->\n## 1.用户判断给定的对象是否是数组\n```javascript\nfunction isArray(obj){\n\treturn Object.prototype.toString.call(obj) === '[object Array]'；\n}\n// test\nisArray('str'); //false\nisArray([1,2]); //true\n```\n\n## 2.判断检查数组中是否存在某个值\n```javascript\nArray.prototype.inArray = function(a){\n\tfor(var i=0;i<this.length;i++){\n\t\tif(this[i] == a){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//demo\n[3,4].inArray(4);//true\n```\n## 3.用来显示或隐藏一个DOM元素\n```javascript\nfunction toggle(obj){\n\tvar elem = document.querySelector(obj);\n\tif(elem.style.display != 'none'){\n\t\telem.style.display = 'none';\n\t}else{\n\t\telem.style.dispaly = '';//注意不要有空格\n\t}\n}\n//demo\noDiv.onclick = function(){//oDiv是点击元素\n      toggle(\"obj\");\n}\n```\n> querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。\n注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。\n\n## 4.加载样式文件\n```javascript\nfunction loadStyle(url){\n\ttry{\n\t\tdocument.createStyleSheet(url);//ie\n\t}catch(err){\n\t\tvar cssLink = document.createElement('link');\n\t\tcssLink.rel = 'styleSheet';\n\t\tcssLink.type = 'text/css';\n\t\tcssLink.href = url;\n\t\tvar head = document.getElementsByTagName('head')[0];\n\t\thead.appendChild(cssLink);\n\t}\n}\n//test\nloadStyle('css/style.css')；\n```\n## 5.获取时间的某部分\n```javascript\nvar myDate = new Data();\n\n//获取当前年份(2位)\nmyDate.getYear();\n//获取完整的年份(4位，ex:2016)\nmyDate.getFullYear();\n//获取当前月份(0~11)\nmyDate.getMonth();\n//获取当日(1~31)\nmyDate.getDate();\n//获取当前星期几(0~6)\nmyDate.getDay();\n//获取当前时间戳\nmyDate.getTime();\n//获取当前小时(0~23)\nmyDate.getHours();\n//获取当前分钟数(0~59)\nmyDate.getMinutes();\n//获取当前秒数（0~59）\nmyDate.getSeconds();\n//获取当前毫秒数(0~999)\nmyDate.getMilliseconds();\n\nmyDate.toLocaleDateString(); //获取当前日期\nmyDate.toLocaleTimeString(); //获取当前时间\nmyDate.toLocaleString( ); //获取日期与时间\n\n//时间戳\nDate.now();\n\n兼容\n+Date.now();\n//ie9+\n\n```\n## 6.元素显示的通用方法\n```javascript\nfunction $(id){\n\t return !id ? null : document.getElementById(id);\n}\nfunction display(id) {\n    var obj = $(id);\n    if(obj.style.visibility) {\n        obj.style.visibility = obj.style.visibility == 'visible' ? 'hidden' : 'visible';\n    } else {\n        obj.style.display = obj.style.display == '' ? 'none' : '';\n    }\n}\n```\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","source":"_posts/JS实用技巧(一).md","raw":"title: JS实用技巧(一)\ndate: 2016-12-13 09:07:03\ntags: [javascript,\"Js技巧\"]\ncategories: Javascript\n---\n> 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n\n<!-- more -->\n## 1.用户判断给定的对象是否是数组\n```javascript\nfunction isArray(obj){\n\treturn Object.prototype.toString.call(obj) === '[object Array]'；\n}\n// test\nisArray('str'); //false\nisArray([1,2]); //true\n```\n\n## 2.判断检查数组中是否存在某个值\n```javascript\nArray.prototype.inArray = function(a){\n\tfor(var i=0;i<this.length;i++){\n\t\tif(this[i] == a){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//demo\n[3,4].inArray(4);//true\n```\n## 3.用来显示或隐藏一个DOM元素\n```javascript\nfunction toggle(obj){\n\tvar elem = document.querySelector(obj);\n\tif(elem.style.display != 'none'){\n\t\telem.style.display = 'none';\n\t}else{\n\t\telem.style.dispaly = '';//注意不要有空格\n\t}\n}\n//demo\noDiv.onclick = function(){//oDiv是点击元素\n      toggle(\"obj\");\n}\n```\n> querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。\n注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。\n\n## 4.加载样式文件\n```javascript\nfunction loadStyle(url){\n\ttry{\n\t\tdocument.createStyleSheet(url);//ie\n\t}catch(err){\n\t\tvar cssLink = document.createElement('link');\n\t\tcssLink.rel = 'styleSheet';\n\t\tcssLink.type = 'text/css';\n\t\tcssLink.href = url;\n\t\tvar head = document.getElementsByTagName('head')[0];\n\t\thead.appendChild(cssLink);\n\t}\n}\n//test\nloadStyle('css/style.css')；\n```\n## 5.获取时间的某部分\n```javascript\nvar myDate = new Data();\n\n//获取当前年份(2位)\nmyDate.getYear();\n//获取完整的年份(4位，ex:2016)\nmyDate.getFullYear();\n//获取当前月份(0~11)\nmyDate.getMonth();\n//获取当日(1~31)\nmyDate.getDate();\n//获取当前星期几(0~6)\nmyDate.getDay();\n//获取当前时间戳\nmyDate.getTime();\n//获取当前小时(0~23)\nmyDate.getHours();\n//获取当前分钟数(0~59)\nmyDate.getMinutes();\n//获取当前秒数（0~59）\nmyDate.getSeconds();\n//获取当前毫秒数(0~999)\nmyDate.getMilliseconds();\n\nmyDate.toLocaleDateString(); //获取当前日期\nmyDate.toLocaleTimeString(); //获取当前时间\nmyDate.toLocaleString( ); //获取日期与时间\n\n//时间戳\nDate.now();\n\n兼容\n+Date.now();\n//ie9+\n\n```\n## 6.元素显示的通用方法\n```javascript\nfunction $(id){\n\t return !id ? null : document.getElementById(id);\n}\nfunction display(id) {\n    var obj = $(id);\n    if(obj.style.visibility) {\n        obj.style.visibility = obj.style.visibility == 'visible' ? 'hidden' : 'visible';\n    } else {\n        obj.style.display = obj.style.display == '' ? 'none' : '';\n    }\n}\n```\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","slug":"JS实用技巧(一)","published":1,"updated":"2019-09-25T15:10:25.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o4000sla2euvfg5lsr","content":"<blockquote>\n<p>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"1-用户判断给定的对象是否是数组\"><a href=\"#1-用户判断给定的对象是否是数组\" class=\"headerlink\" title=\"1.用户判断给定的对象是否是数组\"></a>1.用户判断给定的对象是否是数组</h2><pre><code class=\"javascript\">function isArray(obj){\n    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39;；\n}\n// test\nisArray(&#39;str&#39;); //false\nisArray([1,2]); //true\n</code></pre>\n<h2 id=\"2-判断检查数组中是否存在某个值\"><a href=\"#2-判断检查数组中是否存在某个值\" class=\"headerlink\" title=\"2.判断检查数组中是否存在某个值\"></a>2.判断检查数组中是否存在某个值</h2><pre><code class=\"javascript\">Array.prototype.inArray = function(a){\n    for(var i=0;i&lt;this.length;i++){\n        if(this[i] == a){\n            return true;\n        }\n    }\n    return false;\n}\n//demo\n[3,4].inArray(4);//true\n</code></pre>\n<h2 id=\"3-用来显示或隐藏一个DOM元素\"><a href=\"#3-用来显示或隐藏一个DOM元素\" class=\"headerlink\" title=\"3.用来显示或隐藏一个DOM元素\"></a>3.用来显示或隐藏一个DOM元素</h2><pre><code class=\"javascript\">function toggle(obj){\n    var elem = document.querySelector(obj);\n    if(elem.style.display != &#39;none&#39;){\n        elem.style.display = &#39;none&#39;;\n    }else{\n        elem.style.dispaly = &#39;&#39;;//注意不要有空格\n    }\n}\n//demo\noDiv.onclick = function(){//oDiv是点击元素\n      toggle(&quot;obj&quot;);\n}\n</code></pre>\n<blockquote>\n<p>querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。<br>注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。</p>\n</blockquote>\n<h2 id=\"4-加载样式文件\"><a href=\"#4-加载样式文件\" class=\"headerlink\" title=\"4.加载样式文件\"></a>4.加载样式文件</h2><pre><code class=\"javascript\">function loadStyle(url){\n    try{\n        document.createStyleSheet(url);//ie\n    }catch(err){\n        var cssLink = document.createElement(&#39;link&#39;);\n        cssLink.rel = &#39;styleSheet&#39;;\n        cssLink.type = &#39;text/css&#39;;\n        cssLink.href = url;\n        var head = document.getElementsByTagName(&#39;head&#39;)[0];\n        head.appendChild(cssLink);\n    }\n}\n//test\nloadStyle(&#39;css/style.css&#39;)；\n</code></pre>\n<h2 id=\"5-获取时间的某部分\"><a href=\"#5-获取时间的某部分\" class=\"headerlink\" title=\"5.获取时间的某部分\"></a>5.获取时间的某部分</h2><pre><code class=\"javascript\">var myDate = new Data();\n\n//获取当前年份(2位)\nmyDate.getYear();\n//获取完整的年份(4位，ex:2016)\nmyDate.getFullYear();\n//获取当前月份(0~11)\nmyDate.getMonth();\n//获取当日(1~31)\nmyDate.getDate();\n//获取当前星期几(0~6)\nmyDate.getDay();\n//获取当前时间戳\nmyDate.getTime();\n//获取当前小时(0~23)\nmyDate.getHours();\n//获取当前分钟数(0~59)\nmyDate.getMinutes();\n//获取当前秒数（0~59）\nmyDate.getSeconds();\n//获取当前毫秒数(0~999)\nmyDate.getMilliseconds();\n\nmyDate.toLocaleDateString(); //获取当前日期\nmyDate.toLocaleTimeString(); //获取当前时间\nmyDate.toLocaleString( ); //获取日期与时间\n\n//时间戳\nDate.now();\n\n兼容\n+Date.now();\n//ie9+\n</code></pre>\n<h2 id=\"6-元素显示的通用方法\"><a href=\"#6-元素显示的通用方法\" class=\"headerlink\" title=\"6.元素显示的通用方法\"></a>6.元素显示的通用方法</h2><pre><code class=\"javascript\">function $(id){\n     return !id ? null : document.getElementById(id);\n}\nfunction display(id) {\n    var obj = $(id);\n    if(obj.style.visibility) {\n        obj.style.visibility = obj.style.visibility == &#39;visible&#39; ? &#39;hidden&#39; : &#39;visible&#39;;\n    } else {\n        obj.style.display = obj.style.display == &#39;&#39; ? &#39;none&#39; : &#39;&#39;;\n    }\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</p>\n</blockquote>","more":"<h2 id=\"1-用户判断给定的对象是否是数组\"><a href=\"#1-用户判断给定的对象是否是数组\" class=\"headerlink\" title=\"1.用户判断给定的对象是否是数组\"></a>1.用户判断给定的对象是否是数组</h2><pre><code class=\"javascript\">function isArray(obj){\n    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39;；\n}\n// test\nisArray(&#39;str&#39;); //false\nisArray([1,2]); //true\n</code></pre>\n<h2 id=\"2-判断检查数组中是否存在某个值\"><a href=\"#2-判断检查数组中是否存在某个值\" class=\"headerlink\" title=\"2.判断检查数组中是否存在某个值\"></a>2.判断检查数组中是否存在某个值</h2><pre><code class=\"javascript\">Array.prototype.inArray = function(a){\n    for(var i=0;i&lt;this.length;i++){\n        if(this[i] == a){\n            return true;\n        }\n    }\n    return false;\n}\n//demo\n[3,4].inArray(4);//true\n</code></pre>\n<h2 id=\"3-用来显示或隐藏一个DOM元素\"><a href=\"#3-用来显示或隐藏一个DOM元素\" class=\"headerlink\" title=\"3.用来显示或隐藏一个DOM元素\"></a>3.用来显示或隐藏一个DOM元素</h2><pre><code class=\"javascript\">function toggle(obj){\n    var elem = document.querySelector(obj);\n    if(elem.style.display != &#39;none&#39;){\n        elem.style.display = &#39;none&#39;;\n    }else{\n        elem.style.dispaly = &#39;&#39;;//注意不要有空格\n    }\n}\n//demo\noDiv.onclick = function(){//oDiv是点击元素\n      toggle(&quot;obj&quot;);\n}\n</code></pre>\n<blockquote>\n<p>querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。<br>注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。</p>\n</blockquote>\n<h2 id=\"4-加载样式文件\"><a href=\"#4-加载样式文件\" class=\"headerlink\" title=\"4.加载样式文件\"></a>4.加载样式文件</h2><pre><code class=\"javascript\">function loadStyle(url){\n    try{\n        document.createStyleSheet(url);//ie\n    }catch(err){\n        var cssLink = document.createElement(&#39;link&#39;);\n        cssLink.rel = &#39;styleSheet&#39;;\n        cssLink.type = &#39;text/css&#39;;\n        cssLink.href = url;\n        var head = document.getElementsByTagName(&#39;head&#39;)[0];\n        head.appendChild(cssLink);\n    }\n}\n//test\nloadStyle(&#39;css/style.css&#39;)；\n</code></pre>\n<h2 id=\"5-获取时间的某部分\"><a href=\"#5-获取时间的某部分\" class=\"headerlink\" title=\"5.获取时间的某部分\"></a>5.获取时间的某部分</h2><pre><code class=\"javascript\">var myDate = new Data();\n\n//获取当前年份(2位)\nmyDate.getYear();\n//获取完整的年份(4位，ex:2016)\nmyDate.getFullYear();\n//获取当前月份(0~11)\nmyDate.getMonth();\n//获取当日(1~31)\nmyDate.getDate();\n//获取当前星期几(0~6)\nmyDate.getDay();\n//获取当前时间戳\nmyDate.getTime();\n//获取当前小时(0~23)\nmyDate.getHours();\n//获取当前分钟数(0~59)\nmyDate.getMinutes();\n//获取当前秒数（0~59）\nmyDate.getSeconds();\n//获取当前毫秒数(0~999)\nmyDate.getMilliseconds();\n\nmyDate.toLocaleDateString(); //获取当前日期\nmyDate.toLocaleTimeString(); //获取当前时间\nmyDate.toLocaleString( ); //获取日期与时间\n\n//时间戳\nDate.now();\n\n兼容\n+Date.now();\n//ie9+\n</code></pre>\n<h2 id=\"6-元素显示的通用方法\"><a href=\"#6-元素显示的通用方法\" class=\"headerlink\" title=\"6.元素显示的通用方法\"></a>6.元素显示的通用方法</h2><pre><code class=\"javascript\">function $(id){\n     return !id ? null : document.getElementById(id);\n}\nfunction display(id) {\n    var obj = $(id);\n    if(obj.style.visibility) {\n        obj.style.visibility = obj.style.visibility == &#39;visible&#39; ? &#39;hidden&#39; : &#39;visible&#39;;\n    } else {\n        obj.style.display = obj.style.display == &#39;&#39; ? &#39;none&#39; : &#39;&#39;;\n    }\n}\n</code></pre>"},{"title":"JS实用技巧(三)","date":"2017-01-02T02:44:38.000Z","_content":"> ### 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n\n<!-- more -->\n## 1.获取或设置元素样式\n```javascript\n/**\n\tcss 获取或者设置元素的样式\n\tcss($('div'),'width','100px');\n*/\nfunction css(elem,styles,attr){\n\tif(arguments.length <= 1){\n\t\treturn;\n\t}\n\tif(arguments.length ===2){\n\t\tif(elem.currentStyle){\n\t\t\t return elem.currentStyle[styles];\n\t\t}\n\t\treturn window.getComputedStyle(elem)[styles];\n\t}\n\telem.style[styles] = attr;\n}\n```\n## 2.给元素添加Class样式\n```javascript\n/**\n\t给元素添加某个class样式\n\telem 元素\n\tcName 添加的样式\n\t支持多个class添加 字符串用空格隔开\n*/\nfunction addClass(elem,cName){\n\tvar reg = new RegExp('(^|\\\\s)' + cName+ '(\\\\s|$)');\n\tif(!reg.test(elem.className)){\n\t\telem.className += '  ' + cName;//有个空格\n\t}\n}\n```\n## 3.元素是否有某个Class样式\n```javascript\n//返回值 true or false\nfunction hasClass(elem,hClass){\n\tvar reg = new RegExp('(^|\\\\s)' + hClass+ '(\\\\s|$)');\n\treturn (reg.test(elem.className)) ? true:false;\n}\n```\n## 4.去除元素的某个class样式\n```javascript\n/**\n\t去除元素的某个class样式\n\telem 元素\n\trName 去除的样式\n\t支持多个class去除 字符串用空格隔开\n*/\n//调用了上个函数hasClass\nfunction removeClass(elem,rName){\n\tif(hasClass(elem,rName)){\n\t\tvar reg = new RegExp('(\\\\s|^)'+rName+'(\\\\s|$)', 'g');\n\t\telem.className = elem.className.replace(reg, ' ');//‘ ’空格\n\t}\n}\n```\n## 5.找出数组中第二大数字\n```javascript\nfunction getNum(arr){\n\tvar arr = arr.sort(function(a,b){\n\t\treturn b-a;//从大到小排序\n\t})\n\treturn arr[1];//取出第二个\n}\nvar test = [1,2,41,8,5,90,45,3];\nconsole.log(getNum(test));//45\n```\n## 6.传入任意数字，自动求和\n```javascript\nvar num = 0;\nfunction sum(){\n\tfor(var i=0;i<arguments.length;i++){\n\t\tnum += arguments[i];\n\t}\n\treturn num;\n}\nconsole.log(sum(1,2,3));//6\nconsole.log(sum(2016,1));//2017\n```\n## 7.传入任意数字，找出最大数字\n```javascript\nvar num = 0;\nfunction getMax(){\n\tfor(var i=0;i<arguments.length;i++){\n\t\tif(num < arguments[i]){\n\t\t\tnum = arguments[i];\n\t\t}\n\t}\n\treturn num;\n}\nconsole.log(getMax(1,2,4,12,89,56,32,15));//89\nconsole.log(getMax(9,5,7,8,3,1));//9\n```\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","source":"_posts/JS实用技巧(三).md","raw":"---\ntitle: JS实用技巧(三)\ndate: 2017-01-02 10:44:38\ntags: [javascript,\"Js技巧\"]\ncategories: Javascript\n---\n> ### 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n\n<!-- more -->\n## 1.获取或设置元素样式\n```javascript\n/**\n\tcss 获取或者设置元素的样式\n\tcss($('div'),'width','100px');\n*/\nfunction css(elem,styles,attr){\n\tif(arguments.length <= 1){\n\t\treturn;\n\t}\n\tif(arguments.length ===2){\n\t\tif(elem.currentStyle){\n\t\t\t return elem.currentStyle[styles];\n\t\t}\n\t\treturn window.getComputedStyle(elem)[styles];\n\t}\n\telem.style[styles] = attr;\n}\n```\n## 2.给元素添加Class样式\n```javascript\n/**\n\t给元素添加某个class样式\n\telem 元素\n\tcName 添加的样式\n\t支持多个class添加 字符串用空格隔开\n*/\nfunction addClass(elem,cName){\n\tvar reg = new RegExp('(^|\\\\s)' + cName+ '(\\\\s|$)');\n\tif(!reg.test(elem.className)){\n\t\telem.className += '  ' + cName;//有个空格\n\t}\n}\n```\n## 3.元素是否有某个Class样式\n```javascript\n//返回值 true or false\nfunction hasClass(elem,hClass){\n\tvar reg = new RegExp('(^|\\\\s)' + hClass+ '(\\\\s|$)');\n\treturn (reg.test(elem.className)) ? true:false;\n}\n```\n## 4.去除元素的某个class样式\n```javascript\n/**\n\t去除元素的某个class样式\n\telem 元素\n\trName 去除的样式\n\t支持多个class去除 字符串用空格隔开\n*/\n//调用了上个函数hasClass\nfunction removeClass(elem,rName){\n\tif(hasClass(elem,rName)){\n\t\tvar reg = new RegExp('(\\\\s|^)'+rName+'(\\\\s|$)', 'g');\n\t\telem.className = elem.className.replace(reg, ' ');//‘ ’空格\n\t}\n}\n```\n## 5.找出数组中第二大数字\n```javascript\nfunction getNum(arr){\n\tvar arr = arr.sort(function(a,b){\n\t\treturn b-a;//从大到小排序\n\t})\n\treturn arr[1];//取出第二个\n}\nvar test = [1,2,41,8,5,90,45,3];\nconsole.log(getNum(test));//45\n```\n## 6.传入任意数字，自动求和\n```javascript\nvar num = 0;\nfunction sum(){\n\tfor(var i=0;i<arguments.length;i++){\n\t\tnum += arguments[i];\n\t}\n\treturn num;\n}\nconsole.log(sum(1,2,3));//6\nconsole.log(sum(2016,1));//2017\n```\n## 7.传入任意数字，找出最大数字\n```javascript\nvar num = 0;\nfunction getMax(){\n\tfor(var i=0;i<arguments.length;i++){\n\t\tif(num < arguments[i]){\n\t\t\tnum = arguments[i];\n\t\t}\n\t}\n\treturn num;\n}\nconsole.log(getMax(1,2,4,12,89,56,32,15));//89\nconsole.log(getMax(9,5,7,8,3,1));//9\n```\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","slug":"JS实用技巧(三)","published":1,"updated":"2019-10-01T07:23:39.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o5000vla2ez205nrju","content":"<blockquote>\n<h3 id=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"><a href=\"#该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\" class=\"headerlink\" title=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"></a>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</h3></blockquote>\n<a id=\"more\"></a>\n<h2 id=\"1-获取或设置元素样式\"><a href=\"#1-获取或设置元素样式\" class=\"headerlink\" title=\"1.获取或设置元素样式\"></a>1.获取或设置元素样式</h2><pre><code class=\"javascript\">/**\n    css 获取或者设置元素的样式\n    css($(&#39;div&#39;),&#39;width&#39;,&#39;100px&#39;);\n*/\nfunction css(elem,styles,attr){\n    if(arguments.length &lt;= 1){\n        return;\n    }\n    if(arguments.length ===2){\n        if(elem.currentStyle){\n             return elem.currentStyle[styles];\n        }\n        return window.getComputedStyle(elem)[styles];\n    }\n    elem.style[styles] = attr;\n}\n</code></pre>\n<h2 id=\"2-给元素添加Class样式\"><a href=\"#2-给元素添加Class样式\" class=\"headerlink\" title=\"2.给元素添加Class样式\"></a>2.给元素添加Class样式</h2><pre><code class=\"javascript\">/**\n    给元素添加某个class样式\n    elem 元素\n    cName 添加的样式\n    支持多个class添加 字符串用空格隔开\n*/\nfunction addClass(elem,cName){\n    var reg = new RegExp(&#39;(^|\\\\s)&#39; + cName+ &#39;(\\\\s|$)&#39;);\n    if(!reg.test(elem.className)){\n        elem.className += &#39;  &#39; + cName;//有个空格\n    }\n}\n</code></pre>\n<h2 id=\"3-元素是否有某个Class样式\"><a href=\"#3-元素是否有某个Class样式\" class=\"headerlink\" title=\"3.元素是否有某个Class样式\"></a>3.元素是否有某个Class样式</h2><pre><code class=\"javascript\">//返回值 true or false\nfunction hasClass(elem,hClass){\n    var reg = new RegExp(&#39;(^|\\\\s)&#39; + hClass+ &#39;(\\\\s|$)&#39;);\n    return (reg.test(elem.className)) ? true:false;\n}\n</code></pre>\n<h2 id=\"4-去除元素的某个class样式\"><a href=\"#4-去除元素的某个class样式\" class=\"headerlink\" title=\"4.去除元素的某个class样式\"></a>4.去除元素的某个class样式</h2><pre><code class=\"javascript\">/**\n    去除元素的某个class样式\n    elem 元素\n    rName 去除的样式\n    支持多个class去除 字符串用空格隔开\n*/\n//调用了上个函数hasClass\nfunction removeClass(elem,rName){\n    if(hasClass(elem,rName)){\n        var reg = new RegExp(&#39;(\\\\s|^)&#39;+rName+&#39;(\\\\s|$)&#39;, &#39;g&#39;);\n        elem.className = elem.className.replace(reg, &#39; &#39;);//‘ ’空格\n    }\n}\n</code></pre>\n<h2 id=\"5-找出数组中第二大数字\"><a href=\"#5-找出数组中第二大数字\" class=\"headerlink\" title=\"5.找出数组中第二大数字\"></a>5.找出数组中第二大数字</h2><pre><code class=\"javascript\">function getNum(arr){\n    var arr = arr.sort(function(a,b){\n        return b-a;//从大到小排序\n    })\n    return arr[1];//取出第二个\n}\nvar test = [1,2,41,8,5,90,45,3];\nconsole.log(getNum(test));//45\n</code></pre>\n<h2 id=\"6-传入任意数字，自动求和\"><a href=\"#6-传入任意数字，自动求和\" class=\"headerlink\" title=\"6.传入任意数字，自动求和\"></a>6.传入任意数字，自动求和</h2><pre><code class=\"javascript\">var num = 0;\nfunction sum(){\n    for(var i=0;i&lt;arguments.length;i++){\n        num += arguments[i];\n    }\n    return num;\n}\nconsole.log(sum(1,2,3));//6\nconsole.log(sum(2016,1));//2017\n</code></pre>\n<h2 id=\"7-传入任意数字，找出最大数字\"><a href=\"#7-传入任意数字，找出最大数字\" class=\"headerlink\" title=\"7.传入任意数字，找出最大数字\"></a>7.传入任意数字，找出最大数字</h2><pre><code class=\"javascript\">var num = 0;\nfunction getMax(){\n    for(var i=0;i&lt;arguments.length;i++){\n        if(num &lt; arguments[i]){\n            num = arguments[i];\n        }\n    }\n    return num;\n}\nconsole.log(getMax(1,2,4,12,89,56,32,15));//89\nconsole.log(getMax(9,5,7,8,3,1));//9\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<h3 id=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"><a href=\"#该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\" class=\"headerlink\" title=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"></a>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</h3></blockquote>","more":"<h2 id=\"1-获取或设置元素样式\"><a href=\"#1-获取或设置元素样式\" class=\"headerlink\" title=\"1.获取或设置元素样式\"></a>1.获取或设置元素样式</h2><pre><code class=\"javascript\">/**\n    css 获取或者设置元素的样式\n    css($(&#39;div&#39;),&#39;width&#39;,&#39;100px&#39;);\n*/\nfunction css(elem,styles,attr){\n    if(arguments.length &lt;= 1){\n        return;\n    }\n    if(arguments.length ===2){\n        if(elem.currentStyle){\n             return elem.currentStyle[styles];\n        }\n        return window.getComputedStyle(elem)[styles];\n    }\n    elem.style[styles] = attr;\n}\n</code></pre>\n<h2 id=\"2-给元素添加Class样式\"><a href=\"#2-给元素添加Class样式\" class=\"headerlink\" title=\"2.给元素添加Class样式\"></a>2.给元素添加Class样式</h2><pre><code class=\"javascript\">/**\n    给元素添加某个class样式\n    elem 元素\n    cName 添加的样式\n    支持多个class添加 字符串用空格隔开\n*/\nfunction addClass(elem,cName){\n    var reg = new RegExp(&#39;(^|\\\\s)&#39; + cName+ &#39;(\\\\s|$)&#39;);\n    if(!reg.test(elem.className)){\n        elem.className += &#39;  &#39; + cName;//有个空格\n    }\n}\n</code></pre>\n<h2 id=\"3-元素是否有某个Class样式\"><a href=\"#3-元素是否有某个Class样式\" class=\"headerlink\" title=\"3.元素是否有某个Class样式\"></a>3.元素是否有某个Class样式</h2><pre><code class=\"javascript\">//返回值 true or false\nfunction hasClass(elem,hClass){\n    var reg = new RegExp(&#39;(^|\\\\s)&#39; + hClass+ &#39;(\\\\s|$)&#39;);\n    return (reg.test(elem.className)) ? true:false;\n}\n</code></pre>\n<h2 id=\"4-去除元素的某个class样式\"><a href=\"#4-去除元素的某个class样式\" class=\"headerlink\" title=\"4.去除元素的某个class样式\"></a>4.去除元素的某个class样式</h2><pre><code class=\"javascript\">/**\n    去除元素的某个class样式\n    elem 元素\n    rName 去除的样式\n    支持多个class去除 字符串用空格隔开\n*/\n//调用了上个函数hasClass\nfunction removeClass(elem,rName){\n    if(hasClass(elem,rName)){\n        var reg = new RegExp(&#39;(\\\\s|^)&#39;+rName+&#39;(\\\\s|$)&#39;, &#39;g&#39;);\n        elem.className = elem.className.replace(reg, &#39; &#39;);//‘ ’空格\n    }\n}\n</code></pre>\n<h2 id=\"5-找出数组中第二大数字\"><a href=\"#5-找出数组中第二大数字\" class=\"headerlink\" title=\"5.找出数组中第二大数字\"></a>5.找出数组中第二大数字</h2><pre><code class=\"javascript\">function getNum(arr){\n    var arr = arr.sort(function(a,b){\n        return b-a;//从大到小排序\n    })\n    return arr[1];//取出第二个\n}\nvar test = [1,2,41,8,5,90,45,3];\nconsole.log(getNum(test));//45\n</code></pre>\n<h2 id=\"6-传入任意数字，自动求和\"><a href=\"#6-传入任意数字，自动求和\" class=\"headerlink\" title=\"6.传入任意数字，自动求和\"></a>6.传入任意数字，自动求和</h2><pre><code class=\"javascript\">var num = 0;\nfunction sum(){\n    for(var i=0;i&lt;arguments.length;i++){\n        num += arguments[i];\n    }\n    return num;\n}\nconsole.log(sum(1,2,3));//6\nconsole.log(sum(2016,1));//2017\n</code></pre>\n<h2 id=\"7-传入任意数字，找出最大数字\"><a href=\"#7-传入任意数字，找出最大数字\" class=\"headerlink\" title=\"7.传入任意数字，找出最大数字\"></a>7.传入任意数字，找出最大数字</h2><pre><code class=\"javascript\">var num = 0;\nfunction getMax(){\n    for(var i=0;i&lt;arguments.length;i++){\n        if(num &lt; arguments[i]){\n            num = arguments[i];\n        }\n    }\n    return num;\n}\nconsole.log(getMax(1,2,4,12,89,56,32,15));//89\nconsole.log(getMax(9,5,7,8,3,1));//9\n</code></pre>"},{"title":"JS实用技巧(五)","date":"2017-02-04T13:15:55.000Z","_content":"> ### 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n<!-- more -->\n## 实现数组原生翻转reverse()方法\n```javascript\nfunction reverse(arr){\n    //方法1\n    var s = JSON.stringify(arr),//序列化\n        o = [],\n        reg = /(\\w)+/g;//提取规则\n    while(match = reg.exec(s)){\n        //循环提取匹配\n        o.unshift(match[0]);\n    }\n    return o;\n    //方法2\n    var o = [];\n    for(var i=0;i<arr.length;i++){\n        o.unshift(arr[i]);\n    }\n    return o;\n}\n//test:\nvar arrSt = [\"bi\",\"yu\",\"qi\",\"to\",\"be\",\"an\"];\nvar res = reverse(arrSt);\nconsole.log(res);//[\"an\", \"be\", \"to\", \"qi\", \"yu\", \"bi\"]\n```\n## 根据传进去的对象,返回所有key为id的value\n```javascript\nfunction areaIds(data){\n    var str = JSON.stringify(data),\n        // reg = /\\\"id\\\":([^,])/g,\n        reg = /\\\"id\\\":(\\d)/,\n        arr = [];\n    while(match = reg.exec(str)){\n        arr.push(match[1]);\n    }\n    return arr;\n}\n//test\nvar dd = {\n    id:1,\n    items:[\n        {id:2},\n        {id:3,items:[\n            {id:4},\n            {id:5}\n        ]}\n    ]\n}\nvar d = areaIds(dd);\nconsole.log(d);//[\"1\", \"2\", \"3\", \"4\", \"5\"]\n```\n## 根据第一个参数array返回number数量的数的和\n```javascript\n/*\n* var values = [2,3,32,8,5]\n* minSum(values, 2); // => 2+3 = 5\n* maxSum(values, 3); // => 32+8+5 = 45\n*\n*/\nvar testArr = [2,3,32,8,5];\n\nfunction minSum(val,num){\n    var sum = 0;\n    val.sort(function(a,b){\n        return a - b;\n    });\n    for(let i=0;i<num;i++){\n        sum += val[i];\n    }\n    return sum;\n}\nvar mini = minSum(testArr,2);\nconsole.log(mini);//5\n\nfunction maxSum(val,num){\n    var sum = 0;\n    val.sort(function(a,b){\n        return b - a;\n    });\n    for(let i=0;i<num;i++){\n        sum += val[i];\n    }\n    return sum;\n}\nvar maxi = maxSum(testArr,3);\nconsole.log(maxi);//45\n\n```\n## 实现数组拷贝累加\n```javascript\n//[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5]\nArray.prototype.duplicator = function() {\n    //第一种方法\n    var temp = this;\n    temp = temp.join(',')+','+temp.join(',');\n    return temp.split(',');\n    //第二种\n    var o = this.slice();\n    for(var i=0;i<this.length;i++){\n        o.push(this[i]);\n    }\n    return o;\n    //第三种 最简便\n    return this.slice().concat(this);\n}\nconsole.log([1,2,3,4,5].duplicator());\n//[1,2,3,4,5,1,2,3,4,5]\n```\n[1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","source":"_posts/JS实用技巧(五).md","raw":"---\ntitle: JS实用技巧(五)\ndate: 2017-02-04 21:15:55\ntags: [javascript,\"Js技巧\"]\ncategories: Javascript\n---\n> ### 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n<!-- more -->\n## 实现数组原生翻转reverse()方法\n```javascript\nfunction reverse(arr){\n    //方法1\n    var s = JSON.stringify(arr),//序列化\n        o = [],\n        reg = /(\\w)+/g;//提取规则\n    while(match = reg.exec(s)){\n        //循环提取匹配\n        o.unshift(match[0]);\n    }\n    return o;\n    //方法2\n    var o = [];\n    for(var i=0;i<arr.length;i++){\n        o.unshift(arr[i]);\n    }\n    return o;\n}\n//test:\nvar arrSt = [\"bi\",\"yu\",\"qi\",\"to\",\"be\",\"an\"];\nvar res = reverse(arrSt);\nconsole.log(res);//[\"an\", \"be\", \"to\", \"qi\", \"yu\", \"bi\"]\n```\n## 根据传进去的对象,返回所有key为id的value\n```javascript\nfunction areaIds(data){\n    var str = JSON.stringify(data),\n        // reg = /\\\"id\\\":([^,])/g,\n        reg = /\\\"id\\\":(\\d)/,\n        arr = [];\n    while(match = reg.exec(str)){\n        arr.push(match[1]);\n    }\n    return arr;\n}\n//test\nvar dd = {\n    id:1,\n    items:[\n        {id:2},\n        {id:3,items:[\n            {id:4},\n            {id:5}\n        ]}\n    ]\n}\nvar d = areaIds(dd);\nconsole.log(d);//[\"1\", \"2\", \"3\", \"4\", \"5\"]\n```\n## 根据第一个参数array返回number数量的数的和\n```javascript\n/*\n* var values = [2,3,32,8,5]\n* minSum(values, 2); // => 2+3 = 5\n* maxSum(values, 3); // => 32+8+5 = 45\n*\n*/\nvar testArr = [2,3,32,8,5];\n\nfunction minSum(val,num){\n    var sum = 0;\n    val.sort(function(a,b){\n        return a - b;\n    });\n    for(let i=0;i<num;i++){\n        sum += val[i];\n    }\n    return sum;\n}\nvar mini = minSum(testArr,2);\nconsole.log(mini);//5\n\nfunction maxSum(val,num){\n    var sum = 0;\n    val.sort(function(a,b){\n        return b - a;\n    });\n    for(let i=0;i<num;i++){\n        sum += val[i];\n    }\n    return sum;\n}\nvar maxi = maxSum(testArr,3);\nconsole.log(maxi);//45\n\n```\n## 实现数组拷贝累加\n```javascript\n//[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5]\nArray.prototype.duplicator = function() {\n    //第一种方法\n    var temp = this;\n    temp = temp.join(',')+','+temp.join(',');\n    return temp.split(',');\n    //第二种\n    var o = this.slice();\n    for(var i=0;i<this.length;i++){\n        o.push(this[i]);\n    }\n    return o;\n    //第三种 最简便\n    return this.slice().concat(this);\n}\nconsole.log([1,2,3,4,5].duplicator());\n//[1,2,3,4,5,1,2,3,4,5]\n```\n[1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","slug":"JS实用技巧(五)","published":1,"updated":"2019-09-25T15:10:25.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o6000yla2eag9e12oq","content":"<blockquote>\n<h3 id=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"><a href=\"#该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\" class=\"headerlink\" title=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"></a>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</h3></blockquote>\n<a id=\"more\"></a>\n<h2 id=\"实现数组原生翻转reverse-方法\"><a href=\"#实现数组原生翻转reverse-方法\" class=\"headerlink\" title=\"实现数组原生翻转reverse()方法\"></a>实现数组原生翻转reverse()方法</h2><pre><code class=\"javascript\">function reverse(arr){\n    //方法1\n    var s = JSON.stringify(arr),//序列化\n        o = [],\n        reg = /(\\w)+/g;//提取规则\n    while(match = reg.exec(s)){\n        //循环提取匹配\n        o.unshift(match[0]);\n    }\n    return o;\n    //方法2\n    var o = [];\n    for(var i=0;i&lt;arr.length;i++){\n        o.unshift(arr[i]);\n    }\n    return o;\n}\n//test:\nvar arrSt = [&quot;bi&quot;,&quot;yu&quot;,&quot;qi&quot;,&quot;to&quot;,&quot;be&quot;,&quot;an&quot;];\nvar res = reverse(arrSt);\nconsole.log(res);//[&quot;an&quot;, &quot;be&quot;, &quot;to&quot;, &quot;qi&quot;, &quot;yu&quot;, &quot;bi&quot;]\n</code></pre>\n<h2 id=\"根据传进去的对象-返回所有key为id的value\"><a href=\"#根据传进去的对象-返回所有key为id的value\" class=\"headerlink\" title=\"根据传进去的对象,返回所有key为id的value\"></a>根据传进去的对象,返回所有key为id的value</h2><pre><code class=\"javascript\">function areaIds(data){\n    var str = JSON.stringify(data),\n        // reg = /\\&quot;id\\&quot;:([^,])/g,\n        reg = /\\&quot;id\\&quot;:(\\d)/,\n        arr = [];\n    while(match = reg.exec(str)){\n        arr.push(match[1]);\n    }\n    return arr;\n}\n//test\nvar dd = {\n    id:1,\n    items:[\n        {id:2},\n        {id:3,items:[\n            {id:4},\n            {id:5}\n        ]}\n    ]\n}\nvar d = areaIds(dd);\nconsole.log(d);//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]\n</code></pre>\n<h2 id=\"根据第一个参数array返回number数量的数的和\"><a href=\"#根据第一个参数array返回number数量的数的和\" class=\"headerlink\" title=\"根据第一个参数array返回number数量的数的和\"></a>根据第一个参数array返回number数量的数的和</h2><pre><code class=\"javascript\">/*\n* var values = [2,3,32,8,5]\n* minSum(values, 2); // =&gt; 2+3 = 5\n* maxSum(values, 3); // =&gt; 32+8+5 = 45\n*\n*/\nvar testArr = [2,3,32,8,5];\n\nfunction minSum(val,num){\n    var sum = 0;\n    val.sort(function(a,b){\n        return a - b;\n    });\n    for(let i=0;i&lt;num;i++){\n        sum += val[i];\n    }\n    return sum;\n}\nvar mini = minSum(testArr,2);\nconsole.log(mini);//5\n\nfunction maxSum(val,num){\n    var sum = 0;\n    val.sort(function(a,b){\n        return b - a;\n    });\n    for(let i=0;i&lt;num;i++){\n        sum += val[i];\n    }\n    return sum;\n}\nvar maxi = maxSum(testArr,3);\nconsole.log(maxi);//45\n</code></pre>\n<h2 id=\"实现数组拷贝累加\"><a href=\"#实现数组拷贝累加\" class=\"headerlink\" title=\"实现数组拷贝累加\"></a>实现数组拷贝累加</h2><pre><code class=\"javascript\">//[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5]\nArray.prototype.duplicator = function() {\n    //第一种方法\n    var temp = this;\n    temp = temp.join(&#39;,&#39;)+&#39;,&#39;+temp.join(&#39;,&#39;);\n    return temp.split(&#39;,&#39;);\n    //第二种\n    var o = this.slice();\n    for(var i=0;i&lt;this.length;i++){\n        o.push(this[i]);\n    }\n    return o;\n    //第三种 最简便\n    return this.slice().concat(this);\n}\nconsole.log([1,2,3,4,5].duplicator());\n//[1,2,3,4,5,1,2,3,4,5]\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<h3 id=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"><a href=\"#该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\" class=\"headerlink\" title=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"></a>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</h3></blockquote>","more":"<h2 id=\"实现数组原生翻转reverse-方法\"><a href=\"#实现数组原生翻转reverse-方法\" class=\"headerlink\" title=\"实现数组原生翻转reverse()方法\"></a>实现数组原生翻转reverse()方法</h2><pre><code class=\"javascript\">function reverse(arr){\n    //方法1\n    var s = JSON.stringify(arr),//序列化\n        o = [],\n        reg = /(\\w)+/g;//提取规则\n    while(match = reg.exec(s)){\n        //循环提取匹配\n        o.unshift(match[0]);\n    }\n    return o;\n    //方法2\n    var o = [];\n    for(var i=0;i&lt;arr.length;i++){\n        o.unshift(arr[i]);\n    }\n    return o;\n}\n//test:\nvar arrSt = [&quot;bi&quot;,&quot;yu&quot;,&quot;qi&quot;,&quot;to&quot;,&quot;be&quot;,&quot;an&quot;];\nvar res = reverse(arrSt);\nconsole.log(res);//[&quot;an&quot;, &quot;be&quot;, &quot;to&quot;, &quot;qi&quot;, &quot;yu&quot;, &quot;bi&quot;]\n</code></pre>\n<h2 id=\"根据传进去的对象-返回所有key为id的value\"><a href=\"#根据传进去的对象-返回所有key为id的value\" class=\"headerlink\" title=\"根据传进去的对象,返回所有key为id的value\"></a>根据传进去的对象,返回所有key为id的value</h2><pre><code class=\"javascript\">function areaIds(data){\n    var str = JSON.stringify(data),\n        // reg = /\\&quot;id\\&quot;:([^,])/g,\n        reg = /\\&quot;id\\&quot;:(\\d)/,\n        arr = [];\n    while(match = reg.exec(str)){\n        arr.push(match[1]);\n    }\n    return arr;\n}\n//test\nvar dd = {\n    id:1,\n    items:[\n        {id:2},\n        {id:3,items:[\n            {id:4},\n            {id:5}\n        ]}\n    ]\n}\nvar d = areaIds(dd);\nconsole.log(d);//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]\n</code></pre>\n<h2 id=\"根据第一个参数array返回number数量的数的和\"><a href=\"#根据第一个参数array返回number数量的数的和\" class=\"headerlink\" title=\"根据第一个参数array返回number数量的数的和\"></a>根据第一个参数array返回number数量的数的和</h2><pre><code class=\"javascript\">/*\n* var values = [2,3,32,8,5]\n* minSum(values, 2); // =&gt; 2+3 = 5\n* maxSum(values, 3); // =&gt; 32+8+5 = 45\n*\n*/\nvar testArr = [2,3,32,8,5];\n\nfunction minSum(val,num){\n    var sum = 0;\n    val.sort(function(a,b){\n        return a - b;\n    });\n    for(let i=0;i&lt;num;i++){\n        sum += val[i];\n    }\n    return sum;\n}\nvar mini = minSum(testArr,2);\nconsole.log(mini);//5\n\nfunction maxSum(val,num){\n    var sum = 0;\n    val.sort(function(a,b){\n        return b - a;\n    });\n    for(let i=0;i&lt;num;i++){\n        sum += val[i];\n    }\n    return sum;\n}\nvar maxi = maxSum(testArr,3);\nconsole.log(maxi);//45\n</code></pre>\n<h2 id=\"实现数组拷贝累加\"><a href=\"#实现数组拷贝累加\" class=\"headerlink\" title=\"实现数组拷贝累加\"></a>实现数组拷贝累加</h2><pre><code class=\"javascript\">//[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5]\nArray.prototype.duplicator = function() {\n    //第一种方法\n    var temp = this;\n    temp = temp.join(&#39;,&#39;)+&#39;,&#39;+temp.join(&#39;,&#39;);\n    return temp.split(&#39;,&#39;);\n    //第二种\n    var o = this.slice();\n    for(var i=0;i&lt;this.length;i++){\n        o.push(this[i]);\n    }\n    return o;\n    //第三种 最简便\n    return this.slice().concat(this);\n}\nconsole.log([1,2,3,4,5].duplicator());\n//[1,2,3,4,5,1,2,3,4,5]\n</code></pre>"},{"title":"JS实用技巧(二)","date":"2016-12-26T13:13:12.000Z","_content":"> ### 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n## 1.十六进制颜色值的随机生成(2种方法)\n```javascript\nfunction getColor(){\n\tvar   arrStr = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\"],\n\t\t\tstrHas = \"#\",\n\t\t\tindex;\n\t\t\tfor(var i=0;i<6;i++){\n\t\t\t\tindex = Math.floor(Math.random()*14);\n\t\t\t\tstrHas += arrStr[index];\n\t\t\t}\n\treturn strHas;\n}\ngetColor();//随机颜色值\n\nfunction getColor2(){\n\treturn \"#\"+(\"000\"+Math.floor(Math.random()*16777215).toString(16)).slice(-6);\n}\ngetColor2()//随机颜色值\n```\n说明：\n1、16777215为16进制的颜色ffffff转成10进制的数字\n2、转成16进制不足6位的以0来补充(经测试会有不足6位的情况出现)\n\n## 2.Event兼容\n```javascript\n//兼容IE和Firefox的event对象\nbtn.onclick() = function(){\n\te = window.event || e;\n\t//some code\n}\n\n//兼容srcElement和target(事件源)\nvar et = e.srcElement || e.target;\nconsole.log(et.tagName);\n\n//封装getEventTarget函数\nfunction getEventTarget(e){\n\te.window.event || e;\n\treturn e.srcElement || e.target;\n}\n```\n## 3.阻止冒泡，封装stopPropagation函数\n```javascript\nfunction stopPropagation(e){\n\te = window.event || e;\n\tif(document.all){\n\t\tcancelBubble = true;\n\t}else{\n\t\te.stopPropagation();\n\t}\n}\n//or\nfunction stopPropagation2(e){\n\te = window.event || e;\n\tif(e.stopPropagation){\n\t\te.stopPropagation();\n\t}else{\n\t\tcancelBubble = true;\n\t}\n}\n//demo\nbtn.onclick = function(e){\n\tstopPropagation(e);\n}\n```\ndocument.all可以判断浏览器是否是IE;\n\n## 4.添加事件监听 兼容\n```javascript\n/*\n\t添加事件监听 兼容\n\taddEvent(elem,type,fn,choose);\n\telem 需要添加事件监听的元素\n\ttype 事件类型 一律不加on\n\tfn 回调函数（要做的事情）\n\tchoose 冒泡或者捕捉 默认为false\n*/\nfunction addEvent(elem,type,fn,choose){\n\tif(arguments.length < 3){\n\t\treturn ;\n\t}\n\t//给choose赋初值\n\tchoose = choose || false;\n\t//判断浏览器是否支持addEventListener\n\tif(elem.addEventListener){\n\t\telem.addEventListener(type,fn,choose);\n\t}else {\n\t\telem.attachEvent('on'+type , fn , choose);\n\t}\n}\n// demo:\nvar btn = document.querySelector(\"#btn\");\non(btn,\"click\",function(){\n    console.log(888);\n});\n```\n## 5.类型判断函数\n```javascript\nvar Tyle = (function(){\n\tvar Type = {},\n\t\tlist = ['String','Array','Object','Number','RegExp','Null'];\n\tfor(var i=0;i<list.length;i++){\n\t\t(function(type){\n\t\t\tType['is'+type] = function(obj){\n\t\t\t\treturn Object.prototype.toString.call(obj) === '[object '+type+']'\n\t\t\t}\n\t\t})(list[i])\n\t}\n\treturn Type\n})()\n\nconsole.log(Tyle.isArray([])) // true\nconsole.log(Tyle.isNumber(''))\t// false\nconsole.log(Tyle.isString(''))\t// true\nconsole.log(Tyle.isObject({}))\t// true\nconsole.log(Tyle.isRegExp(/\\s/))\t// true\nconsole.log(Tyle.isNull(''))\t// false\n```\n## 6.设置透明度\n```javascript\nfunction setOpacity(elem,level){\n\tnode = typeof node == \"string\" ? document.getElementById(node) : node;//检测传进来node的类型\n\tif(document.all){\n\t\tnode.style.filter = 'alpha(opacity='+level+')';\n\t}else{\n\t\tnode.style.opacity  = level/100;\n\t}\n}\n//test\nsetOpacity(\"box1\",20);\nsetOpacity(\"box2\",80);\n```\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","source":"_posts/JS实用技巧(二).md","raw":"---\ntitle: JS实用技巧(二)\ndate: 2016-12-26 21:13:12\ntags: [javascript,\"Js技巧\"]\ncategories: Javascript\n---\n> ### 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n## 1.十六进制颜色值的随机生成(2种方法)\n```javascript\nfunction getColor(){\n\tvar   arrStr = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\"],\n\t\t\tstrHas = \"#\",\n\t\t\tindex;\n\t\t\tfor(var i=0;i<6;i++){\n\t\t\t\tindex = Math.floor(Math.random()*14);\n\t\t\t\tstrHas += arrStr[index];\n\t\t\t}\n\treturn strHas;\n}\ngetColor();//随机颜色值\n\nfunction getColor2(){\n\treturn \"#\"+(\"000\"+Math.floor(Math.random()*16777215).toString(16)).slice(-6);\n}\ngetColor2()//随机颜色值\n```\n说明：\n1、16777215为16进制的颜色ffffff转成10进制的数字\n2、转成16进制不足6位的以0来补充(经测试会有不足6位的情况出现)\n\n## 2.Event兼容\n```javascript\n//兼容IE和Firefox的event对象\nbtn.onclick() = function(){\n\te = window.event || e;\n\t//some code\n}\n\n//兼容srcElement和target(事件源)\nvar et = e.srcElement || e.target;\nconsole.log(et.tagName);\n\n//封装getEventTarget函数\nfunction getEventTarget(e){\n\te.window.event || e;\n\treturn e.srcElement || e.target;\n}\n```\n## 3.阻止冒泡，封装stopPropagation函数\n```javascript\nfunction stopPropagation(e){\n\te = window.event || e;\n\tif(document.all){\n\t\tcancelBubble = true;\n\t}else{\n\t\te.stopPropagation();\n\t}\n}\n//or\nfunction stopPropagation2(e){\n\te = window.event || e;\n\tif(e.stopPropagation){\n\t\te.stopPropagation();\n\t}else{\n\t\tcancelBubble = true;\n\t}\n}\n//demo\nbtn.onclick = function(e){\n\tstopPropagation(e);\n}\n```\ndocument.all可以判断浏览器是否是IE;\n\n## 4.添加事件监听 兼容\n```javascript\n/*\n\t添加事件监听 兼容\n\taddEvent(elem,type,fn,choose);\n\telem 需要添加事件监听的元素\n\ttype 事件类型 一律不加on\n\tfn 回调函数（要做的事情）\n\tchoose 冒泡或者捕捉 默认为false\n*/\nfunction addEvent(elem,type,fn,choose){\n\tif(arguments.length < 3){\n\t\treturn ;\n\t}\n\t//给choose赋初值\n\tchoose = choose || false;\n\t//判断浏览器是否支持addEventListener\n\tif(elem.addEventListener){\n\t\telem.addEventListener(type,fn,choose);\n\t}else {\n\t\telem.attachEvent('on'+type , fn , choose);\n\t}\n}\n// demo:\nvar btn = document.querySelector(\"#btn\");\non(btn,\"click\",function(){\n    console.log(888);\n});\n```\n## 5.类型判断函数\n```javascript\nvar Tyle = (function(){\n\tvar Type = {},\n\t\tlist = ['String','Array','Object','Number','RegExp','Null'];\n\tfor(var i=0;i<list.length;i++){\n\t\t(function(type){\n\t\t\tType['is'+type] = function(obj){\n\t\t\t\treturn Object.prototype.toString.call(obj) === '[object '+type+']'\n\t\t\t}\n\t\t})(list[i])\n\t}\n\treturn Type\n})()\n\nconsole.log(Tyle.isArray([])) // true\nconsole.log(Tyle.isNumber(''))\t// false\nconsole.log(Tyle.isString(''))\t// true\nconsole.log(Tyle.isObject({}))\t// true\nconsole.log(Tyle.isRegExp(/\\s/))\t// true\nconsole.log(Tyle.isNull(''))\t// false\n```\n## 6.设置透明度\n```javascript\nfunction setOpacity(elem,level){\n\tnode = typeof node == \"string\" ? document.getElementById(node) : node;//检测传进来node的类型\n\tif(document.all){\n\t\tnode.style.filter = 'alpha(opacity='+level+')';\n\t}else{\n\t\tnode.style.opacity  = level/100;\n\t}\n}\n//test\nsetOpacity(\"box1\",20);\nsetOpacity(\"box2\",80);\n```\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","slug":"JS实用技巧(二)","published":1,"updated":"2019-09-25T15:10:25.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o70012la2en7j6uudt","content":"<blockquote>\n<h3 id=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"><a href=\"#该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\" class=\"headerlink\" title=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"></a>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</h3></blockquote>\n<h2 id=\"1-十六进制颜色值的随机生成-2种方法\"><a href=\"#1-十六进制颜色值的随机生成-2种方法\" class=\"headerlink\" title=\"1.十六进制颜色值的随机生成(2种方法)\"></a>1.十六进制颜色值的随机生成(2种方法)</h2><pre><code class=\"javascript\">function getColor(){\n    var   arrStr = [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;],\n            strHas = &quot;#&quot;,\n            index;\n            for(var i=0;i&lt;6;i++){\n                index = Math.floor(Math.random()*14);\n                strHas += arrStr[index];\n            }\n    return strHas;\n}\ngetColor();//随机颜色值\n\nfunction getColor2(){\n    return &quot;#&quot;+(&quot;000&quot;+Math.floor(Math.random()*16777215).toString(16)).slice(-6);\n}\ngetColor2()//随机颜色值\n</code></pre>\n<p>说明：<br>1、16777215为16进制的颜色ffffff转成10进制的数字<br>2、转成16进制不足6位的以0来补充(经测试会有不足6位的情况出现)</p>\n<h2 id=\"2-Event兼容\"><a href=\"#2-Event兼容\" class=\"headerlink\" title=\"2.Event兼容\"></a>2.Event兼容</h2><pre><code class=\"javascript\">//兼容IE和Firefox的event对象\nbtn.onclick() = function(){\n    e = window.event || e;\n    //some code\n}\n\n//兼容srcElement和target(事件源)\nvar et = e.srcElement || e.target;\nconsole.log(et.tagName);\n\n//封装getEventTarget函数\nfunction getEventTarget(e){\n    e.window.event || e;\n    return e.srcElement || e.target;\n}\n</code></pre>\n<h2 id=\"3-阻止冒泡，封装stopPropagation函数\"><a href=\"#3-阻止冒泡，封装stopPropagation函数\" class=\"headerlink\" title=\"3.阻止冒泡，封装stopPropagation函数\"></a>3.阻止冒泡，封装stopPropagation函数</h2><pre><code class=\"javascript\">function stopPropagation(e){\n    e = window.event || e;\n    if(document.all){\n        cancelBubble = true;\n    }else{\n        e.stopPropagation();\n    }\n}\n//or\nfunction stopPropagation2(e){\n    e = window.event || e;\n    if(e.stopPropagation){\n        e.stopPropagation();\n    }else{\n        cancelBubble = true;\n    }\n}\n//demo\nbtn.onclick = function(e){\n    stopPropagation(e);\n}\n</code></pre>\n<p>document.all可以判断浏览器是否是IE;</p>\n<h2 id=\"4-添加事件监听-兼容\"><a href=\"#4-添加事件监听-兼容\" class=\"headerlink\" title=\"4.添加事件监听 兼容\"></a>4.添加事件监听 兼容</h2><pre><code class=\"javascript\">/*\n    添加事件监听 兼容\n    addEvent(elem,type,fn,choose);\n    elem 需要添加事件监听的元素\n    type 事件类型 一律不加on\n    fn 回调函数（要做的事情）\n    choose 冒泡或者捕捉 默认为false\n*/\nfunction addEvent(elem,type,fn,choose){\n    if(arguments.length &lt; 3){\n        return ;\n    }\n    //给choose赋初值\n    choose = choose || false;\n    //判断浏览器是否支持addEventListener\n    if(elem.addEventListener){\n        elem.addEventListener(type,fn,choose);\n    }else {\n        elem.attachEvent(&#39;on&#39;+type , fn , choose);\n    }\n}\n// demo:\nvar btn = document.querySelector(&quot;#btn&quot;);\non(btn,&quot;click&quot;,function(){\n    console.log(888);\n});\n</code></pre>\n<h2 id=\"5-类型判断函数\"><a href=\"#5-类型判断函数\" class=\"headerlink\" title=\"5.类型判断函数\"></a>5.类型判断函数</h2><pre><code class=\"javascript\">var Tyle = (function(){\n    var Type = {},\n        list = [&#39;String&#39;,&#39;Array&#39;,&#39;Object&#39;,&#39;Number&#39;,&#39;RegExp&#39;,&#39;Null&#39;];\n    for(var i=0;i&lt;list.length;i++){\n        (function(type){\n            Type[&#39;is&#39;+type] = function(obj){\n                return Object.prototype.toString.call(obj) === &#39;[object &#39;+type+&#39;]&#39;\n            }\n        })(list[i])\n    }\n    return Type\n})()\n\nconsole.log(Tyle.isArray([])) // true\nconsole.log(Tyle.isNumber(&#39;&#39;))    // false\nconsole.log(Tyle.isString(&#39;&#39;))    // true\nconsole.log(Tyle.isObject({}))    // true\nconsole.log(Tyle.isRegExp(/\\s/))    // true\nconsole.log(Tyle.isNull(&#39;&#39;))    // false\n</code></pre>\n<h2 id=\"6-设置透明度\"><a href=\"#6-设置透明度\" class=\"headerlink\" title=\"6.设置透明度\"></a>6.设置透明度</h2><pre><code class=\"javascript\">function setOpacity(elem,level){\n    node = typeof node == &quot;string&quot; ? document.getElementById(node) : node;//检测传进来node的类型\n    if(document.all){\n        node.style.filter = &#39;alpha(opacity=&#39;+level+&#39;)&#39;;\n    }else{\n        node.style.opacity  = level/100;\n    }\n}\n//test\nsetOpacity(&quot;box1&quot;,20);\nsetOpacity(&quot;box2&quot;,80);\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<h3 id=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"><a href=\"#该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\" class=\"headerlink\" title=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"></a>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</h3></blockquote>\n<h2 id=\"1-十六进制颜色值的随机生成-2种方法\"><a href=\"#1-十六进制颜色值的随机生成-2种方法\" class=\"headerlink\" title=\"1.十六进制颜色值的随机生成(2种方法)\"></a>1.十六进制颜色值的随机生成(2种方法)</h2><pre><code class=\"javascript\">function getColor(){\n    var   arrStr = [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;],\n            strHas = &quot;#&quot;,\n            index;\n            for(var i=0;i&lt;6;i++){\n                index = Math.floor(Math.random()*14);\n                strHas += arrStr[index];\n            }\n    return strHas;\n}\ngetColor();//随机颜色值\n\nfunction getColor2(){\n    return &quot;#&quot;+(&quot;000&quot;+Math.floor(Math.random()*16777215).toString(16)).slice(-6);\n}\ngetColor2()//随机颜色值\n</code></pre>\n<p>说明：<br>1、16777215为16进制的颜色ffffff转成10进制的数字<br>2、转成16进制不足6位的以0来补充(经测试会有不足6位的情况出现)</p>\n<h2 id=\"2-Event兼容\"><a href=\"#2-Event兼容\" class=\"headerlink\" title=\"2.Event兼容\"></a>2.Event兼容</h2><pre><code class=\"javascript\">//兼容IE和Firefox的event对象\nbtn.onclick() = function(){\n    e = window.event || e;\n    //some code\n}\n\n//兼容srcElement和target(事件源)\nvar et = e.srcElement || e.target;\nconsole.log(et.tagName);\n\n//封装getEventTarget函数\nfunction getEventTarget(e){\n    e.window.event || e;\n    return e.srcElement || e.target;\n}\n</code></pre>\n<h2 id=\"3-阻止冒泡，封装stopPropagation函数\"><a href=\"#3-阻止冒泡，封装stopPropagation函数\" class=\"headerlink\" title=\"3.阻止冒泡，封装stopPropagation函数\"></a>3.阻止冒泡，封装stopPropagation函数</h2><pre><code class=\"javascript\">function stopPropagation(e){\n    e = window.event || e;\n    if(document.all){\n        cancelBubble = true;\n    }else{\n        e.stopPropagation();\n    }\n}\n//or\nfunction stopPropagation2(e){\n    e = window.event || e;\n    if(e.stopPropagation){\n        e.stopPropagation();\n    }else{\n        cancelBubble = true;\n    }\n}\n//demo\nbtn.onclick = function(e){\n    stopPropagation(e);\n}\n</code></pre>\n<p>document.all可以判断浏览器是否是IE;</p>\n<h2 id=\"4-添加事件监听-兼容\"><a href=\"#4-添加事件监听-兼容\" class=\"headerlink\" title=\"4.添加事件监听 兼容\"></a>4.添加事件监听 兼容</h2><pre><code class=\"javascript\">/*\n    添加事件监听 兼容\n    addEvent(elem,type,fn,choose);\n    elem 需要添加事件监听的元素\n    type 事件类型 一律不加on\n    fn 回调函数（要做的事情）\n    choose 冒泡或者捕捉 默认为false\n*/\nfunction addEvent(elem,type,fn,choose){\n    if(arguments.length &lt; 3){\n        return ;\n    }\n    //给choose赋初值\n    choose = choose || false;\n    //判断浏览器是否支持addEventListener\n    if(elem.addEventListener){\n        elem.addEventListener(type,fn,choose);\n    }else {\n        elem.attachEvent(&#39;on&#39;+type , fn , choose);\n    }\n}\n// demo:\nvar btn = document.querySelector(&quot;#btn&quot;);\non(btn,&quot;click&quot;,function(){\n    console.log(888);\n});\n</code></pre>\n<h2 id=\"5-类型判断函数\"><a href=\"#5-类型判断函数\" class=\"headerlink\" title=\"5.类型判断函数\"></a>5.类型判断函数</h2><pre><code class=\"javascript\">var Tyle = (function(){\n    var Type = {},\n        list = [&#39;String&#39;,&#39;Array&#39;,&#39;Object&#39;,&#39;Number&#39;,&#39;RegExp&#39;,&#39;Null&#39;];\n    for(var i=0;i&lt;list.length;i++){\n        (function(type){\n            Type[&#39;is&#39;+type] = function(obj){\n                return Object.prototype.toString.call(obj) === &#39;[object &#39;+type+&#39;]&#39;\n            }\n        })(list[i])\n    }\n    return Type\n})()\n\nconsole.log(Tyle.isArray([])) // true\nconsole.log(Tyle.isNumber(&#39;&#39;))    // false\nconsole.log(Tyle.isString(&#39;&#39;))    // true\nconsole.log(Tyle.isObject({}))    // true\nconsole.log(Tyle.isRegExp(/\\s/))    // true\nconsole.log(Tyle.isNull(&#39;&#39;))    // false\n</code></pre>\n<h2 id=\"6-设置透明度\"><a href=\"#6-设置透明度\" class=\"headerlink\" title=\"6.设置透明度\"></a>6.设置透明度</h2><pre><code class=\"javascript\">function setOpacity(elem,level){\n    node = typeof node == &quot;string&quot; ? document.getElementById(node) : node;//检测传进来node的类型\n    if(document.all){\n        node.style.filter = &#39;alpha(opacity=&#39;+level+&#39;)&#39;;\n    }else{\n        node.style.opacity  = level/100;\n    }\n}\n//test\nsetOpacity(&quot;box1&quot;,20);\nsetOpacity(&quot;box2&quot;,80);\n</code></pre>\n"},{"title":"JS实用技巧(四)","date":"2017-01-08T12:51:49.000Z","subtitle":"","author":"Yuqi Bi","header-img":"form-opts.png","cdn":"header-on","_content":"> ### 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n<!-- more -->\n## 1.判断函数的类型\n```javascript\n//ex:判断一个数据是否是数组Object.prototype.toString.call(obj)返回一个字符串\n//比如 Object.prototype.toString.call( [1,2,3] ) 总 是 返 回 \"[object Array]\"\n//Object.prototype.toString.call( “str”)总是返回\"[object String]\"\n\nvar isString = function(obj){\n\treturn Object.prototype.toString.call(obj) === '[object String]';\n}\nvar isArray = function(obj){\n\treturn Object.prototype.toString.call(obj) === '[object Array]';\n}\nvar isNumber = function(obj){\n\treturn Object.prototype.toString.call(ojb) === '[object Number]';\n}\n//调用\nconsole.log( isString('abc') );//true\nconsole.log( isArray([1,2,3]) );//true\n```\n改进\n```javascript\n//这些函数大部分实现都是相同的，\n//不同的只是返回的字符串的类型，\n//可以把字符串作为参数提前植入\nvar isType = function(type){\n\treturn function(obj){\n\t\treturn Object.prototype.toString.call(obj) === '[object '+type+']';\n\t}\n};\nvar isString = isType('String');\nvar isArray = isType('Array');\nvar isNumber = isType('Number');\n\n//调用\nconsole.log( isArray([1,2]) );//true\nconsole.log( isArray('str') );// false\n```\n## 2.防止连续点击造成事件Bug\n(比如轮播按钮快速点击，表单重复多次提交，这里就需要判断两次点击事件间隔，来做判断)\n```javascript\n//原生JS\nvar testBtnt = document.querySelector('.btn');\n//初始时间戳\nvar _thistime = Date.now();\ntestBtnt.onclick = function(){\n\t//比较两次点击之间的时间，如果点击过快，return\n\tif((Date.now() - _thistime) < 700){//事件为毫秒，需要自己设定\n\t\treturn false;\n\t}else{//符合点击范围\n\t\t//时间保留到上次点击的地方\n\t\t_thistime = Date.now();\n\t\t//do some code\n\t}\n}\n```\n## 3.判断对象的属性存在于实例中，还是原型中\n```javascript\n/*\n*object:实例对象\n*name:要查询的属性\n*/\nfunction hasPrototypeProperty(object,name){\n\treturn  !object.hasOwnProperty(name) && (name in object);\n}\n//in 只要通过对象能访问到属性就返回true\n//hasOwnproperty()只有属性存在于实例中才会返回true\n```\n**Test：**\n```javascript\nfunction Person(){\n}\nPerson.prototype.name = \"loading\";\nPerson.prototype.age = 34;\nvar person = new Person();\nconsole.log( hasPrototypeProperty(person,'name') );//true;\nperson.name = \"caricai\";\nconsole.log( hasPrototypeProperty(person,'name') );//false\n```\n## 4.RGBA实现随机颜色\n```javascript\nfunction getColor(){\n    var strColor = [\n        Math.floor(Math.random() * 255),\n        Math.floor(Math.random() * 255),\n        Math.floor(Math.random() * 255)\n    ];\n    var strNum = strColor.join(',');\n    var rgba = 'rgba('+strNum+')';\n    return rgba;\n}\nconsole.log(getColor());得到随机值rgba();\n```\n## 5.找出字符串中最长的单词并输出其长度\n```javascript\nvar string = \"The over the; lazy dog, May with you wohennia shabiad.\";\nfunction findLongWord(str){\n    //对, . ; 先做了过滤 用空格分开 转化成数组 成为单词\n    var str = str.replace(/[,.;]*/g ,'').split(' ');\n    //进行长度比较\n    var len = 0;\n    //储存最长的单词\n    var s = '';\n    for(var i=0;i<str.length;i++){\n        if(len < str[i].length){\n            len = str[i].length;\n            s = str[i];\n        }\n    }\n    //返回值\n    return ('最长单词是:'+s +',长度为:'+s.length)\n}\nconsole.log(findLongWord(string));\n```\n## 6.判断是否为空对象\n```javascript\nfunction isEmpty(obj){\n   for(var key in obj){\n\t   return false;\n   }\n   return true;\n};\nvar o = {};\nisEmpty(o);//true\no.name=\"biyuqi\";\nisEmpty(o);//false\n```\n  [1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","source":"_posts/JS实用技巧(四).md","raw":"---\ntitle: JS实用技巧(四)\ndate: 2017-01-08 20:51:49\ntags: ['javascript',\"Js技巧\"]\nsubtitle: \"\"\nauthor: \"Yuqi Bi\"\nheader-img: \"form-opts.png\"\ncdn: 'header-on'\n---\n> ### 该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\n\n<!-- more -->\n## 1.判断函数的类型\n```javascript\n//ex:判断一个数据是否是数组Object.prototype.toString.call(obj)返回一个字符串\n//比如 Object.prototype.toString.call( [1,2,3] ) 总 是 返 回 \"[object Array]\"\n//Object.prototype.toString.call( “str”)总是返回\"[object String]\"\n\nvar isString = function(obj){\n\treturn Object.prototype.toString.call(obj) === '[object String]';\n}\nvar isArray = function(obj){\n\treturn Object.prototype.toString.call(obj) === '[object Array]';\n}\nvar isNumber = function(obj){\n\treturn Object.prototype.toString.call(ojb) === '[object Number]';\n}\n//调用\nconsole.log( isString('abc') );//true\nconsole.log( isArray([1,2,3]) );//true\n```\n改进\n```javascript\n//这些函数大部分实现都是相同的，\n//不同的只是返回的字符串的类型，\n//可以把字符串作为参数提前植入\nvar isType = function(type){\n\treturn function(obj){\n\t\treturn Object.prototype.toString.call(obj) === '[object '+type+']';\n\t}\n};\nvar isString = isType('String');\nvar isArray = isType('Array');\nvar isNumber = isType('Number');\n\n//调用\nconsole.log( isArray([1,2]) );//true\nconsole.log( isArray('str') );// false\n```\n## 2.防止连续点击造成事件Bug\n(比如轮播按钮快速点击，表单重复多次提交，这里就需要判断两次点击事件间隔，来做判断)\n```javascript\n//原生JS\nvar testBtnt = document.querySelector('.btn');\n//初始时间戳\nvar _thistime = Date.now();\ntestBtnt.onclick = function(){\n\t//比较两次点击之间的时间，如果点击过快，return\n\tif((Date.now() - _thistime) < 700){//事件为毫秒，需要自己设定\n\t\treturn false;\n\t}else{//符合点击范围\n\t\t//时间保留到上次点击的地方\n\t\t_thistime = Date.now();\n\t\t//do some code\n\t}\n}\n```\n## 3.判断对象的属性存在于实例中，还是原型中\n```javascript\n/*\n*object:实例对象\n*name:要查询的属性\n*/\nfunction hasPrototypeProperty(object,name){\n\treturn  !object.hasOwnProperty(name) && (name in object);\n}\n//in 只要通过对象能访问到属性就返回true\n//hasOwnproperty()只有属性存在于实例中才会返回true\n```\n**Test：**\n```javascript\nfunction Person(){\n}\nPerson.prototype.name = \"loading\";\nPerson.prototype.age = 34;\nvar person = new Person();\nconsole.log( hasPrototypeProperty(person,'name') );//true;\nperson.name = \"caricai\";\nconsole.log( hasPrototypeProperty(person,'name') );//false\n```\n## 4.RGBA实现随机颜色\n```javascript\nfunction getColor(){\n    var strColor = [\n        Math.floor(Math.random() * 255),\n        Math.floor(Math.random() * 255),\n        Math.floor(Math.random() * 255)\n    ];\n    var strNum = strColor.join(',');\n    var rgba = 'rgba('+strNum+')';\n    return rgba;\n}\nconsole.log(getColor());得到随机值rgba();\n```\n## 5.找出字符串中最长的单词并输出其长度\n```javascript\nvar string = \"The over the; lazy dog, May with you wohennia shabiad.\";\nfunction findLongWord(str){\n    //对, . ; 先做了过滤 用空格分开 转化成数组 成为单词\n    var str = str.replace(/[,.;]*/g ,'').split(' ');\n    //进行长度比较\n    var len = 0;\n    //储存最长的单词\n    var s = '';\n    for(var i=0;i<str.length;i++){\n        if(len < str[i].length){\n            len = str[i].length;\n            s = str[i];\n        }\n    }\n    //返回值\n    return ('最长单词是:'+s +',长度为:'+s.length)\n}\nconsole.log(findLongWord(string));\n```\n## 6.判断是否为空对象\n```javascript\nfunction isEmpty(obj){\n   for(var key in obj){\n\t   return false;\n   }\n   return true;\n};\nvar o = {};\nisEmpty(o);//true\no.name=\"biyuqi\";\nisEmpty(o);//false\n```\n  [1]: http://oiukswkar.bkt.clouddn.com/Js-jq.jpg\n","slug":"JS实用技巧(四)","published":1,"updated":"2019-09-25T15:10:25.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o80014la2el28q70zp","content":"<blockquote>\n<h3 id=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"><a href=\"#该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\" class=\"headerlink\" title=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"></a>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</h3></blockquote>\n<a id=\"more\"></a>\n<h2 id=\"1-判断函数的类型\"><a href=\"#1-判断函数的类型\" class=\"headerlink\" title=\"1.判断函数的类型\"></a>1.判断函数的类型</h2><pre><code class=\"javascript\">//ex:判断一个数据是否是数组Object.prototype.toString.call(obj)返回一个字符串\n//比如 Object.prototype.toString.call( [1,2,3] ) 总 是 返 回 &quot;[object Array]&quot;\n//Object.prototype.toString.call( “str”)总是返回&quot;[object String]&quot;\n\nvar isString = function(obj){\n    return Object.prototype.toString.call(obj) === &#39;[object String]&#39;;\n}\nvar isArray = function(obj){\n    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39;;\n}\nvar isNumber = function(obj){\n    return Object.prototype.toString.call(ojb) === &#39;[object Number]&#39;;\n}\n//调用\nconsole.log( isString(&#39;abc&#39;) );//true\nconsole.log( isArray([1,2,3]) );//true\n</code></pre>\n<p>改进</p>\n<pre><code class=\"javascript\">//这些函数大部分实现都是相同的，\n//不同的只是返回的字符串的类型，\n//可以把字符串作为参数提前植入\nvar isType = function(type){\n    return function(obj){\n        return Object.prototype.toString.call(obj) === &#39;[object &#39;+type+&#39;]&#39;;\n    }\n};\nvar isString = isType(&#39;String&#39;);\nvar isArray = isType(&#39;Array&#39;);\nvar isNumber = isType(&#39;Number&#39;);\n\n//调用\nconsole.log( isArray([1,2]) );//true\nconsole.log( isArray(&#39;str&#39;) );// false\n</code></pre>\n<h2 id=\"2-防止连续点击造成事件Bug\"><a href=\"#2-防止连续点击造成事件Bug\" class=\"headerlink\" title=\"2.防止连续点击造成事件Bug\"></a>2.防止连续点击造成事件Bug</h2><p>(比如轮播按钮快速点击，表单重复多次提交，这里就需要判断两次点击事件间隔，来做判断)</p>\n<pre><code class=\"javascript\">//原生JS\nvar testBtnt = document.querySelector(&#39;.btn&#39;);\n//初始时间戳\nvar _thistime = Date.now();\ntestBtnt.onclick = function(){\n    //比较两次点击之间的时间，如果点击过快，return\n    if((Date.now() - _thistime) &lt; 700){//事件为毫秒，需要自己设定\n        return false;\n    }else{//符合点击范围\n        //时间保留到上次点击的地方\n        _thistime = Date.now();\n        //do some code\n    }\n}\n</code></pre>\n<h2 id=\"3-判断对象的属性存在于实例中，还是原型中\"><a href=\"#3-判断对象的属性存在于实例中，还是原型中\" class=\"headerlink\" title=\"3.判断对象的属性存在于实例中，还是原型中\"></a>3.判断对象的属性存在于实例中，还是原型中</h2><pre><code class=\"javascript\">/*\n*object:实例对象\n*name:要查询的属性\n*/\nfunction hasPrototypeProperty(object,name){\n    return  !object.hasOwnProperty(name) &amp;&amp; (name in object);\n}\n//in 只要通过对象能访问到属性就返回true\n//hasOwnproperty()只有属性存在于实例中才会返回true\n</code></pre>\n<p><strong>Test：</strong></p>\n<pre><code class=\"javascript\">function Person(){\n}\nPerson.prototype.name = &quot;loading&quot;;\nPerson.prototype.age = 34;\nvar person = new Person();\nconsole.log( hasPrototypeProperty(person,&#39;name&#39;) );//true;\nperson.name = &quot;caricai&quot;;\nconsole.log( hasPrototypeProperty(person,&#39;name&#39;) );//false\n</code></pre>\n<h2 id=\"4-RGBA实现随机颜色\"><a href=\"#4-RGBA实现随机颜色\" class=\"headerlink\" title=\"4.RGBA实现随机颜色\"></a>4.RGBA实现随机颜色</h2><pre><code class=\"javascript\">function getColor(){\n    var strColor = [\n        Math.floor(Math.random() * 255),\n        Math.floor(Math.random() * 255),\n        Math.floor(Math.random() * 255)\n    ];\n    var strNum = strColor.join(&#39;,&#39;);\n    var rgba = &#39;rgba(&#39;+strNum+&#39;)&#39;;\n    return rgba;\n}\nconsole.log(getColor());得到随机值rgba();\n</code></pre>\n<h2 id=\"5-找出字符串中最长的单词并输出其长度\"><a href=\"#5-找出字符串中最长的单词并输出其长度\" class=\"headerlink\" title=\"5.找出字符串中最长的单词并输出其长度\"></a>5.找出字符串中最长的单词并输出其长度</h2><pre><code class=\"javascript\">var string = &quot;The over the; lazy dog, May with you wohennia shabiad.&quot;;\nfunction findLongWord(str){\n    //对, . ; 先做了过滤 用空格分开 转化成数组 成为单词\n    var str = str.replace(/[,.;]*/g ,&#39;&#39;).split(&#39; &#39;);\n    //进行长度比较\n    var len = 0;\n    //储存最长的单词\n    var s = &#39;&#39;;\n    for(var i=0;i&lt;str.length;i++){\n        if(len &lt; str[i].length){\n            len = str[i].length;\n            s = str[i];\n        }\n    }\n    //返回值\n    return (&#39;最长单词是:&#39;+s +&#39;,长度为:&#39;+s.length)\n}\nconsole.log(findLongWord(string));\n</code></pre>\n<h2 id=\"6-判断是否为空对象\"><a href=\"#6-判断是否为空对象\" class=\"headerlink\" title=\"6.判断是否为空对象\"></a>6.判断是否为空对象</h2><pre><code class=\"javascript\">function isEmpty(obj){\n   for(var key in obj){\n       return false;\n   }\n   return true;\n};\nvar o = {};\nisEmpty(o);//true\no.name=&quot;biyuqi&quot;;\nisEmpty(o);//false\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<h3 id=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"><a href=\"#该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\" class=\"headerlink\" title=\"该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。\"></a>该系列文章主要记录自己平常所用，js一些技巧，作为知识的积累。</h3></blockquote>","more":"<h2 id=\"1-判断函数的类型\"><a href=\"#1-判断函数的类型\" class=\"headerlink\" title=\"1.判断函数的类型\"></a>1.判断函数的类型</h2><pre><code class=\"javascript\">//ex:判断一个数据是否是数组Object.prototype.toString.call(obj)返回一个字符串\n//比如 Object.prototype.toString.call( [1,2,3] ) 总 是 返 回 &quot;[object Array]&quot;\n//Object.prototype.toString.call( “str”)总是返回&quot;[object String]&quot;\n\nvar isString = function(obj){\n    return Object.prototype.toString.call(obj) === &#39;[object String]&#39;;\n}\nvar isArray = function(obj){\n    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39;;\n}\nvar isNumber = function(obj){\n    return Object.prototype.toString.call(ojb) === &#39;[object Number]&#39;;\n}\n//调用\nconsole.log( isString(&#39;abc&#39;) );//true\nconsole.log( isArray([1,2,3]) );//true\n</code></pre>\n<p>改进</p>\n<pre><code class=\"javascript\">//这些函数大部分实现都是相同的，\n//不同的只是返回的字符串的类型，\n//可以把字符串作为参数提前植入\nvar isType = function(type){\n    return function(obj){\n        return Object.prototype.toString.call(obj) === &#39;[object &#39;+type+&#39;]&#39;;\n    }\n};\nvar isString = isType(&#39;String&#39;);\nvar isArray = isType(&#39;Array&#39;);\nvar isNumber = isType(&#39;Number&#39;);\n\n//调用\nconsole.log( isArray([1,2]) );//true\nconsole.log( isArray(&#39;str&#39;) );// false\n</code></pre>\n<h2 id=\"2-防止连续点击造成事件Bug\"><a href=\"#2-防止连续点击造成事件Bug\" class=\"headerlink\" title=\"2.防止连续点击造成事件Bug\"></a>2.防止连续点击造成事件Bug</h2><p>(比如轮播按钮快速点击，表单重复多次提交，这里就需要判断两次点击事件间隔，来做判断)</p>\n<pre><code class=\"javascript\">//原生JS\nvar testBtnt = document.querySelector(&#39;.btn&#39;);\n//初始时间戳\nvar _thistime = Date.now();\ntestBtnt.onclick = function(){\n    //比较两次点击之间的时间，如果点击过快，return\n    if((Date.now() - _thistime) &lt; 700){//事件为毫秒，需要自己设定\n        return false;\n    }else{//符合点击范围\n        //时间保留到上次点击的地方\n        _thistime = Date.now();\n        //do some code\n    }\n}\n</code></pre>\n<h2 id=\"3-判断对象的属性存在于实例中，还是原型中\"><a href=\"#3-判断对象的属性存在于实例中，还是原型中\" class=\"headerlink\" title=\"3.判断对象的属性存在于实例中，还是原型中\"></a>3.判断对象的属性存在于实例中，还是原型中</h2><pre><code class=\"javascript\">/*\n*object:实例对象\n*name:要查询的属性\n*/\nfunction hasPrototypeProperty(object,name){\n    return  !object.hasOwnProperty(name) &amp;&amp; (name in object);\n}\n//in 只要通过对象能访问到属性就返回true\n//hasOwnproperty()只有属性存在于实例中才会返回true\n</code></pre>\n<p><strong>Test：</strong></p>\n<pre><code class=\"javascript\">function Person(){\n}\nPerson.prototype.name = &quot;loading&quot;;\nPerson.prototype.age = 34;\nvar person = new Person();\nconsole.log( hasPrototypeProperty(person,&#39;name&#39;) );//true;\nperson.name = &quot;caricai&quot;;\nconsole.log( hasPrototypeProperty(person,&#39;name&#39;) );//false\n</code></pre>\n<h2 id=\"4-RGBA实现随机颜色\"><a href=\"#4-RGBA实现随机颜色\" class=\"headerlink\" title=\"4.RGBA实现随机颜色\"></a>4.RGBA实现随机颜色</h2><pre><code class=\"javascript\">function getColor(){\n    var strColor = [\n        Math.floor(Math.random() * 255),\n        Math.floor(Math.random() * 255),\n        Math.floor(Math.random() * 255)\n    ];\n    var strNum = strColor.join(&#39;,&#39;);\n    var rgba = &#39;rgba(&#39;+strNum+&#39;)&#39;;\n    return rgba;\n}\nconsole.log(getColor());得到随机值rgba();\n</code></pre>\n<h2 id=\"5-找出字符串中最长的单词并输出其长度\"><a href=\"#5-找出字符串中最长的单词并输出其长度\" class=\"headerlink\" title=\"5.找出字符串中最长的单词并输出其长度\"></a>5.找出字符串中最长的单词并输出其长度</h2><pre><code class=\"javascript\">var string = &quot;The over the; lazy dog, May with you wohennia shabiad.&quot;;\nfunction findLongWord(str){\n    //对, . ; 先做了过滤 用空格分开 转化成数组 成为单词\n    var str = str.replace(/[,.;]*/g ,&#39;&#39;).split(&#39; &#39;);\n    //进行长度比较\n    var len = 0;\n    //储存最长的单词\n    var s = &#39;&#39;;\n    for(var i=0;i&lt;str.length;i++){\n        if(len &lt; str[i].length){\n            len = str[i].length;\n            s = str[i];\n        }\n    }\n    //返回值\n    return (&#39;最长单词是:&#39;+s +&#39;,长度为:&#39;+s.length)\n}\nconsole.log(findLongWord(string));\n</code></pre>\n<h2 id=\"6-判断是否为空对象\"><a href=\"#6-判断是否为空对象\" class=\"headerlink\" title=\"6.判断是否为空对象\"></a>6.判断是否为空对象</h2><pre><code class=\"javascript\">function isEmpty(obj){\n   for(var key in obj){\n       return false;\n   }\n   return true;\n};\nvar o = {};\nisEmpty(o);//true\no.name=&quot;biyuqi&quot;;\nisEmpty(o);//false\n</code></pre>"},{"title":"JS数组常用的方法总结","date":"2016-12-28T13:19:37.000Z","_content":"## 前言\n数组应该是js中比较常用到的数据类型了，它有着独有的数据特点：\n* 数组可以保存任意的数据类型 (字符串，数值，对象)\n* 大小动态调整(随着数据的添加自动增长)\n\n<!-- more -->\n\n## 创建方式\n* Array构造函数\n```javascript\nvar colors = new Array();\n```\n* 数组字面量表示\n```javascript\nvar colors = [\"red\",\"blue\",\"green\"]\n```\n## 常用的方法\n* ## push()\n接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。\n```javascript\nvar colors = [];\ncolors.push(\"red\",\"green\");\nconsole.log(colors) //red green 添加两项\n\ncolors.push(\"black\");\nconsole.log(colors);// red green black 又追加一项\n```\n* ## pop()\n从数组末尾移除最后一项，减少length值,返回移除的项.\n```javascript\nvar colors = [];\ncolors.push(\"red\",\"green\",\"black\");\nvar item = colors.pop();\n\nconsole.log(item); //balck 返回抓取到的值\n\nconsole.log(colors);//red green 原数组值减去\n\nconsole.log(colors.length);//2\n```\n---\n* shift()\n移除数组中的第一个项，并返回该项，同时数组长度减1.\n```javascript\nvar colors = [];\ncolors.push(\"red\",\"green\",\"black\");\nvar item2 = colors.shift();\n\nconsole.log(item2); //red 返回抓取到的值\n\nconsole.log(colors);// green black原数组值减去\n\nconsole.log(colors.length);//2\n```\n* unshift()\n在数组前端添加**任意**个项，并返回新数组长度\n```javascript\nvar colors = [];\ncolors.push(\"red\",\"green\",\"black\");\nvar item3 = colors.unshift(\"yellow\",\"limegreen\");\n\nconsole.log(item3); //red green 返回抓取到的值\n\nconsole.log(colors);// green black black yellow limegreen原数组值减去\n\nconsole.log(colors.length);//5\n```\n* ## sort() 排序方法\n针对原数组进行的排序，不会生成新的数组\n默认sort()不带参数是按照数组中的元素换成字符串进行比较(从小到大)\nex:\n```javascript\n var arr = [1,21,8,2,7,5];\n arr.sort();// 1, 2, 21, 5, 7, 8\n```\n## 排序\n```javascript\n var arr = [1,21,8,2,7,5];\n \n//升序\narr.sort(function(a,b){\n\treturn a-b;\n})\nconsole.log(arr);//1,2,5,7,8,21 真正意义上的从小到大\n\n//降序\narr.sort(function(a,b){\n\treturn b-a;\n})\nconsole.log(arr);//21,,8,7,5,2,1 真正意义上的大到小\n```\n## 数组操作方法\n* ## concat(item1,item2)\n基于当前数组中的所有项创建一个新的数组。不操作原数组.\n```javascript\nvar arr1 = [1,2,3,4];\nvar arr2 = [1,7,8];\nvar con = arr1.concat(arr2);\nconsole.log(con);//1,2,3,4,1,7,8\n```\n* ## slice 截取数组\n基于当前数组中的一个或者多个项创建一个新的数组，接收一个或者两个参数，即**要返回项的起始和结束位置，如果只有一个参数，返回该参数指定位置开始到数组末尾的所有项，如果两个参数，返回起始和结束位置之间的项（但是不包括结束位置项）**.\n```javascript\nvar arr1 = [1,2,3,4,5,6,7,8,9];\nvar arr2 = arr1.slice(1);\nvar arr3 = arr1.slice(1,4);\n\nconsole.log(arr2);//2,3,4,5,6,7,8,9; 索引从0开始\nconsole.log(arr3);//2,3,4；不包括最后一项\n\n//如果slice 方法中有一个负数，则可以用数组长度加上该数来确定位置\n```\n* ## splice \n主要用途向数组中部插入项：操作的是原数组\n### 删除：\n可以删除任意数量项，只需制定2个参数：要删除的第第一项的位置和删除的项数。例如：splice(0,3);会删除数组中的前3项.\n### 插入：\n可以插入任意数量项，只需制定3个参数：起始位置，0(要删除的项数)，要插入的项。如果要插入多个，可再传第四，第五项...；ex:splice(2,0,\"red\",\"green\"),从2位置开始插入“red”,\"green\";\n### 替换：\n可以插入任意数量项，只需制定3个参数：起始位置，0(要删除的项数)，要插入的项(不必与删除数量相同)。ex:splice(2,1,\"red\",\"green\"),从2位置开始插入“red”,\"green\";\n```javascript\nvar colors = [\"red\",\"green\",\"blue\"];\nvar removed = colors.splice(0,1);\nconsole.log(colors);//green,blue\nconsole.log(removed);//red 返回的数组中只包含一项\n\nremoved = colors.splice(1,0,\"yellow\",\"orange\"); //从1位置插入2项\nconsole.log(colors);//green yellow orange blue\nconsole.log(removed);//返回空数组，因为没有删除项，仅仅插入\n\nremoved = colors.splice(1,1,\"red\",\"purple\");\nconsole.log(colors);//green red purple orange blue\nconsole.log(removed);//ywllow\n```\n## 位置方法\n>ES5为数组添加了两个位置方法：indexOf()   LastIndexOf().\n都接收两个参数 : 要查找的项和(可选的)表示查找起点位置的索引;\n\n* indexOf()\n从数组的开头开始向后查找：\n```javascript\nvar numbers = [1,2,3,4,5,6,7];\nconsole.log(numbers.indexOf(3));//返回索引 2\n```\n* lastIndexOf()\n从数组的开头开始向后查找：\n```javascript\nvar numbers = [1,2,3,4,5,6,7];\nconsole.log(numbers.lastIndexOf(3));//返回索引 4\n```\n注意：没有找到的情况下返回-1；比较数组每一项时，使用全等操作符；支持IE9+;  \n## 迭代方法\nES5为数组定义了5个迭代方法：\n* every():对数组中的每一项运行给定函数，如果该函数每一项都返回true，则返回true;\n* filter():对数组中的每一项运行给定函数，返回该函数会返回true的项，组成的数组；\n* forEach():对数组中的每一项给定函数，没有返回值；\n* map():对数组中的每一项给定函数;返回每次函数调用的结果组成的数组；\n* some():对数组中的每一项给定函数;如果该函数对任意一项返回true，则返回true;\n\n** 以上方法中，最相似的是every some，都是用于查询数组中的项是否满足某个条件，every()，传入每一项都返回true时才为true，some()相反 **\n```javascript\nvar numbers = [1,2,3,4,5,7,8];\nvar everyReault = numbers.every(function(item,index,array){\n\treturn (item > 2);//\n})\nconsole.log(everyReault);//false 不满足条件\n```\n```javascript\nvar numbers = [1,2,3,4,5,7,8];\nvar everyReault = numbers.some(function(item,index,array){\n\treturn (item > 2);//\n})\nconsole.log(everyReault);//true 满足条件\n```\n** filter() 自定函数确定是否在返回的数组中包含一项要返回一个大于2的数组**\n```javascript\nvar num = [1,2,3,4,5,2,1];\nvar filterResult = num.filter(function(item,index,array){\n\treturn (item >2)\n})\nconsole.log(filterReault); //[3,4,5,]\n```\n** map()函数也返回一个数组，该数组每一项都会在原始数组的对应项上运行传入函数的结果，例如给数组中每一项*2，返回乘积后的数组**\n```javascript\nvar num = [2,3,4,5,6,7];\nvar mapResult = num.map(function(item,index,array){\n\treturn (item*2)\n})\nconsole.log(mapResult);  //[4,6,10,12,14]]\n```\n** forEach() 对数组每一项进行遍历，没有返回值，本质上与使用for 循环迭代数组一样。**\n```javascript\nvar num = [1,2,3,4,5];\nnum.forEach(functin(item,index,array){\n\t//执行some code\n})\n```\n注：支持IE9+\n## 归并方法\n** ES5新增了两个归并数组的方法:reduce() 和 reduceRight()**\n都会迭代所有数组，然后构建一个返回值，reduce()方法从数组第一项开始，遍历到最后，reduceRight()则相反。都接收两个参数：一个在每一项上调用的函数(可选)作为归并基础的初始值。\n这两个方法接收4个参数：前一个值，当前值，项的索引，数组对象；\n```javascript\n//利用reduce方法可以执行求数组和\nvar num = [2,3,4,5];\nvar sum = num.reduce(function(prev,cur,index,array){\n\treturn prev + cur;\n})\nconsole.log(sum); //14;\n```\n```javascript\n//利用reduceRight方法可以执行求数组和,方向相反\nvar num = [2,3,4,5];\nvar sum = num.reduceRight(function(prev,cur,index,array){\n\treturn prev + cur;\n})\nconsole.log(sum); //14;\n```\n注：支持IE9+\n## 小结\n","source":"_posts/JS数组常用的方法总结.md","raw":"---\ntitle: JS数组常用的方法总结\ndate: 2016-12-28 21:19:37\ntags: [javascript]\ncategories: Javascript\n---\n## 前言\n数组应该是js中比较常用到的数据类型了，它有着独有的数据特点：\n* 数组可以保存任意的数据类型 (字符串，数值，对象)\n* 大小动态调整(随着数据的添加自动增长)\n\n<!-- more -->\n\n## 创建方式\n* Array构造函数\n```javascript\nvar colors = new Array();\n```\n* 数组字面量表示\n```javascript\nvar colors = [\"red\",\"blue\",\"green\"]\n```\n## 常用的方法\n* ## push()\n接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。\n```javascript\nvar colors = [];\ncolors.push(\"red\",\"green\");\nconsole.log(colors) //red green 添加两项\n\ncolors.push(\"black\");\nconsole.log(colors);// red green black 又追加一项\n```\n* ## pop()\n从数组末尾移除最后一项，减少length值,返回移除的项.\n```javascript\nvar colors = [];\ncolors.push(\"red\",\"green\",\"black\");\nvar item = colors.pop();\n\nconsole.log(item); //balck 返回抓取到的值\n\nconsole.log(colors);//red green 原数组值减去\n\nconsole.log(colors.length);//2\n```\n---\n* shift()\n移除数组中的第一个项，并返回该项，同时数组长度减1.\n```javascript\nvar colors = [];\ncolors.push(\"red\",\"green\",\"black\");\nvar item2 = colors.shift();\n\nconsole.log(item2); //red 返回抓取到的值\n\nconsole.log(colors);// green black原数组值减去\n\nconsole.log(colors.length);//2\n```\n* unshift()\n在数组前端添加**任意**个项，并返回新数组长度\n```javascript\nvar colors = [];\ncolors.push(\"red\",\"green\",\"black\");\nvar item3 = colors.unshift(\"yellow\",\"limegreen\");\n\nconsole.log(item3); //red green 返回抓取到的值\n\nconsole.log(colors);// green black black yellow limegreen原数组值减去\n\nconsole.log(colors.length);//5\n```\n* ## sort() 排序方法\n针对原数组进行的排序，不会生成新的数组\n默认sort()不带参数是按照数组中的元素换成字符串进行比较(从小到大)\nex:\n```javascript\n var arr = [1,21,8,2,7,5];\n arr.sort();// 1, 2, 21, 5, 7, 8\n```\n## 排序\n```javascript\n var arr = [1,21,8,2,7,5];\n \n//升序\narr.sort(function(a,b){\n\treturn a-b;\n})\nconsole.log(arr);//1,2,5,7,8,21 真正意义上的从小到大\n\n//降序\narr.sort(function(a,b){\n\treturn b-a;\n})\nconsole.log(arr);//21,,8,7,5,2,1 真正意义上的大到小\n```\n## 数组操作方法\n* ## concat(item1,item2)\n基于当前数组中的所有项创建一个新的数组。不操作原数组.\n```javascript\nvar arr1 = [1,2,3,4];\nvar arr2 = [1,7,8];\nvar con = arr1.concat(arr2);\nconsole.log(con);//1,2,3,4,1,7,8\n```\n* ## slice 截取数组\n基于当前数组中的一个或者多个项创建一个新的数组，接收一个或者两个参数，即**要返回项的起始和结束位置，如果只有一个参数，返回该参数指定位置开始到数组末尾的所有项，如果两个参数，返回起始和结束位置之间的项（但是不包括结束位置项）**.\n```javascript\nvar arr1 = [1,2,3,4,5,6,7,8,9];\nvar arr2 = arr1.slice(1);\nvar arr3 = arr1.slice(1,4);\n\nconsole.log(arr2);//2,3,4,5,6,7,8,9; 索引从0开始\nconsole.log(arr3);//2,3,4；不包括最后一项\n\n//如果slice 方法中有一个负数，则可以用数组长度加上该数来确定位置\n```\n* ## splice \n主要用途向数组中部插入项：操作的是原数组\n### 删除：\n可以删除任意数量项，只需制定2个参数：要删除的第第一项的位置和删除的项数。例如：splice(0,3);会删除数组中的前3项.\n### 插入：\n可以插入任意数量项，只需制定3个参数：起始位置，0(要删除的项数)，要插入的项。如果要插入多个，可再传第四，第五项...；ex:splice(2,0,\"red\",\"green\"),从2位置开始插入“red”,\"green\";\n### 替换：\n可以插入任意数量项，只需制定3个参数：起始位置，0(要删除的项数)，要插入的项(不必与删除数量相同)。ex:splice(2,1,\"red\",\"green\"),从2位置开始插入“red”,\"green\";\n```javascript\nvar colors = [\"red\",\"green\",\"blue\"];\nvar removed = colors.splice(0,1);\nconsole.log(colors);//green,blue\nconsole.log(removed);//red 返回的数组中只包含一项\n\nremoved = colors.splice(1,0,\"yellow\",\"orange\"); //从1位置插入2项\nconsole.log(colors);//green yellow orange blue\nconsole.log(removed);//返回空数组，因为没有删除项，仅仅插入\n\nremoved = colors.splice(1,1,\"red\",\"purple\");\nconsole.log(colors);//green red purple orange blue\nconsole.log(removed);//ywllow\n```\n## 位置方法\n>ES5为数组添加了两个位置方法：indexOf()   LastIndexOf().\n都接收两个参数 : 要查找的项和(可选的)表示查找起点位置的索引;\n\n* indexOf()\n从数组的开头开始向后查找：\n```javascript\nvar numbers = [1,2,3,4,5,6,7];\nconsole.log(numbers.indexOf(3));//返回索引 2\n```\n* lastIndexOf()\n从数组的开头开始向后查找：\n```javascript\nvar numbers = [1,2,3,4,5,6,7];\nconsole.log(numbers.lastIndexOf(3));//返回索引 4\n```\n注意：没有找到的情况下返回-1；比较数组每一项时，使用全等操作符；支持IE9+;  \n## 迭代方法\nES5为数组定义了5个迭代方法：\n* every():对数组中的每一项运行给定函数，如果该函数每一项都返回true，则返回true;\n* filter():对数组中的每一项运行给定函数，返回该函数会返回true的项，组成的数组；\n* forEach():对数组中的每一项给定函数，没有返回值；\n* map():对数组中的每一项给定函数;返回每次函数调用的结果组成的数组；\n* some():对数组中的每一项给定函数;如果该函数对任意一项返回true，则返回true;\n\n** 以上方法中，最相似的是every some，都是用于查询数组中的项是否满足某个条件，every()，传入每一项都返回true时才为true，some()相反 **\n```javascript\nvar numbers = [1,2,3,4,5,7,8];\nvar everyReault = numbers.every(function(item,index,array){\n\treturn (item > 2);//\n})\nconsole.log(everyReault);//false 不满足条件\n```\n```javascript\nvar numbers = [1,2,3,4,5,7,8];\nvar everyReault = numbers.some(function(item,index,array){\n\treturn (item > 2);//\n})\nconsole.log(everyReault);//true 满足条件\n```\n** filter() 自定函数确定是否在返回的数组中包含一项要返回一个大于2的数组**\n```javascript\nvar num = [1,2,3,4,5,2,1];\nvar filterResult = num.filter(function(item,index,array){\n\treturn (item >2)\n})\nconsole.log(filterReault); //[3,4,5,]\n```\n** map()函数也返回一个数组，该数组每一项都会在原始数组的对应项上运行传入函数的结果，例如给数组中每一项*2，返回乘积后的数组**\n```javascript\nvar num = [2,3,4,5,6,7];\nvar mapResult = num.map(function(item,index,array){\n\treturn (item*2)\n})\nconsole.log(mapResult);  //[4,6,10,12,14]]\n```\n** forEach() 对数组每一项进行遍历，没有返回值，本质上与使用for 循环迭代数组一样。**\n```javascript\nvar num = [1,2,3,4,5];\nnum.forEach(functin(item,index,array){\n\t//执行some code\n})\n```\n注：支持IE9+\n## 归并方法\n** ES5新增了两个归并数组的方法:reduce() 和 reduceRight()**\n都会迭代所有数组，然后构建一个返回值，reduce()方法从数组第一项开始，遍历到最后，reduceRight()则相反。都接收两个参数：一个在每一项上调用的函数(可选)作为归并基础的初始值。\n这两个方法接收4个参数：前一个值，当前值，项的索引，数组对象；\n```javascript\n//利用reduce方法可以执行求数组和\nvar num = [2,3,4,5];\nvar sum = num.reduce(function(prev,cur,index,array){\n\treturn prev + cur;\n})\nconsole.log(sum); //14;\n```\n```javascript\n//利用reduceRight方法可以执行求数组和,方向相反\nvar num = [2,3,4,5];\nvar sum = num.reduceRight(function(prev,cur,index,array){\n\treturn prev + cur;\n})\nconsole.log(sum); //14;\n```\n注：支持IE9+\n## 小结\n","slug":"JS数组常用的方法总结","published":1,"updated":"2019-09-25T15:10:25.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91o90016la2edx78tinv","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数组应该是js中比较常用到的数据类型了，它有着独有的数据特点：</p>\n<ul>\n<li>数组可以保存任意的数据类型 (字符串，数值，对象)</li>\n<li>大小动态调整(随着数据的添加自动增长)</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h2><ul>\n<li>Array构造函数<pre><code class=\"javascript\">var colors = new Array();\n</code></pre>\n</li>\n<li>数组字面量表示<pre><code class=\"javascript\">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]\n</code></pre>\n<h2 id=\"常用的方法\"><a href=\"#常用的方法\" class=\"headerlink\" title=\"常用的方法\"></a>常用的方法</h2></li>\n<li><h2 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h2>接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。<br>```javascript<br>var colors = [];<br>colors.push(“red”,”green”);<br>console.log(colors) //red green 添加两项</li>\n</ul>\n<p>colors.push(“black”);<br>console.log(colors);// red green black 又追加一项</p>\n<pre><code>* ## pop()\n从数组末尾移除最后一项，减少length值,返回移除的项.\n```javascript\nvar colors = [];\ncolors.push(&quot;red&quot;,&quot;green&quot;,&quot;black&quot;);\nvar item = colors.pop();\n\nconsole.log(item); //balck 返回抓取到的值\n\nconsole.log(colors);//red green 原数组值减去\n\nconsole.log(colors.length);//2\n</code></pre><hr>\n<ul>\n<li>shift()<br>移除数组中的第一个项，并返回该项，同时数组长度减1.<br>```javascript<br>var colors = [];<br>colors.push(“red”,”green”,”black”);<br>var item2 = colors.shift();</li>\n</ul>\n<p>console.log(item2); //red 返回抓取到的值</p>\n<p>console.log(colors);// green black原数组值减去</p>\n<p>console.log(colors.length);//2</p>\n<pre><code>* unshift()\n在数组前端添加**任意**个项，并返回新数组长度\n```javascript\nvar colors = [];\ncolors.push(&quot;red&quot;,&quot;green&quot;,&quot;black&quot;);\nvar item3 = colors.unshift(&quot;yellow&quot;,&quot;limegreen&quot;);\n\nconsole.log(item3); //red green 返回抓取到的值\n\nconsole.log(colors);// green black black yellow limegreen原数组值减去\n\nconsole.log(colors.length);//5\n</code></pre><ul>\n<li><h2 id=\"sort-排序方法\"><a href=\"#sort-排序方法\" class=\"headerlink\" title=\"sort() 排序方法\"></a>sort() 排序方法</h2>针对原数组进行的排序，不会生成新的数组<br>默认sort()不带参数是按照数组中的元素换成字符串进行比较(从小到大)<br>ex:<pre><code class=\"javascript\">var arr = [1,21,8,2,7,5];\narr.sort();// 1, 2, 21, 5, 7, 8\n</code></pre>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2>```javascript<br>var arr = [1,21,8,2,7,5];</li>\n</ul>\n<p>//升序<br>arr.sort(function(a,b){<br>    return a-b;<br>})<br>console.log(arr);//1,2,5,7,8,21 真正意义上的从小到大</p>\n<p>//降序<br>arr.sort(function(a,b){<br>    return b-a;<br>})<br>console.log(arr);//21,,8,7,5,2,1 真正意义上的大到小</p>\n<pre><code>## 数组操作方法\n* ## concat(item1,item2)\n基于当前数组中的所有项创建一个新的数组。不操作原数组.\n```javascript\nvar arr1 = [1,2,3,4];\nvar arr2 = [1,7,8];\nvar con = arr1.concat(arr2);\nconsole.log(con);//1,2,3,4,1,7,8\n</code></pre><ul>\n<li><h2 id=\"slice-截取数组\"><a href=\"#slice-截取数组\" class=\"headerlink\" title=\"slice 截取数组\"></a>slice 截取数组</h2>基于当前数组中的一个或者多个项创建一个新的数组，接收一个或者两个参数，即<strong>要返回项的起始和结束位置，如果只有一个参数，返回该参数指定位置开始到数组末尾的所有项，如果两个参数，返回起始和结束位置之间的项（但是不包括结束位置项）</strong>.<br>```javascript<br>var arr1 = [1,2,3,4,5,6,7,8,9];<br>var arr2 = arr1.slice(1);<br>var arr3 = arr1.slice(1,4);</li>\n</ul>\n<p>console.log(arr2);//2,3,4,5,6,7,8,9; 索引从0开始<br>console.log(arr3);//2,3,4；不包括最后一项</p>\n<p>//如果slice 方法中有一个负数，则可以用数组长度加上该数来确定位置</p>\n<pre><code>* ## splice \n主要用途向数组中部插入项：操作的是原数组\n### 删除：\n可以删除任意数量项，只需制定2个参数：要删除的第第一项的位置和删除的项数。例如：splice(0,3);会删除数组中的前3项.\n### 插入：\n可以插入任意数量项，只需制定3个参数：起始位置，0(要删除的项数)，要插入的项。如果要插入多个，可再传第四，第五项...；ex:splice(2,0,&quot;red&quot;,&quot;green&quot;),从2位置开始插入“red”,&quot;green&quot;;\n### 替换：\n可以插入任意数量项，只需制定3个参数：起始位置，0(要删除的项数)，要插入的项(不必与删除数量相同)。ex:splice(2,1,&quot;red&quot;,&quot;green&quot;),从2位置开始插入“red”,&quot;green&quot;;\n```javascript\nvar colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];\nvar removed = colors.splice(0,1);\nconsole.log(colors);//green,blue\nconsole.log(removed);//red 返回的数组中只包含一项\n\nremoved = colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;); //从1位置插入2项\nconsole.log(colors);//green yellow orange blue\nconsole.log(removed);//返回空数组，因为没有删除项，仅仅插入\n\nremoved = colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;);\nconsole.log(colors);//green red purple orange blue\nconsole.log(removed);//ywllow\n</code></pre><h2 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h2><blockquote>\n<p>ES5为数组添加了两个位置方法：indexOf()   LastIndexOf().<br>都接收两个参数 : 要查找的项和(可选的)表示查找起点位置的索引;</p>\n</blockquote>\n<ul>\n<li>indexOf()<br>从数组的开头开始向后查找：<pre><code class=\"javascript\">var numbers = [1,2,3,4,5,6,7];\nconsole.log(numbers.indexOf(3));//返回索引 2\n</code></pre>\n</li>\n<li>lastIndexOf()<br>从数组的开头开始向后查找：<pre><code class=\"javascript\">var numbers = [1,2,3,4,5,6,7];\nconsole.log(numbers.lastIndexOf(3));//返回索引 4\n</code></pre>\n注意：没有找到的情况下返回-1；比较数组每一项时，使用全等操作符；支持IE9+;  <h2 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h2>ES5为数组定义了5个迭代方法：</li>\n<li>every():对数组中的每一项运行给定函数，如果该函数每一项都返回true，则返回true;</li>\n<li>filter():对数组中的每一项运行给定函数，返回该函数会返回true的项，组成的数组；</li>\n<li>forEach():对数组中的每一项给定函数，没有返回值；</li>\n<li>map():对数组中的每一项给定函数;返回每次函数调用的结果组成的数组；</li>\n<li>some():对数组中的每一项给定函数;如果该函数对任意一项返回true，则返回true;</li>\n</ul>\n<p><strong> 以上方法中，最相似的是every some，都是用于查询数组中的项是否满足某个条件，every()，传入每一项都返回true时才为true，some()相反 </strong></p>\n<pre><code class=\"javascript\">var numbers = [1,2,3,4,5,7,8];\nvar everyReault = numbers.every(function(item,index,array){\n    return (item &gt; 2);//\n})\nconsole.log(everyReault);//false 不满足条件\n</code></pre>\n<pre><code class=\"javascript\">var numbers = [1,2,3,4,5,7,8];\nvar everyReault = numbers.some(function(item,index,array){\n    return (item &gt; 2);//\n})\nconsole.log(everyReault);//true 满足条件\n</code></pre>\n<p><strong> filter() 自定函数确定是否在返回的数组中包含一项要返回一个大于2的数组</strong></p>\n<pre><code class=\"javascript\">var num = [1,2,3,4,5,2,1];\nvar filterResult = num.filter(function(item,index,array){\n    return (item &gt;2)\n})\nconsole.log(filterReault); //[3,4,5,]\n</code></pre>\n<p><strong> map()函数也返回一个数组，该数组每一项都会在原始数组的对应项上运行传入函数的结果，例如给数组中每一项*2，返回乘积后的数组</strong></p>\n<pre><code class=\"javascript\">var num = [2,3,4,5,6,7];\nvar mapResult = num.map(function(item,index,array){\n    return (item*2)\n})\nconsole.log(mapResult);  //[4,6,10,12,14]]\n</code></pre>\n<p><strong> forEach() 对数组每一项进行遍历，没有返回值，本质上与使用for 循环迭代数组一样。</strong></p>\n<pre><code class=\"javascript\">var num = [1,2,3,4,5];\nnum.forEach(functin(item,index,array){\n    //执行some code\n})\n</code></pre>\n<p>注：支持IE9+</p>\n<h2 id=\"归并方法\"><a href=\"#归并方法\" class=\"headerlink\" title=\"归并方法\"></a>归并方法</h2><p><strong> ES5新增了两个归并数组的方法:reduce() 和 reduceRight()</strong><br>都会迭代所有数组，然后构建一个返回值，reduce()方法从数组第一项开始，遍历到最后，reduceRight()则相反。都接收两个参数：一个在每一项上调用的函数(可选)作为归并基础的初始值。<br>这两个方法接收4个参数：前一个值，当前值，项的索引，数组对象；</p>\n<pre><code class=\"javascript\">//利用reduce方法可以执行求数组和\nvar num = [2,3,4,5];\nvar sum = num.reduce(function(prev,cur,index,array){\n    return prev + cur;\n})\nconsole.log(sum); //14;\n</code></pre>\n<pre><code class=\"javascript\">//利用reduceRight方法可以执行求数组和,方向相反\nvar num = [2,3,4,5];\nvar sum = num.reduceRight(function(prev,cur,index,array){\n    return prev + cur;\n})\nconsole.log(sum); //14;\n</code></pre>\n<p>注：支持IE9+</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2>","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>数组应该是js中比较常用到的数据类型了，它有着独有的数据特点：</p>\n<ul>\n<li>数组可以保存任意的数据类型 (字符串，数值，对象)</li>\n<li>大小动态调整(随着数据的添加自动增长)</li>\n</ul>","more":"<h2 id=\"创建方式\"><a href=\"#创建方式\" class=\"headerlink\" title=\"创建方式\"></a>创建方式</h2><ul>\n<li>Array构造函数<pre><code class=\"javascript\">var colors = new Array();\n</code></pre>\n</li>\n<li>数组字面量表示<pre><code class=\"javascript\">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]\n</code></pre>\n<h2 id=\"常用的方法\"><a href=\"#常用的方法\" class=\"headerlink\" title=\"常用的方法\"></a>常用的方法</h2></li>\n<li><h2 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push()\"></a>push()</h2>接收任意数量的参数，把他们逐个添加到数组末尾，并返回修改后的数组长度。<br>```javascript<br>var colors = [];<br>colors.push(“red”,”green”);<br>console.log(colors) //red green 添加两项</li>\n</ul>\n<p>colors.push(“black”);<br>console.log(colors);// red green black 又追加一项</p>\n<pre><code>* ## pop()\n从数组末尾移除最后一项，减少length值,返回移除的项.\n```javascript\nvar colors = [];\ncolors.push(&quot;red&quot;,&quot;green&quot;,&quot;black&quot;);\nvar item = colors.pop();\n\nconsole.log(item); //balck 返回抓取到的值\n\nconsole.log(colors);//red green 原数组值减去\n\nconsole.log(colors.length);//2\n</code></pre><hr>\n<ul>\n<li>shift()<br>移除数组中的第一个项，并返回该项，同时数组长度减1.<br>```javascript<br>var colors = [];<br>colors.push(“red”,”green”,”black”);<br>var item2 = colors.shift();</li>\n</ul>\n<p>console.log(item2); //red 返回抓取到的值</p>\n<p>console.log(colors);// green black原数组值减去</p>\n<p>console.log(colors.length);//2</p>\n<pre><code>* unshift()\n在数组前端添加**任意**个项，并返回新数组长度\n```javascript\nvar colors = [];\ncolors.push(&quot;red&quot;,&quot;green&quot;,&quot;black&quot;);\nvar item3 = colors.unshift(&quot;yellow&quot;,&quot;limegreen&quot;);\n\nconsole.log(item3); //red green 返回抓取到的值\n\nconsole.log(colors);// green black black yellow limegreen原数组值减去\n\nconsole.log(colors.length);//5\n</code></pre><ul>\n<li><h2 id=\"sort-排序方法\"><a href=\"#sort-排序方法\" class=\"headerlink\" title=\"sort() 排序方法\"></a>sort() 排序方法</h2>针对原数组进行的排序，不会生成新的数组<br>默认sort()不带参数是按照数组中的元素换成字符串进行比较(从小到大)<br>ex:<pre><code class=\"javascript\">var arr = [1,21,8,2,7,5];\narr.sort();// 1, 2, 21, 5, 7, 8\n</code></pre>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2>```javascript<br>var arr = [1,21,8,2,7,5];</li>\n</ul>\n<p>//升序<br>arr.sort(function(a,b){<br>    return a-b;<br>})<br>console.log(arr);//1,2,5,7,8,21 真正意义上的从小到大</p>\n<p>//降序<br>arr.sort(function(a,b){<br>    return b-a;<br>})<br>console.log(arr);//21,,8,7,5,2,1 真正意义上的大到小</p>\n<pre><code>## 数组操作方法\n* ## concat(item1,item2)\n基于当前数组中的所有项创建一个新的数组。不操作原数组.\n```javascript\nvar arr1 = [1,2,3,4];\nvar arr2 = [1,7,8];\nvar con = arr1.concat(arr2);\nconsole.log(con);//1,2,3,4,1,7,8\n</code></pre><ul>\n<li><h2 id=\"slice-截取数组\"><a href=\"#slice-截取数组\" class=\"headerlink\" title=\"slice 截取数组\"></a>slice 截取数组</h2>基于当前数组中的一个或者多个项创建一个新的数组，接收一个或者两个参数，即<strong>要返回项的起始和结束位置，如果只有一个参数，返回该参数指定位置开始到数组末尾的所有项，如果两个参数，返回起始和结束位置之间的项（但是不包括结束位置项）</strong>.<br>```javascript<br>var arr1 = [1,2,3,4,5,6,7,8,9];<br>var arr2 = arr1.slice(1);<br>var arr3 = arr1.slice(1,4);</li>\n</ul>\n<p>console.log(arr2);//2,3,4,5,6,7,8,9; 索引从0开始<br>console.log(arr3);//2,3,4；不包括最后一项</p>\n<p>//如果slice 方法中有一个负数，则可以用数组长度加上该数来确定位置</p>\n<pre><code>* ## splice \n主要用途向数组中部插入项：操作的是原数组\n### 删除：\n可以删除任意数量项，只需制定2个参数：要删除的第第一项的位置和删除的项数。例如：splice(0,3);会删除数组中的前3项.\n### 插入：\n可以插入任意数量项，只需制定3个参数：起始位置，0(要删除的项数)，要插入的项。如果要插入多个，可再传第四，第五项...；ex:splice(2,0,&quot;red&quot;,&quot;green&quot;),从2位置开始插入“red”,&quot;green&quot;;\n### 替换：\n可以插入任意数量项，只需制定3个参数：起始位置，0(要删除的项数)，要插入的项(不必与删除数量相同)。ex:splice(2,1,&quot;red&quot;,&quot;green&quot;),从2位置开始插入“red”,&quot;green&quot;;\n```javascript\nvar colors = [&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];\nvar removed = colors.splice(0,1);\nconsole.log(colors);//green,blue\nconsole.log(removed);//red 返回的数组中只包含一项\n\nremoved = colors.splice(1,0,&quot;yellow&quot;,&quot;orange&quot;); //从1位置插入2项\nconsole.log(colors);//green yellow orange blue\nconsole.log(removed);//返回空数组，因为没有删除项，仅仅插入\n\nremoved = colors.splice(1,1,&quot;red&quot;,&quot;purple&quot;);\nconsole.log(colors);//green red purple orange blue\nconsole.log(removed);//ywllow\n</code></pre><h2 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h2><blockquote>\n<p>ES5为数组添加了两个位置方法：indexOf()   LastIndexOf().<br>都接收两个参数 : 要查找的项和(可选的)表示查找起点位置的索引;</p>\n</blockquote>\n<ul>\n<li>indexOf()<br>从数组的开头开始向后查找：<pre><code class=\"javascript\">var numbers = [1,2,3,4,5,6,7];\nconsole.log(numbers.indexOf(3));//返回索引 2\n</code></pre>\n</li>\n<li>lastIndexOf()<br>从数组的开头开始向后查找：<pre><code class=\"javascript\">var numbers = [1,2,3,4,5,6,7];\nconsole.log(numbers.lastIndexOf(3));//返回索引 4\n</code></pre>\n注意：没有找到的情况下返回-1；比较数组每一项时，使用全等操作符；支持IE9+;  <h2 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h2>ES5为数组定义了5个迭代方法：</li>\n<li>every():对数组中的每一项运行给定函数，如果该函数每一项都返回true，则返回true;</li>\n<li>filter():对数组中的每一项运行给定函数，返回该函数会返回true的项，组成的数组；</li>\n<li>forEach():对数组中的每一项给定函数，没有返回值；</li>\n<li>map():对数组中的每一项给定函数;返回每次函数调用的结果组成的数组；</li>\n<li>some():对数组中的每一项给定函数;如果该函数对任意一项返回true，则返回true;</li>\n</ul>\n<p><strong> 以上方法中，最相似的是every some，都是用于查询数组中的项是否满足某个条件，every()，传入每一项都返回true时才为true，some()相反 </strong></p>\n<pre><code class=\"javascript\">var numbers = [1,2,3,4,5,7,8];\nvar everyReault = numbers.every(function(item,index,array){\n    return (item &gt; 2);//\n})\nconsole.log(everyReault);//false 不满足条件\n</code></pre>\n<pre><code class=\"javascript\">var numbers = [1,2,3,4,5,7,8];\nvar everyReault = numbers.some(function(item,index,array){\n    return (item &gt; 2);//\n})\nconsole.log(everyReault);//true 满足条件\n</code></pre>\n<p><strong> filter() 自定函数确定是否在返回的数组中包含一项要返回一个大于2的数组</strong></p>\n<pre><code class=\"javascript\">var num = [1,2,3,4,5,2,1];\nvar filterResult = num.filter(function(item,index,array){\n    return (item &gt;2)\n})\nconsole.log(filterReault); //[3,4,5,]\n</code></pre>\n<p><strong> map()函数也返回一个数组，该数组每一项都会在原始数组的对应项上运行传入函数的结果，例如给数组中每一项*2，返回乘积后的数组</strong></p>\n<pre><code class=\"javascript\">var num = [2,3,4,5,6,7];\nvar mapResult = num.map(function(item,index,array){\n    return (item*2)\n})\nconsole.log(mapResult);  //[4,6,10,12,14]]\n</code></pre>\n<p><strong> forEach() 对数组每一项进行遍历，没有返回值，本质上与使用for 循环迭代数组一样。</strong></p>\n<pre><code class=\"javascript\">var num = [1,2,3,4,5];\nnum.forEach(functin(item,index,array){\n    //执行some code\n})\n</code></pre>\n<p>注：支持IE9+</p>\n<h2 id=\"归并方法\"><a href=\"#归并方法\" class=\"headerlink\" title=\"归并方法\"></a>归并方法</h2><p><strong> ES5新增了两个归并数组的方法:reduce() 和 reduceRight()</strong><br>都会迭代所有数组，然后构建一个返回值，reduce()方法从数组第一项开始，遍历到最后，reduceRight()则相反。都接收两个参数：一个在每一项上调用的函数(可选)作为归并基础的初始值。<br>这两个方法接收4个参数：前一个值，当前值，项的索引，数组对象；</p>\n<pre><code class=\"javascript\">//利用reduce方法可以执行求数组和\nvar num = [2,3,4,5];\nvar sum = num.reduce(function(prev,cur,index,array){\n    return prev + cur;\n})\nconsole.log(sum); //14;\n</code></pre>\n<pre><code class=\"javascript\">//利用reduceRight方法可以执行求数组和,方向相反\nvar num = [2,3,4,5];\nvar sum = num.reduceRight(function(prev,cur,index,array){\n    return prev + cur;\n})\nconsole.log(sum); //14;\n</code></pre>\n<p>注：支持IE9+</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2>"},{"title":"JS生成随机的由字母数字组合的字符串","date":"2016-12-12T14:05:29.000Z","_content":"## 前言\n网上偶然看到一个问题，需要生成3~32位长度的字母数字随机组合字符串，另一个是生成43位随机字符串.\n代码：\n```javascript\n/*\n** getWorld 产生任意长度随机字母数字组合\n** getFlag 是否任意长度 min 任意最小长度（固定位数） max-任意最大长度\n*/\n\nfunction getWord(getFlag,min,max){\n\tvar str = \"\";\n\tvar range = min;\n\tvar arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n\t\t\t\t'9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\n\t\t\t\t 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\n\t\t\t\t'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A',\n\t\t\t\t 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\n\t\t\t\t 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\n\t\t\t\t 'V', 'W', 'X', 'Y', 'Z'];\n\tif(getFlag){\n\t\trange = parseInt(Math.random() * (max - min)) + min;\n\t}\n\tfor(var i=0;i<range;i++){\n\t\tvar index = parseInt(Math.random() * (arr.length - 1));\n\t\tstr += arr[index];\n\t}\n\treturn str;\n}\n```\n## 使用方法：\n* 生成3~32位随机数：getWord(true,3,32)\n* 生成43位随机串: getWord(false,43);\n","source":"_posts/JS生成随机的由字母数字组合的字符串.md","raw":"---\ntitle: JS生成随机的由字母数字组合的字符串\ndate: 2016-12-12 22:05:29\ntags: [javascript]\ncategories: Javascript\n---\n## 前言\n网上偶然看到一个问题，需要生成3~32位长度的字母数字随机组合字符串，另一个是生成43位随机字符串.\n代码：\n```javascript\n/*\n** getWorld 产生任意长度随机字母数字组合\n** getFlag 是否任意长度 min 任意最小长度（固定位数） max-任意最大长度\n*/\n\nfunction getWord(getFlag,min,max){\n\tvar str = \"\";\n\tvar range = min;\n\tvar arr = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n\t\t\t\t'9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',\n\t\t\t\t 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\n\t\t\t\t'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A',\n\t\t\t\t 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\n\t\t\t\t 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\n\t\t\t\t 'V', 'W', 'X', 'Y', 'Z'];\n\tif(getFlag){\n\t\trange = parseInt(Math.random() * (max - min)) + min;\n\t}\n\tfor(var i=0;i<range;i++){\n\t\tvar index = parseInt(Math.random() * (arr.length - 1));\n\t\tstr += arr[index];\n\t}\n\treturn str;\n}\n```\n## 使用方法：\n* 生成3~32位随机数：getWord(true,3,32)\n* 生成43位随机串: getWord(false,43);\n","slug":"JS生成随机的由字母数字组合的字符串","published":1,"updated":"2019-09-25T15:10:25.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91oa001ala2e9m2tt58d","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>网上偶然看到一个问题，需要生成3~32位长度的字母数字随机组合字符串，另一个是生成43位随机字符串.<br>代码：</p>\n<pre><code class=\"javascript\">/*\n** getWorld 产生任意长度随机字母数字组合\n** getFlag 是否任意长度 min 任意最小长度（固定位数） max-任意最大长度\n*/\n\nfunction getWord(getFlag,min,max){\n    var str = &quot;&quot;;\n    var range = min;\n    var arr = [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,\n                &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;,\n                 &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;,\n                &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;A&#39;,\n                 &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;,\n                 &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;,\n                 &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;];\n    if(getFlag){\n        range = parseInt(Math.random() * (max - min)) + min;\n    }\n    for(var i=0;i&lt;range;i++){\n        var index = parseInt(Math.random() * (arr.length - 1));\n        str += arr[index];\n    }\n    return str;\n}\n</code></pre>\n<h2 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h2><ul>\n<li>生成3~32位随机数：getWord(true,3,32)</li>\n<li>生成43位随机串: getWord(false,43);</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>网上偶然看到一个问题，需要生成3~32位长度的字母数字随机组合字符串，另一个是生成43位随机字符串.<br>代码：</p>\n<pre><code class=\"javascript\">/*\n** getWorld 产生任意长度随机字母数字组合\n** getFlag 是否任意长度 min 任意最小长度（固定位数） max-任意最大长度\n*/\n\nfunction getWord(getFlag,min,max){\n    var str = &quot;&quot;;\n    var range = min;\n    var arr = [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,\n                &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;,\n                 &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;,\n                &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39;, &#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;A&#39;,\n                 &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;,\n                 &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;, &#39;P&#39;, &#39;Q&#39;, &#39;R&#39;, &#39;S&#39;, &#39;T&#39;, &#39;U&#39;,\n                 &#39;V&#39;, &#39;W&#39;, &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;];\n    if(getFlag){\n        range = parseInt(Math.random() * (max - min)) + min;\n    }\n    for(var i=0;i&lt;range;i++){\n        var index = parseInt(Math.random() * (arr.length - 1));\n        str += arr[index];\n    }\n    return str;\n}\n</code></pre>\n<h2 id=\"使用方法：\"><a href=\"#使用方法：\" class=\"headerlink\" title=\"使用方法：\"></a>使用方法：</h2><ul>\n<li>生成3~32位随机数：getWord(true,3,32)</li>\n<li>生成43位随机串: getWord(false,43);</li>\n</ul>\n"},{"title":"Javascript函数","date":"2016-12-12T12:18:51.000Z","_content":"## 概念\n函数是一块Javascript代码，被定义一次，但可执行和调用多次。  \nJS中的函数也是对象，所以JS函数可以像其他对象那样操作和传递。  \n所以我们也常叫JS中的函数为函数对象。  \n例如：  \n```javascript\nfunction add(x,y){\n\tif(typeof x === 'number' && typeof y === 'number'){\n\t\treturn x + y;\n\t}else{\n\t\treturn 0;\n\t}\n}\nadd(3,4); // 7\n```\n<!-- more -->\n函数一般由3部分组成：  \n* 函数名\n* 参数列表\n* 函数体  \n\n## 调用方式\n* 直接调用\n\n```javascript\nadd();\n```\n* 对象方法\n\n```javascript\no.add();\n```\n* 构造器  \n\n```javascript\nnew Foo();\n```\n* call/applay/bind  \n\n```javascript\nfun.call(o);\n```\n## 函数声明与函数表达式\n\n### 函数声明\n就是对函数进行普通的声明  \n```javascript\nfunction add(a,b){\n\treturn a + b;\n}\n```\n### 函数表达式\n* 将函数赋值给变量\n\n```javascript\nvar add = function(a,b){\n\t// some code...\n}\n```\n* 立即执行函数\n把匿名函数用括号包裹起来，在直接调用。\n  \n```javascript\n(function(){\n\t// some code..\n})()\n```\n* 函数对象作为返回值\n\n```javascript\nreturn function(){\n\t// some code...\n}\n```\n* 命名式函数表达式\n\n```javascript\nvar add = function foo(a,b){\n\t//some code...\n}\n```\n这种表达式还真的少见，怎么用？该用哪个名字呢？  \n做一个测试：  \n```javascript\nvar fun = function funcc() {};\nconsole.log(fun === funcc);\n\n//在IE6~8 得到false  \n// 在IE9+,以及现代浏览器中 Uncaught RefererceReeor :funccc is not defined\n```\n那么命名函数表达式有什么作用呢？\n* 一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。  \n* 或者在递归时，使用名字调用自己。\n\n但是这两种用法都很不常见。了解即可。  \n\n## 变量 & 函数的声明前置\n例1，函数声明：\n```javascript\nvar num = add(3,4);\nconsole.log(num);\n\nfunction add(a,b){\n\treturn a＋ｂ；\n}\n```\n例２，函数表达式：\n```javascript\nvar num = add(2,4);\n\nconsole.log(num);\n\nvar  add = function(a,b){\n\treturn a+b;\n}\n```\n案例1中得到的结果是7，而案例2中是：**Uncaugh TypeError :add is not a function.**  \n因为函数和变量在声明的时候，会被前置到当前作用域的顶端。1中将函数声明*function add(a,b)*前置到作用域前端，2将声明**var add**前置到其作用域的前端了，并没有赋值。**赋值的过程是在函数执行到响应位置的时候才进行的。**\n## Function 构造器\n除了函数声明，函数表达式。还有一种创建函数对象的方式，是使用函数构造器。\n```javascript\nvar foo = new Function('a','b','console.log(a+b);');\nfoo(3,4);//7\n\nvar foo2 = Function('a','b','console.log(a+b);');\nfoo2(3,4);//7\n```\nFunction 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。\n\n还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。\n## 函数属性 && argumnets\n### 函数属性 &arguments\n```javascript\nfunction foo(a,b,c){\n\targuments.length; //2\n\targuments[0]; //1\n\targuments[0] = 10;\n\ta; //change to 10\n\t\n\targuments[2] = 100;\n\tc; //still undefined\n\targuments.callee === foo; //true\n}\n\nfoo(4,5);\nfoo.length;//3\nfoo.name;//'foo'\n```\n* **foo.name 函数名**\n* **foo.length 形参个数**\n* **arguments.length 实参个数**\n\n未传参数时，arguments[i]相应位置仍然是undefined。  \n严格模式下，代码中的改变实参无效，a仍未1.同时callee属性失效.  \n* 关于**callee**\n\ncallee 属性的初始值就是正被执行function对象。  \ncallee 属性是arguments对象的一个成员，他表示对函数对象本身的引用，\n这有利于匿名函数的递归或者保证函数的封装性，例如用下面示例的递归求和。而该函数仅当相关函数正在执行时才可用。需要注意callee拥有length属相，这个属相有事用于验证还是可以的。  \narguments.length是实参长度。arguments.callee.length是形参长度，由此可以判断调用时形参长度是否和实参长度一致。\n```javascript\nfunction sum(num){\n\tif(num <=1){\n\t\treturn 1;\n\t}else{\n\t\treturn num + arguments.callee(num -1);\n\t}\n}\n\nsum(100); //5050 很熟悉的结果吧\n```\n* 参考：\n>高程3","source":"_posts/Javascript函数.md","raw":"---\ntitle: Javascript函数\ndate: 2016-12-12 20:18:51\ntags: [javascript]\ncategories: Javascript\n---\n## 概念\n函数是一块Javascript代码，被定义一次，但可执行和调用多次。  \nJS中的函数也是对象，所以JS函数可以像其他对象那样操作和传递。  \n所以我们也常叫JS中的函数为函数对象。  \n例如：  \n```javascript\nfunction add(x,y){\n\tif(typeof x === 'number' && typeof y === 'number'){\n\t\treturn x + y;\n\t}else{\n\t\treturn 0;\n\t}\n}\nadd(3,4); // 7\n```\n<!-- more -->\n函数一般由3部分组成：  \n* 函数名\n* 参数列表\n* 函数体  \n\n## 调用方式\n* 直接调用\n\n```javascript\nadd();\n```\n* 对象方法\n\n```javascript\no.add();\n```\n* 构造器  \n\n```javascript\nnew Foo();\n```\n* call/applay/bind  \n\n```javascript\nfun.call(o);\n```\n## 函数声明与函数表达式\n\n### 函数声明\n就是对函数进行普通的声明  \n```javascript\nfunction add(a,b){\n\treturn a + b;\n}\n```\n### 函数表达式\n* 将函数赋值给变量\n\n```javascript\nvar add = function(a,b){\n\t// some code...\n}\n```\n* 立即执行函数\n把匿名函数用括号包裹起来，在直接调用。\n  \n```javascript\n(function(){\n\t// some code..\n})()\n```\n* 函数对象作为返回值\n\n```javascript\nreturn function(){\n\t// some code...\n}\n```\n* 命名式函数表达式\n\n```javascript\nvar add = function foo(a,b){\n\t//some code...\n}\n```\n这种表达式还真的少见，怎么用？该用哪个名字呢？  \n做一个测试：  \n```javascript\nvar fun = function funcc() {};\nconsole.log(fun === funcc);\n\n//在IE6~8 得到false  \n// 在IE9+,以及现代浏览器中 Uncaught RefererceReeor :funccc is not defined\n```\n那么命名函数表达式有什么作用呢？\n* 一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。  \n* 或者在递归时，使用名字调用自己。\n\n但是这两种用法都很不常见。了解即可。  \n\n## 变量 & 函数的声明前置\n例1，函数声明：\n```javascript\nvar num = add(3,4);\nconsole.log(num);\n\nfunction add(a,b){\n\treturn a＋ｂ；\n}\n```\n例２，函数表达式：\n```javascript\nvar num = add(2,4);\n\nconsole.log(num);\n\nvar  add = function(a,b){\n\treturn a+b;\n}\n```\n案例1中得到的结果是7，而案例2中是：**Uncaugh TypeError :add is not a function.**  \n因为函数和变量在声明的时候，会被前置到当前作用域的顶端。1中将函数声明*function add(a,b)*前置到作用域前端，2将声明**var add**前置到其作用域的前端了，并没有赋值。**赋值的过程是在函数执行到响应位置的时候才进行的。**\n## Function 构造器\n除了函数声明，函数表达式。还有一种创建函数对象的方式，是使用函数构造器。\n```javascript\nvar foo = new Function('a','b','console.log(a+b);');\nfoo(3,4);//7\n\nvar foo2 = Function('a','b','console.log(a+b);');\nfoo2(3,4);//7\n```\nFunction 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。\n\n还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。\n## 函数属性 && argumnets\n### 函数属性 &arguments\n```javascript\nfunction foo(a,b,c){\n\targuments.length; //2\n\targuments[0]; //1\n\targuments[0] = 10;\n\ta; //change to 10\n\t\n\targuments[2] = 100;\n\tc; //still undefined\n\targuments.callee === foo; //true\n}\n\nfoo(4,5);\nfoo.length;//3\nfoo.name;//'foo'\n```\n* **foo.name 函数名**\n* **foo.length 形参个数**\n* **arguments.length 实参个数**\n\n未传参数时，arguments[i]相应位置仍然是undefined。  \n严格模式下，代码中的改变实参无效，a仍未1.同时callee属性失效.  \n* 关于**callee**\n\ncallee 属性的初始值就是正被执行function对象。  \ncallee 属性是arguments对象的一个成员，他表示对函数对象本身的引用，\n这有利于匿名函数的递归或者保证函数的封装性，例如用下面示例的递归求和。而该函数仅当相关函数正在执行时才可用。需要注意callee拥有length属相，这个属相有事用于验证还是可以的。  \narguments.length是实参长度。arguments.callee.length是形参长度，由此可以判断调用时形参长度是否和实参长度一致。\n```javascript\nfunction sum(num){\n\tif(num <=1){\n\t\treturn 1;\n\t}else{\n\t\treturn num + arguments.callee(num -1);\n\t}\n}\n\nsum(100); //5050 很熟悉的结果吧\n```\n* 参考：\n>高程3","slug":"Javascript函数","published":1,"updated":"2019-09-25T15:10:25.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ob001dla2e4urxy2hj","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>函数是一块Javascript代码，被定义一次，但可执行和调用多次。<br>JS中的函数也是对象，所以JS函数可以像其他对象那样操作和传递。<br>所以我们也常叫JS中的函数为函数对象。<br>例如：  </p>\n<pre><code class=\"javascript\">function add(x,y){\n    if(typeof x === &#39;number&#39; &amp;&amp; typeof y === &#39;number&#39;){\n        return x + y;\n    }else{\n        return 0;\n    }\n}\nadd(3,4); // 7\n</code></pre>\n<a id=\"more\"></a>\n<p>函数一般由3部分组成：  </p>\n<ul>\n<li>函数名</li>\n<li>参数列表</li>\n<li>函数体  </li>\n</ul>\n<h2 id=\"调用方式\"><a href=\"#调用方式\" class=\"headerlink\" title=\"调用方式\"></a>调用方式</h2><ul>\n<li>直接调用</li>\n</ul>\n<pre><code class=\"javascript\">add();\n</code></pre>\n<ul>\n<li>对象方法</li>\n</ul>\n<pre><code class=\"javascript\">o.add();\n</code></pre>\n<ul>\n<li>构造器  </li>\n</ul>\n<pre><code class=\"javascript\">new Foo();\n</code></pre>\n<ul>\n<li>call/applay/bind  </li>\n</ul>\n<pre><code class=\"javascript\">fun.call(o);\n</code></pre>\n<h2 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h2><h3 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h3><p>就是对函数进行普通的声明  </p>\n<pre><code class=\"javascript\">function add(a,b){\n    return a + b;\n}\n</code></pre>\n<h3 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h3><ul>\n<li>将函数赋值给变量</li>\n</ul>\n<pre><code class=\"javascript\">var add = function(a,b){\n    // some code...\n}\n</code></pre>\n<ul>\n<li>立即执行函数<br>把匿名函数用括号包裹起来，在直接调用。</li>\n</ul>\n<pre><code class=\"javascript\">(function(){\n    // some code..\n})()\n</code></pre>\n<ul>\n<li>函数对象作为返回值</li>\n</ul>\n<pre><code class=\"javascript\">return function(){\n    // some code...\n}\n</code></pre>\n<ul>\n<li>命名式函数表达式</li>\n</ul>\n<pre><code class=\"javascript\">var add = function foo(a,b){\n    //some code...\n}\n</code></pre>\n<p>这种表达式还真的少见，怎么用？该用哪个名字呢？<br>做一个测试：  </p>\n<pre><code class=\"javascript\">var fun = function funcc() {};\nconsole.log(fun === funcc);\n\n//在IE6~8 得到false  \n// 在IE9+,以及现代浏览器中 Uncaught RefererceReeor :funccc is not defined\n</code></pre>\n<p>那么命名函数表达式有什么作用呢？</p>\n<ul>\n<li>一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。  </li>\n<li>或者在递归时，使用名字调用自己。</li>\n</ul>\n<p>但是这两种用法都很不常见。了解即可。  </p>\n<h2 id=\"变量-amp-函数的声明前置\"><a href=\"#变量-amp-函数的声明前置\" class=\"headerlink\" title=\"变量 &amp; 函数的声明前置\"></a>变量 &amp; 函数的声明前置</h2><p>例1，函数声明：</p>\n<pre><code class=\"javascript\">var num = add(3,4);\nconsole.log(num);\n\nfunction add(a,b){\n    return a＋ｂ；\n}\n</code></pre>\n<p>例２，函数表达式：</p>\n<pre><code class=\"javascript\">var num = add(2,4);\n\nconsole.log(num);\n\nvar  add = function(a,b){\n    return a+b;\n}\n</code></pre>\n<p>案例1中得到的结果是7，而案例2中是：<strong>Uncaugh TypeError :add is not a function.</strong><br>因为函数和变量在声明的时候，会被前置到当前作用域的顶端。1中将函数声明<em>function add(a,b)</em>前置到作用域前端，2将声明<strong>var add</strong>前置到其作用域的前端了，并没有赋值。<strong>赋值的过程是在函数执行到响应位置的时候才进行的。</strong></p>\n<h2 id=\"Function-构造器\"><a href=\"#Function-构造器\" class=\"headerlink\" title=\"Function 构造器\"></a>Function 构造器</h2><p>除了函数声明，函数表达式。还有一种创建函数对象的方式，是使用函数构造器。</p>\n<pre><code class=\"javascript\">var foo = new Function(&#39;a&#39;,&#39;b&#39;,&#39;console.log(a+b);&#39;);\nfoo(3,4);//7\n\nvar foo2 = Function(&#39;a&#39;,&#39;b&#39;,&#39;console.log(a+b);&#39;);\nfoo2(3,4);//7\n</code></pre>\n<p>Function 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。</p>\n<p>还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。</p>\n<h2 id=\"函数属性-amp-amp-argumnets\"><a href=\"#函数属性-amp-amp-argumnets\" class=\"headerlink\" title=\"函数属性 &amp;&amp; argumnets\"></a>函数属性 &amp;&amp; argumnets</h2><h3 id=\"函数属性-amp-arguments\"><a href=\"#函数属性-amp-arguments\" class=\"headerlink\" title=\"函数属性 &amp;arguments\"></a>函数属性 &amp;arguments</h3><pre><code class=\"javascript\">function foo(a,b,c){\n    arguments.length; //2\n    arguments[0]; //1\n    arguments[0] = 10;\n    a; //change to 10\n\n    arguments[2] = 100;\n    c; //still undefined\n    arguments.callee === foo; //true\n}\n\nfoo(4,5);\nfoo.length;//3\nfoo.name;//&#39;foo&#39;\n</code></pre>\n<ul>\n<li><strong>foo.name 函数名</strong></li>\n<li><strong>foo.length 形参个数</strong></li>\n<li><strong>arguments.length 实参个数</strong></li>\n</ul>\n<p>未传参数时，arguments[i]相应位置仍然是undefined。<br>严格模式下，代码中的改变实参无效，a仍未1.同时callee属性失效.  </p>\n<ul>\n<li>关于<strong>callee</strong></li>\n</ul>\n<p>callee 属性的初始值就是正被执行function对象。<br>callee 属性是arguments对象的一个成员，他表示对函数对象本身的引用，<br>这有利于匿名函数的递归或者保证函数的封装性，例如用下面示例的递归求和。而该函数仅当相关函数正在执行时才可用。需要注意callee拥有length属相，这个属相有事用于验证还是可以的。<br>arguments.length是实参长度。arguments.callee.length是形参长度，由此可以判断调用时形参长度是否和实参长度一致。</p>\n<pre><code class=\"javascript\">function sum(num){\n    if(num &lt;=1){\n        return 1;\n    }else{\n        return num + arguments.callee(num -1);\n    }\n}\n\nsum(100); //5050 很熟悉的结果吧\n</code></pre>\n<ul>\n<li>参考：<blockquote>\n<p>高程3</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>函数是一块Javascript代码，被定义一次，但可执行和调用多次。<br>JS中的函数也是对象，所以JS函数可以像其他对象那样操作和传递。<br>所以我们也常叫JS中的函数为函数对象。<br>例如：  </p>\n<pre><code class=\"javascript\">function add(x,y){\n    if(typeof x === &#39;number&#39; &amp;&amp; typeof y === &#39;number&#39;){\n        return x + y;\n    }else{\n        return 0;\n    }\n}\nadd(3,4); // 7\n</code></pre>","more":"<p>函数一般由3部分组成：  </p>\n<ul>\n<li>函数名</li>\n<li>参数列表</li>\n<li>函数体  </li>\n</ul>\n<h2 id=\"调用方式\"><a href=\"#调用方式\" class=\"headerlink\" title=\"调用方式\"></a>调用方式</h2><ul>\n<li>直接调用</li>\n</ul>\n<pre><code class=\"javascript\">add();\n</code></pre>\n<ul>\n<li>对象方法</li>\n</ul>\n<pre><code class=\"javascript\">o.add();\n</code></pre>\n<ul>\n<li>构造器  </li>\n</ul>\n<pre><code class=\"javascript\">new Foo();\n</code></pre>\n<ul>\n<li>call/applay/bind  </li>\n</ul>\n<pre><code class=\"javascript\">fun.call(o);\n</code></pre>\n<h2 id=\"函数声明与函数表达式\"><a href=\"#函数声明与函数表达式\" class=\"headerlink\" title=\"函数声明与函数表达式\"></a>函数声明与函数表达式</h2><h3 id=\"函数声明\"><a href=\"#函数声明\" class=\"headerlink\" title=\"函数声明\"></a>函数声明</h3><p>就是对函数进行普通的声明  </p>\n<pre><code class=\"javascript\">function add(a,b){\n    return a + b;\n}\n</code></pre>\n<h3 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h3><ul>\n<li>将函数赋值给变量</li>\n</ul>\n<pre><code class=\"javascript\">var add = function(a,b){\n    // some code...\n}\n</code></pre>\n<ul>\n<li>立即执行函数<br>把匿名函数用括号包裹起来，在直接调用。</li>\n</ul>\n<pre><code class=\"javascript\">(function(){\n    // some code..\n})()\n</code></pre>\n<ul>\n<li>函数对象作为返回值</li>\n</ul>\n<pre><code class=\"javascript\">return function(){\n    // some code...\n}\n</code></pre>\n<ul>\n<li>命名式函数表达式</li>\n</ul>\n<pre><code class=\"javascript\">var add = function foo(a,b){\n    //some code...\n}\n</code></pre>\n<p>这种表达式还真的少见，怎么用？该用哪个名字呢？<br>做一个测试：  </p>\n<pre><code class=\"javascript\">var fun = function funcc() {};\nconsole.log(fun === funcc);\n\n//在IE6~8 得到false  \n// 在IE9+,以及现代浏览器中 Uncaught RefererceReeor :funccc is not defined\n</code></pre>\n<p>那么命名函数表达式有什么作用呢？</p>\n<ul>\n<li>一般用于调试方便，如果使用匿名函数，执行的时候看不到函数名，命名函数表达式是可以看到函数名的。  </li>\n<li>或者在递归时，使用名字调用自己。</li>\n</ul>\n<p>但是这两种用法都很不常见。了解即可。  </p>\n<h2 id=\"变量-amp-函数的声明前置\"><a href=\"#变量-amp-函数的声明前置\" class=\"headerlink\" title=\"变量 &amp; 函数的声明前置\"></a>变量 &amp; 函数的声明前置</h2><p>例1，函数声明：</p>\n<pre><code class=\"javascript\">var num = add(3,4);\nconsole.log(num);\n\nfunction add(a,b){\n    return a＋ｂ；\n}\n</code></pre>\n<p>例２，函数表达式：</p>\n<pre><code class=\"javascript\">var num = add(2,4);\n\nconsole.log(num);\n\nvar  add = function(a,b){\n    return a+b;\n}\n</code></pre>\n<p>案例1中得到的结果是7，而案例2中是：<strong>Uncaugh TypeError :add is not a function.</strong><br>因为函数和变量在声明的时候，会被前置到当前作用域的顶端。1中将函数声明<em>function add(a,b)</em>前置到作用域前端，2将声明<strong>var add</strong>前置到其作用域的前端了，并没有赋值。<strong>赋值的过程是在函数执行到响应位置的时候才进行的。</strong></p>\n<h2 id=\"Function-构造器\"><a href=\"#Function-构造器\" class=\"headerlink\" title=\"Function 构造器\"></a>Function 构造器</h2><p>除了函数声明，函数表达式。还有一种创建函数对象的方式，是使用函数构造器。</p>\n<pre><code class=\"javascript\">var foo = new Function(&#39;a&#39;,&#39;b&#39;,&#39;console.log(a+b);&#39;);\nfoo(3,4);//7\n\nvar foo2 = Function(&#39;a&#39;,&#39;b&#39;,&#39;console.log(a+b);&#39;);\nfoo2(3,4);//7\n</code></pre>\n<p>Function 中前面的参数为后面函数体的形参，最后一个参数为函数体。可以看到传入的都是字符串，这样的创建函数对象的方法是不安全的。</p>\n<p>还有一点，Function 构造器的得到的函数对象，拿不到外层函数的变量，但是可以拿到全局变量。它的作用域与众不同，这也是很少使用的原因之一。</p>\n<h2 id=\"函数属性-amp-amp-argumnets\"><a href=\"#函数属性-amp-amp-argumnets\" class=\"headerlink\" title=\"函数属性 &amp;&amp; argumnets\"></a>函数属性 &amp;&amp; argumnets</h2><h3 id=\"函数属性-amp-arguments\"><a href=\"#函数属性-amp-arguments\" class=\"headerlink\" title=\"函数属性 &amp;arguments\"></a>函数属性 &amp;arguments</h3><pre><code class=\"javascript\">function foo(a,b,c){\n    arguments.length; //2\n    arguments[0]; //1\n    arguments[0] = 10;\n    a; //change to 10\n\n    arguments[2] = 100;\n    c; //still undefined\n    arguments.callee === foo; //true\n}\n\nfoo(4,5);\nfoo.length;//3\nfoo.name;//&#39;foo&#39;\n</code></pre>\n<ul>\n<li><strong>foo.name 函数名</strong></li>\n<li><strong>foo.length 形参个数</strong></li>\n<li><strong>arguments.length 实参个数</strong></li>\n</ul>\n<p>未传参数时，arguments[i]相应位置仍然是undefined。<br>严格模式下，代码中的改变实参无效，a仍未1.同时callee属性失效.  </p>\n<ul>\n<li>关于<strong>callee</strong></li>\n</ul>\n<p>callee 属性的初始值就是正被执行function对象。<br>callee 属性是arguments对象的一个成员，他表示对函数对象本身的引用，<br>这有利于匿名函数的递归或者保证函数的封装性，例如用下面示例的递归求和。而该函数仅当相关函数正在执行时才可用。需要注意callee拥有length属相，这个属相有事用于验证还是可以的。<br>arguments.length是实参长度。arguments.callee.length是形参长度，由此可以判断调用时形参长度是否和实参长度一致。</p>\n<pre><code class=\"javascript\">function sum(num){\n    if(num &lt;=1){\n        return 1;\n    }else{\n        return num + arguments.callee(num -1);\n    }\n}\n\nsum(100); //5050 很熟悉的结果吧\n</code></pre>\n<ul>\n<li>参考：<blockquote>\n<p>高程3</p>\n</blockquote>\n</li>\n</ul>"},{"title":"JS字符串常用方法总结","date":"2017-04-22T13:54:07.000Z","_content":"\n> 周末温习高程三,摘录读书笔记\n\n### 字符方法\n* charAt()\n* charCodeAt()\n\n<!-- more -->\n都接收一个参数，区别是chartAt()方法以单独字符串形式返回给定位置的字符\neg:\n\n```js\nvar str = 'hello world';\nalert(str.charAt(1))//e\n```\n如果你想得到的不是字符而是编码那就需要charCodeAt():\n```js\nvar str2 = 'hello world';\nalert(str2.charCodeAt(1))//101  小写字母e的字符编码\n```\n注：ECMAScript5中还定义了可以用[Number]的方式访问字符串中特定字符;IE8+\n### 字符串操作方法\n* concat()\n* slice()\n* substr()\n* substring()\n\n```js\n//concat() //顾名思义用来拼接一个或多个字符\nvar str = 'hello';\nvar str0 = str.concat('world');\nconsole.log(str0)//'hello world'\nconsole.log(str)//'hello'\n//实践中还是用+号操作符的拼接字符串的场景多，这里只做演示\n```\n后面三个字符 substr slice substring 第一个是开始位置 区别在于第二个字符\nslice substring 第二个是位置(不包含)\nsubstr 第二个参数是个数，即返回字符的个数,没有第二个参数,意味着从第一个参数起,返回所有\n```js\nvar str = 'biyuqi';\nconsole.log(str.slice(0))   //biyuqi\nconsole.log(str.slice(1,3)) //iy\n\nconsole.log(str.substring(0))   //biyuqi\nconsole.log(str.substring(1,3)) //iy\n\nconsole.log(str.substr(0))   //biyuqi\nconsole.log(str.substr(1,3)) //iyu 不包含3 数量3\n```\n### 字符串位置的方法\n与数组方法类似,返回字符串的位置(如果没有找到该字符,则返回-1),区别在于indexOf从字符串开始向后搜索,lastIndex相反\n* indexOf()\n* lastIndexOf()\n\n```js\nvar str = 'hello world';\nconsole.log(str.indexOf('o')) //4\nconsole.log(str.lastIndexOf('o')) //7\nconsole.log(str.indexOf('m')) //-1\n\n//判断重复字符\n//a 测试变量\nif(str.indexOf(a) === str.lastIndexOf(a)){\n    console.log(\"没有重复字符\")\n}else{\n    console.log(\"有重复字符\")\n}\n```\n### trim()方法\nECMAScipr5为所有字符定义了trim()方法,去除字符前后所有空格\n```js\nvar str = ' hello,sorld ';\nconsole.log(str.trim()) //'hello sorld'\n\n// trim() 仅支持IE9+\n//so 兼容方法\nfunction trim(s){\n    var reg = /(^\\s*)|(\\s*$)/g;\n    return s.replace(reg,'')\n}\n```\n### 字符串模式匹配方法\n** match()接收一个参数,要么是一个正则表达式,要么是一个RegExp对象**\n* match() //与正则exec()方法类似\n* replace()\n\n返回一个数组,数组第一项与整个是与整个模式配的字符串,之后的每一项(如果有)保存着与正则表达式中的捕获组匹配的字符串,没有匹配则返回null\n\n```js\nvar string = 'biyui,sdf,sdfsdf'\nvar reg = /(.),/;\nconsole.log(string.match(reg))\n```\n![][1]\n\n全匹配时返回匹配数组,没有匹配则返回null\n```js\nvar string = 'biyui,sdf,sdfsdf'\nvar reg = /(.),/g;\nconsole.log(string.match(reg))\n```\n![][2]\n\n** replace(),接收两个参数：第一个参数可以使RegExp对象或者一个字符串,第二个参数可以使一个字符串或者一个函数 **\n```js\n//字符替换\nvar text = 'cat,bat,sat,fat';\nvar res = text.replace('at','ond');\nconsole.log(res) // cond bat sat fat\n\n//全部替换\nvar text = 'cat,bat,sat,fat';\nvar res = text.replace(/at/g,'ond');\nconsole.log(res) // cond bond,sond fond\n```\n```js\n//第二个参数函数\n//1.只有一个匹配项时，会接收三个参数：模式匹配的项，位置，原始串\n//2.如果有多个捕获组，传递的参数一次的模式匹配的匹配项1、2、3;最后两个参数依然是 位置 原始串\n\n//替换特殊字符\nfunction htmlreplace(s){\n    return s.replace(/[<>\"&]/g,function(match,pos,text){\n        switch(match){\n            case \"<\":\n                return \"&lt;\";\n            case \">\":\n                return \"&gt;\";\n            case \"&\":\n                return \"&amp\";\n            case \"\\\"\":\n                return \"&quot;\";\n        }\n    });\n}\nconsole.log(htmlreplace(\"<p>test</p>\"))\n//&lt;p&gt;test&lt;/P&gt;\n```\n\n[1]: http://oj7j5nuxv.bkt.clouddn.com/match-v.png\n[2]: http://oj7j5nuxv.bkt.clouddn.com/match-val.png\n","source":"_posts/Javascript字符串常用方法总结.md","raw":"---\ntitle: JS字符串常用方法总结\ndate: 2017-04-22 21:54:07\ntags: [javascript]\ncategories: Javascript\n---\n\n> 周末温习高程三,摘录读书笔记\n\n### 字符方法\n* charAt()\n* charCodeAt()\n\n<!-- more -->\n都接收一个参数，区别是chartAt()方法以单独字符串形式返回给定位置的字符\neg:\n\n```js\nvar str = 'hello world';\nalert(str.charAt(1))//e\n```\n如果你想得到的不是字符而是编码那就需要charCodeAt():\n```js\nvar str2 = 'hello world';\nalert(str2.charCodeAt(1))//101  小写字母e的字符编码\n```\n注：ECMAScript5中还定义了可以用[Number]的方式访问字符串中特定字符;IE8+\n### 字符串操作方法\n* concat()\n* slice()\n* substr()\n* substring()\n\n```js\n//concat() //顾名思义用来拼接一个或多个字符\nvar str = 'hello';\nvar str0 = str.concat('world');\nconsole.log(str0)//'hello world'\nconsole.log(str)//'hello'\n//实践中还是用+号操作符的拼接字符串的场景多，这里只做演示\n```\n后面三个字符 substr slice substring 第一个是开始位置 区别在于第二个字符\nslice substring 第二个是位置(不包含)\nsubstr 第二个参数是个数，即返回字符的个数,没有第二个参数,意味着从第一个参数起,返回所有\n```js\nvar str = 'biyuqi';\nconsole.log(str.slice(0))   //biyuqi\nconsole.log(str.slice(1,3)) //iy\n\nconsole.log(str.substring(0))   //biyuqi\nconsole.log(str.substring(1,3)) //iy\n\nconsole.log(str.substr(0))   //biyuqi\nconsole.log(str.substr(1,3)) //iyu 不包含3 数量3\n```\n### 字符串位置的方法\n与数组方法类似,返回字符串的位置(如果没有找到该字符,则返回-1),区别在于indexOf从字符串开始向后搜索,lastIndex相反\n* indexOf()\n* lastIndexOf()\n\n```js\nvar str = 'hello world';\nconsole.log(str.indexOf('o')) //4\nconsole.log(str.lastIndexOf('o')) //7\nconsole.log(str.indexOf('m')) //-1\n\n//判断重复字符\n//a 测试变量\nif(str.indexOf(a) === str.lastIndexOf(a)){\n    console.log(\"没有重复字符\")\n}else{\n    console.log(\"有重复字符\")\n}\n```\n### trim()方法\nECMAScipr5为所有字符定义了trim()方法,去除字符前后所有空格\n```js\nvar str = ' hello,sorld ';\nconsole.log(str.trim()) //'hello sorld'\n\n// trim() 仅支持IE9+\n//so 兼容方法\nfunction trim(s){\n    var reg = /(^\\s*)|(\\s*$)/g;\n    return s.replace(reg,'')\n}\n```\n### 字符串模式匹配方法\n** match()接收一个参数,要么是一个正则表达式,要么是一个RegExp对象**\n* match() //与正则exec()方法类似\n* replace()\n\n返回一个数组,数组第一项与整个是与整个模式配的字符串,之后的每一项(如果有)保存着与正则表达式中的捕获组匹配的字符串,没有匹配则返回null\n\n```js\nvar string = 'biyui,sdf,sdfsdf'\nvar reg = /(.),/;\nconsole.log(string.match(reg))\n```\n![][1]\n\n全匹配时返回匹配数组,没有匹配则返回null\n```js\nvar string = 'biyui,sdf,sdfsdf'\nvar reg = /(.),/g;\nconsole.log(string.match(reg))\n```\n![][2]\n\n** replace(),接收两个参数：第一个参数可以使RegExp对象或者一个字符串,第二个参数可以使一个字符串或者一个函数 **\n```js\n//字符替换\nvar text = 'cat,bat,sat,fat';\nvar res = text.replace('at','ond');\nconsole.log(res) // cond bat sat fat\n\n//全部替换\nvar text = 'cat,bat,sat,fat';\nvar res = text.replace(/at/g,'ond');\nconsole.log(res) // cond bond,sond fond\n```\n```js\n//第二个参数函数\n//1.只有一个匹配项时，会接收三个参数：模式匹配的项，位置，原始串\n//2.如果有多个捕获组，传递的参数一次的模式匹配的匹配项1、2、3;最后两个参数依然是 位置 原始串\n\n//替换特殊字符\nfunction htmlreplace(s){\n    return s.replace(/[<>\"&]/g,function(match,pos,text){\n        switch(match){\n            case \"<\":\n                return \"&lt;\";\n            case \">\":\n                return \"&gt;\";\n            case \"&\":\n                return \"&amp\";\n            case \"\\\"\":\n                return \"&quot;\";\n        }\n    });\n}\nconsole.log(htmlreplace(\"<p>test</p>\"))\n//&lt;p&gt;test&lt;/P&gt;\n```\n\n[1]: http://oj7j5nuxv.bkt.clouddn.com/match-v.png\n[2]: http://oj7j5nuxv.bkt.clouddn.com/match-val.png\n","slug":"Javascript字符串常用方法总结","published":1,"updated":"2019-09-25T15:10:25.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91oc001hla2ewnbi608w","content":"<blockquote>\n<p>周末温习高程三,摘录读书笔记</p>\n</blockquote>\n<h3 id=\"字符方法\"><a href=\"#字符方法\" class=\"headerlink\" title=\"字符方法\"></a>字符方法</h3><ul>\n<li>charAt()</li>\n<li>charCodeAt()</li>\n</ul>\n<a id=\"more\"></a>\n<p>都接收一个参数，区别是chartAt()方法以单独字符串形式返回给定位置的字符<br>eg:</p>\n<pre><code class=\"js\">var str = &#39;hello world&#39;;\nalert(str.charAt(1))//e\n</code></pre>\n<p>如果你想得到的不是字符而是编码那就需要charCodeAt():</p>\n<pre><code class=\"js\">var str2 = &#39;hello world&#39;;\nalert(str2.charCodeAt(1))//101  小写字母e的字符编码\n</code></pre>\n<p>注：ECMAScript5中还定义了可以用[Number]的方式访问字符串中特定字符;IE8+</p>\n<h3 id=\"字符串操作方法\"><a href=\"#字符串操作方法\" class=\"headerlink\" title=\"字符串操作方法\"></a>字符串操作方法</h3><ul>\n<li>concat()</li>\n<li>slice()</li>\n<li>substr()</li>\n<li>substring()</li>\n</ul>\n<pre><code class=\"js\">//concat() //顾名思义用来拼接一个或多个字符\nvar str = &#39;hello&#39;;\nvar str0 = str.concat(&#39;world&#39;);\nconsole.log(str0)//&#39;hello world&#39;\nconsole.log(str)//&#39;hello&#39;\n//实践中还是用+号操作符的拼接字符串的场景多，这里只做演示\n</code></pre>\n<p>后面三个字符 substr slice substring 第一个是开始位置 区别在于第二个字符<br>slice substring 第二个是位置(不包含)<br>substr 第二个参数是个数，即返回字符的个数,没有第二个参数,意味着从第一个参数起,返回所有</p>\n<pre><code class=\"js\">var str = &#39;biyuqi&#39;;\nconsole.log(str.slice(0))   //biyuqi\nconsole.log(str.slice(1,3)) //iy\n\nconsole.log(str.substring(0))   //biyuqi\nconsole.log(str.substring(1,3)) //iy\n\nconsole.log(str.substr(0))   //biyuqi\nconsole.log(str.substr(1,3)) //iyu 不包含3 数量3\n</code></pre>\n<h3 id=\"字符串位置的方法\"><a href=\"#字符串位置的方法\" class=\"headerlink\" title=\"字符串位置的方法\"></a>字符串位置的方法</h3><p>与数组方法类似,返回字符串的位置(如果没有找到该字符,则返回-1),区别在于indexOf从字符串开始向后搜索,lastIndex相反</p>\n<ul>\n<li>indexOf()</li>\n<li>lastIndexOf()</li>\n</ul>\n<pre><code class=\"js\">var str = &#39;hello world&#39;;\nconsole.log(str.indexOf(&#39;o&#39;)) //4\nconsole.log(str.lastIndexOf(&#39;o&#39;)) //7\nconsole.log(str.indexOf(&#39;m&#39;)) //-1\n\n//判断重复字符\n//a 测试变量\nif(str.indexOf(a) === str.lastIndexOf(a)){\n    console.log(&quot;没有重复字符&quot;)\n}else{\n    console.log(&quot;有重复字符&quot;)\n}\n</code></pre>\n<h3 id=\"trim-方法\"><a href=\"#trim-方法\" class=\"headerlink\" title=\"trim()方法\"></a>trim()方法</h3><p>ECMAScipr5为所有字符定义了trim()方法,去除字符前后所有空格</p>\n<pre><code class=\"js\">var str = &#39; hello,sorld &#39;;\nconsole.log(str.trim()) //&#39;hello sorld&#39;\n\n// trim() 仅支持IE9+\n//so 兼容方法\nfunction trim(s){\n    var reg = /(^\\s*)|(\\s*$)/g;\n    return s.replace(reg,&#39;&#39;)\n}\n</code></pre>\n<h3 id=\"字符串模式匹配方法\"><a href=\"#字符串模式匹配方法\" class=\"headerlink\" title=\"字符串模式匹配方法\"></a>字符串模式匹配方法</h3><p><strong> match()接收一个参数,要么是一个正则表达式,要么是一个RegExp对象</strong></p>\n<ul>\n<li>match() //与正则exec()方法类似</li>\n<li>replace()</li>\n</ul>\n<p>返回一个数组,数组第一项与整个是与整个模式配的字符串,之后的每一项(如果有)保存着与正则表达式中的捕获组匹配的字符串,没有匹配则返回null</p>\n<pre><code class=\"js\">var string = &#39;biyui,sdf,sdfsdf&#39;\nvar reg = /(.),/;\nconsole.log(string.match(reg))\n</code></pre>\n<p><img src=\"http://oj7j5nuxv.bkt.clouddn.com/match-v.png\" alt=\"\"></p>\n<p>全匹配时返回匹配数组,没有匹配则返回null</p>\n<pre><code class=\"js\">var string = &#39;biyui,sdf,sdfsdf&#39;\nvar reg = /(.),/g;\nconsole.log(string.match(reg))\n</code></pre>\n<p><img src=\"http://oj7j5nuxv.bkt.clouddn.com/match-val.png\" alt=\"\"></p>\n<p><strong> replace(),接收两个参数：第一个参数可以使RegExp对象或者一个字符串,第二个参数可以使一个字符串或者一个函数 </strong></p>\n<pre><code class=\"js\">//字符替换\nvar text = &#39;cat,bat,sat,fat&#39;;\nvar res = text.replace(&#39;at&#39;,&#39;ond&#39;);\nconsole.log(res) // cond bat sat fat\n\n//全部替换\nvar text = &#39;cat,bat,sat,fat&#39;;\nvar res = text.replace(/at/g,&#39;ond&#39;);\nconsole.log(res) // cond bond,sond fond\n</code></pre>\n<pre><code class=\"js\">//第二个参数函数\n//1.只有一个匹配项时，会接收三个参数：模式匹配的项，位置，原始串\n//2.如果有多个捕获组，传递的参数一次的模式匹配的匹配项1、2、3;最后两个参数依然是 位置 原始串\n\n//替换特殊字符\nfunction htmlreplace(s){\n    return s.replace(/[&lt;&gt;&quot;&amp;]/g,function(match,pos,text){\n        switch(match){\n            case &quot;&lt;&quot;:\n                return &quot;&amp;lt;&quot;;\n            case &quot;&gt;&quot;:\n                return &quot;&amp;gt;&quot;;\n            case &quot;&amp;&quot;:\n                return &quot;&amp;amp&quot;;\n            case &quot;\\&quot;&quot;:\n                return &quot;&amp;quot;&quot;;\n        }\n    });\n}\nconsole.log(htmlreplace(&quot;&lt;p&gt;test&lt;/p&gt;&quot;))\n//&amp;lt;p&amp;gt;test&amp;lt;/P&amp;gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>周末温习高程三,摘录读书笔记</p>\n</blockquote>\n<h3 id=\"字符方法\"><a href=\"#字符方法\" class=\"headerlink\" title=\"字符方法\"></a>字符方法</h3><ul>\n<li>charAt()</li>\n<li>charCodeAt()</li>\n</ul>","more":"<p>都接收一个参数，区别是chartAt()方法以单独字符串形式返回给定位置的字符<br>eg:</p>\n<pre><code class=\"js\">var str = &#39;hello world&#39;;\nalert(str.charAt(1))//e\n</code></pre>\n<p>如果你想得到的不是字符而是编码那就需要charCodeAt():</p>\n<pre><code class=\"js\">var str2 = &#39;hello world&#39;;\nalert(str2.charCodeAt(1))//101  小写字母e的字符编码\n</code></pre>\n<p>注：ECMAScript5中还定义了可以用[Number]的方式访问字符串中特定字符;IE8+</p>\n<h3 id=\"字符串操作方法\"><a href=\"#字符串操作方法\" class=\"headerlink\" title=\"字符串操作方法\"></a>字符串操作方法</h3><ul>\n<li>concat()</li>\n<li>slice()</li>\n<li>substr()</li>\n<li>substring()</li>\n</ul>\n<pre><code class=\"js\">//concat() //顾名思义用来拼接一个或多个字符\nvar str = &#39;hello&#39;;\nvar str0 = str.concat(&#39;world&#39;);\nconsole.log(str0)//&#39;hello world&#39;\nconsole.log(str)//&#39;hello&#39;\n//实践中还是用+号操作符的拼接字符串的场景多，这里只做演示\n</code></pre>\n<p>后面三个字符 substr slice substring 第一个是开始位置 区别在于第二个字符<br>slice substring 第二个是位置(不包含)<br>substr 第二个参数是个数，即返回字符的个数,没有第二个参数,意味着从第一个参数起,返回所有</p>\n<pre><code class=\"js\">var str = &#39;biyuqi&#39;;\nconsole.log(str.slice(0))   //biyuqi\nconsole.log(str.slice(1,3)) //iy\n\nconsole.log(str.substring(0))   //biyuqi\nconsole.log(str.substring(1,3)) //iy\n\nconsole.log(str.substr(0))   //biyuqi\nconsole.log(str.substr(1,3)) //iyu 不包含3 数量3\n</code></pre>\n<h3 id=\"字符串位置的方法\"><a href=\"#字符串位置的方法\" class=\"headerlink\" title=\"字符串位置的方法\"></a>字符串位置的方法</h3><p>与数组方法类似,返回字符串的位置(如果没有找到该字符,则返回-1),区别在于indexOf从字符串开始向后搜索,lastIndex相反</p>\n<ul>\n<li>indexOf()</li>\n<li>lastIndexOf()</li>\n</ul>\n<pre><code class=\"js\">var str = &#39;hello world&#39;;\nconsole.log(str.indexOf(&#39;o&#39;)) //4\nconsole.log(str.lastIndexOf(&#39;o&#39;)) //7\nconsole.log(str.indexOf(&#39;m&#39;)) //-1\n\n//判断重复字符\n//a 测试变量\nif(str.indexOf(a) === str.lastIndexOf(a)){\n    console.log(&quot;没有重复字符&quot;)\n}else{\n    console.log(&quot;有重复字符&quot;)\n}\n</code></pre>\n<h3 id=\"trim-方法\"><a href=\"#trim-方法\" class=\"headerlink\" title=\"trim()方法\"></a>trim()方法</h3><p>ECMAScipr5为所有字符定义了trim()方法,去除字符前后所有空格</p>\n<pre><code class=\"js\">var str = &#39; hello,sorld &#39;;\nconsole.log(str.trim()) //&#39;hello sorld&#39;\n\n// trim() 仅支持IE9+\n//so 兼容方法\nfunction trim(s){\n    var reg = /(^\\s*)|(\\s*$)/g;\n    return s.replace(reg,&#39;&#39;)\n}\n</code></pre>\n<h3 id=\"字符串模式匹配方法\"><a href=\"#字符串模式匹配方法\" class=\"headerlink\" title=\"字符串模式匹配方法\"></a>字符串模式匹配方法</h3><p><strong> match()接收一个参数,要么是一个正则表达式,要么是一个RegExp对象</strong></p>\n<ul>\n<li>match() //与正则exec()方法类似</li>\n<li>replace()</li>\n</ul>\n<p>返回一个数组,数组第一项与整个是与整个模式配的字符串,之后的每一项(如果有)保存着与正则表达式中的捕获组匹配的字符串,没有匹配则返回null</p>\n<pre><code class=\"js\">var string = &#39;biyui,sdf,sdfsdf&#39;\nvar reg = /(.),/;\nconsole.log(string.match(reg))\n</code></pre>\n<p><img src=\"http://oj7j5nuxv.bkt.clouddn.com/match-v.png\" alt=\"\"></p>\n<p>全匹配时返回匹配数组,没有匹配则返回null</p>\n<pre><code class=\"js\">var string = &#39;biyui,sdf,sdfsdf&#39;\nvar reg = /(.),/g;\nconsole.log(string.match(reg))\n</code></pre>\n<p><img src=\"http://oj7j5nuxv.bkt.clouddn.com/match-val.png\" alt=\"\"></p>\n<p><strong> replace(),接收两个参数：第一个参数可以使RegExp对象或者一个字符串,第二个参数可以使一个字符串或者一个函数 </strong></p>\n<pre><code class=\"js\">//字符替换\nvar text = &#39;cat,bat,sat,fat&#39;;\nvar res = text.replace(&#39;at&#39;,&#39;ond&#39;);\nconsole.log(res) // cond bat sat fat\n\n//全部替换\nvar text = &#39;cat,bat,sat,fat&#39;;\nvar res = text.replace(/at/g,&#39;ond&#39;);\nconsole.log(res) // cond bond,sond fond\n</code></pre>\n<pre><code class=\"js\">//第二个参数函数\n//1.只有一个匹配项时，会接收三个参数：模式匹配的项，位置，原始串\n//2.如果有多个捕获组，传递的参数一次的模式匹配的匹配项1、2、3;最后两个参数依然是 位置 原始串\n\n//替换特殊字符\nfunction htmlreplace(s){\n    return s.replace(/[&lt;&gt;&quot;&amp;]/g,function(match,pos,text){\n        switch(match){\n            case &quot;&lt;&quot;:\n                return &quot;&amp;lt;&quot;;\n            case &quot;&gt;&quot;:\n                return &quot;&amp;gt;&quot;;\n            case &quot;&amp;&quot;:\n                return &quot;&amp;amp&quot;;\n            case &quot;\\&quot;&quot;:\n                return &quot;&amp;quot;&quot;;\n        }\n    });\n}\nconsole.log(htmlreplace(&quot;&lt;p&gt;test&lt;/p&gt;&quot;))\n//&amp;lt;p&amp;gt;test&amp;lt;/P&amp;gt;\n</code></pre>"},{"title":"Javascript开发性能调优(一)","date":"2017-02-16T13:00:06.000Z","_content":"> ** 为什么我们做出速度很慢的网站，给用户一个糟糕的体验？**\n\n\n<!-- more -->\n### 异步加载第三方内容\n有人没有加载过这样的第三方内容吗？比如第三方统计，打开很多网站，f12都会看到这些内容问题在于，不管是用户端的还是服务器端的连接，都无法保证这些代码是正常有效的工作的。这些服务有可能临时dowan掉或者是被用户或者其公司的防火墙阻止.为了避免这些在页面加载时成为问题，或者更严重的是，阻塞了全部页面的加载，总是应该异步加载这些代码.\n\n```javascript\nvar script = document.createElement('script'),\n    scripts = document.getElementsByTagName('script')[0];\n\n    script.async = true;\n    script.src = url;\n    scripts.parentNode.insertBefore(script,scripts);\n\n```\n### 缓存数组长度\n循环无疑是和Javascript性能非常相关的一部分。试着优化循环的逻辑，从而让每次循环更加的高效。要做到这一点，方法之一是存储数组的长度，这样的话，在每次循环时都不用重新计算。\n```javascript\nvar arr = new Array(1000),\n    i,len;\n\n//Bad code\nfor(i=0;i<arr.length;i++){\n    //需要计算一千\n}\n//Good Code\nfor(i=0;len = arr.length;i<len;i++){\n    //计算一次长度\n}\n```\n> 注解: 虽然现代浏览器引擎会自动优化这个过程，但是不要忘记还有旧的浏览器\n\n** 在迭代document.getElementsByTagName('a')等类似方法生成的HTML节点数组（NodeList）时，缓存数组长度尤为关键。这些集合通常被认为是“灵活的”，意思就是说，当他们所对应的元素发生变化时，他们会被自动更新。**\n```javascript\nvar elements  = document.getElementsByTagName('a'),\n    i,len;\nfor(i=0;len = elements.length;i<len;i++){\n    //do some code\n}\n```\n注意:返回一个包括所有给定标签名称的元素的HTML集合HTMLCollection。 整个文件结构都会被搜索，包括根节点。返回的 HTML集合是动态的, 意味着它可以自动更新自己来保持和 DOM 树的同步而不用再次调用 document.getElementsByTagName()\n\n### 最小化重绘和回流\n当有任何属性或元素发生改变时，都会引起DOM元素的重绘和回流。当一个元素的布局不变，外观发生改变时，就会引起重绘。就像样式的改变，例如改变background-color。回流的代价是最高的，当改变一个页面的布局时就会发生回流。\n```javascript\nvar item = document.getElementById(\"test\"),\n    lis = document.getElementsByTagName('li'),\n    i, len;\n\nfor (i = 0, len = lis.length; i < len; i++) {\n    //item.offsetWidth 会不停的计算item的宽度\n    lis[i].style.width = item.offsetWidth + 'px';\n}\n```\n改为\n```javascript\nvar item = document.getElementById(\"test\"),\n    lis = document.getElementsByTagName('li'),\n    itemWidth = item.offsetWidth,//缓存宽度\n    i, len;\n\nfor (i = 0, len = lis.length; i < len; i++) {\n    lis[i].style.width = itemWidth + 'px';\n}\n```\n参考:\n    [MDN][2]\n\n[1]: http://oiukswkar.bkt.clouddn.com/optmini.jpg\n[2]: https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByTagName\n","source":"_posts/Javascript开发性能调优(一).md","raw":"---\ntitle: Javascript开发性能调优(一)\ndate: 2017-02-16 21:00:06\ntags: [javascript,\"性能\",\"优化\"]\ncategories: Javascript\n---\n> ** 为什么我们做出速度很慢的网站，给用户一个糟糕的体验？**\n\n\n<!-- more -->\n### 异步加载第三方内容\n有人没有加载过这样的第三方内容吗？比如第三方统计，打开很多网站，f12都会看到这些内容问题在于，不管是用户端的还是服务器端的连接，都无法保证这些代码是正常有效的工作的。这些服务有可能临时dowan掉或者是被用户或者其公司的防火墙阻止.为了避免这些在页面加载时成为问题，或者更严重的是，阻塞了全部页面的加载，总是应该异步加载这些代码.\n\n```javascript\nvar script = document.createElement('script'),\n    scripts = document.getElementsByTagName('script')[0];\n\n    script.async = true;\n    script.src = url;\n    scripts.parentNode.insertBefore(script,scripts);\n\n```\n### 缓存数组长度\n循环无疑是和Javascript性能非常相关的一部分。试着优化循环的逻辑，从而让每次循环更加的高效。要做到这一点，方法之一是存储数组的长度，这样的话，在每次循环时都不用重新计算。\n```javascript\nvar arr = new Array(1000),\n    i,len;\n\n//Bad code\nfor(i=0;i<arr.length;i++){\n    //需要计算一千\n}\n//Good Code\nfor(i=0;len = arr.length;i<len;i++){\n    //计算一次长度\n}\n```\n> 注解: 虽然现代浏览器引擎会自动优化这个过程，但是不要忘记还有旧的浏览器\n\n** 在迭代document.getElementsByTagName('a')等类似方法生成的HTML节点数组（NodeList）时，缓存数组长度尤为关键。这些集合通常被认为是“灵活的”，意思就是说，当他们所对应的元素发生变化时，他们会被自动更新。**\n```javascript\nvar elements  = document.getElementsByTagName('a'),\n    i,len;\nfor(i=0;len = elements.length;i<len;i++){\n    //do some code\n}\n```\n注意:返回一个包括所有给定标签名称的元素的HTML集合HTMLCollection。 整个文件结构都会被搜索，包括根节点。返回的 HTML集合是动态的, 意味着它可以自动更新自己来保持和 DOM 树的同步而不用再次调用 document.getElementsByTagName()\n\n### 最小化重绘和回流\n当有任何属性或元素发生改变时，都会引起DOM元素的重绘和回流。当一个元素的布局不变，外观发生改变时，就会引起重绘。就像样式的改变，例如改变background-color。回流的代价是最高的，当改变一个页面的布局时就会发生回流。\n```javascript\nvar item = document.getElementById(\"test\"),\n    lis = document.getElementsByTagName('li'),\n    i, len;\n\nfor (i = 0, len = lis.length; i < len; i++) {\n    //item.offsetWidth 会不停的计算item的宽度\n    lis[i].style.width = item.offsetWidth + 'px';\n}\n```\n改为\n```javascript\nvar item = document.getElementById(\"test\"),\n    lis = document.getElementsByTagName('li'),\n    itemWidth = item.offsetWidth,//缓存宽度\n    i, len;\n\nfor (i = 0, len = lis.length; i < len; i++) {\n    lis[i].style.width = itemWidth + 'px';\n}\n```\n参考:\n    [MDN][2]\n\n[1]: http://oiukswkar.bkt.clouddn.com/optmini.jpg\n[2]: https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByTagName\n","slug":"Javascript开发性能调优(一)","published":1,"updated":"2019-09-25T15:10:25.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91od001kla2eqirv4iji","content":"<blockquote>\n<p><strong> 为什么我们做出速度很慢的网站，给用户一个糟糕的体验？</strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"异步加载第三方内容\"><a href=\"#异步加载第三方内容\" class=\"headerlink\" title=\"异步加载第三方内容\"></a>异步加载第三方内容</h3><p>有人没有加载过这样的第三方内容吗？比如第三方统计，打开很多网站，f12都会看到这些内容问题在于，不管是用户端的还是服务器端的连接，都无法保证这些代码是正常有效的工作的。这些服务有可能临时dowan掉或者是被用户或者其公司的防火墙阻止.为了避免这些在页面加载时成为问题，或者更严重的是，阻塞了全部页面的加载，总是应该异步加载这些代码.</p>\n<pre><code class=\"javascript\">var script = document.createElement(&#39;script&#39;),\n    scripts = document.getElementsByTagName(&#39;script&#39;)[0];\n\n    script.async = true;\n    script.src = url;\n    scripts.parentNode.insertBefore(script,scripts);\n</code></pre>\n<h3 id=\"缓存数组长度\"><a href=\"#缓存数组长度\" class=\"headerlink\" title=\"缓存数组长度\"></a>缓存数组长度</h3><p>循环无疑是和Javascript性能非常相关的一部分。试着优化循环的逻辑，从而让每次循环更加的高效。要做到这一点，方法之一是存储数组的长度，这样的话，在每次循环时都不用重新计算。</p>\n<pre><code class=\"javascript\">var arr = new Array(1000),\n    i,len;\n\n//Bad code\nfor(i=0;i&lt;arr.length;i++){\n    //需要计算一千\n}\n//Good Code\nfor(i=0;len = arr.length;i&lt;len;i++){\n    //计算一次长度\n}\n</code></pre>\n<blockquote>\n<p>注解: 虽然现代浏览器引擎会自动优化这个过程，但是不要忘记还有旧的浏览器</p>\n</blockquote>\n<p><strong> 在迭代document.getElementsByTagName(‘a’)等类似方法生成的HTML节点数组（NodeList）时，缓存数组长度尤为关键。这些集合通常被认为是“灵活的”，意思就是说，当他们所对应的元素发生变化时，他们会被自动更新。</strong></p>\n<pre><code class=\"javascript\">var elements  = document.getElementsByTagName(&#39;a&#39;),\n    i,len;\nfor(i=0;len = elements.length;i&lt;len;i++){\n    //do some code\n}\n</code></pre>\n<p>注意:返回一个包括所有给定标签名称的元素的HTML集合HTMLCollection。 整个文件结构都会被搜索，包括根节点。返回的 HTML集合是动态的, 意味着它可以自动更新自己来保持和 DOM 树的同步而不用再次调用 document.getElementsByTagName()</p>\n<h3 id=\"最小化重绘和回流\"><a href=\"#最小化重绘和回流\" class=\"headerlink\" title=\"最小化重绘和回流\"></a>最小化重绘和回流</h3><p>当有任何属性或元素发生改变时，都会引起DOM元素的重绘和回流。当一个元素的布局不变，外观发生改变时，就会引起重绘。就像样式的改变，例如改变background-color。回流的代价是最高的，当改变一个页面的布局时就会发生回流。</p>\n<pre><code class=\"javascript\">var item = document.getElementById(&quot;test&quot;),\n    lis = document.getElementsByTagName(&#39;li&#39;),\n    i, len;\n\nfor (i = 0, len = lis.length; i &lt; len; i++) {\n    //item.offsetWidth 会不停的计算item的宽度\n    lis[i].style.width = item.offsetWidth + &#39;px&#39;;\n}\n</code></pre>\n<p>改为</p>\n<pre><code class=\"javascript\">var item = document.getElementById(&quot;test&quot;),\n    lis = document.getElementsByTagName(&#39;li&#39;),\n    itemWidth = item.offsetWidth,//缓存宽度\n    i, len;\n\nfor (i = 0, len = lis.length; i &lt; len; i++) {\n    lis[i].style.width = itemWidth + &#39;px&#39;;\n}\n</code></pre>\n<p>参考:<br>    <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByTagName\" target=\"_blank\" rel=\"external\">MDN</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong> 为什么我们做出速度很慢的网站，给用户一个糟糕的体验？</strong></p>\n</blockquote>","more":"<h3 id=\"异步加载第三方内容\"><a href=\"#异步加载第三方内容\" class=\"headerlink\" title=\"异步加载第三方内容\"></a>异步加载第三方内容</h3><p>有人没有加载过这样的第三方内容吗？比如第三方统计，打开很多网站，f12都会看到这些内容问题在于，不管是用户端的还是服务器端的连接，都无法保证这些代码是正常有效的工作的。这些服务有可能临时dowan掉或者是被用户或者其公司的防火墙阻止.为了避免这些在页面加载时成为问题，或者更严重的是，阻塞了全部页面的加载，总是应该异步加载这些代码.</p>\n<pre><code class=\"javascript\">var script = document.createElement(&#39;script&#39;),\n    scripts = document.getElementsByTagName(&#39;script&#39;)[0];\n\n    script.async = true;\n    script.src = url;\n    scripts.parentNode.insertBefore(script,scripts);\n</code></pre>\n<h3 id=\"缓存数组长度\"><a href=\"#缓存数组长度\" class=\"headerlink\" title=\"缓存数组长度\"></a>缓存数组长度</h3><p>循环无疑是和Javascript性能非常相关的一部分。试着优化循环的逻辑，从而让每次循环更加的高效。要做到这一点，方法之一是存储数组的长度，这样的话，在每次循环时都不用重新计算。</p>\n<pre><code class=\"javascript\">var arr = new Array(1000),\n    i,len;\n\n//Bad code\nfor(i=0;i&lt;arr.length;i++){\n    //需要计算一千\n}\n//Good Code\nfor(i=0;len = arr.length;i&lt;len;i++){\n    //计算一次长度\n}\n</code></pre>\n<blockquote>\n<p>注解: 虽然现代浏览器引擎会自动优化这个过程，但是不要忘记还有旧的浏览器</p>\n</blockquote>\n<p><strong> 在迭代document.getElementsByTagName(‘a’)等类似方法生成的HTML节点数组（NodeList）时，缓存数组长度尤为关键。这些集合通常被认为是“灵活的”，意思就是说，当他们所对应的元素发生变化时，他们会被自动更新。</strong></p>\n<pre><code class=\"javascript\">var elements  = document.getElementsByTagName(&#39;a&#39;),\n    i,len;\nfor(i=0;len = elements.length;i&lt;len;i++){\n    //do some code\n}\n</code></pre>\n<p>注意:返回一个包括所有给定标签名称的元素的HTML集合HTMLCollection。 整个文件结构都会被搜索，包括根节点。返回的 HTML集合是动态的, 意味着它可以自动更新自己来保持和 DOM 树的同步而不用再次调用 document.getElementsByTagName()</p>\n<h3 id=\"最小化重绘和回流\"><a href=\"#最小化重绘和回流\" class=\"headerlink\" title=\"最小化重绘和回流\"></a>最小化重绘和回流</h3><p>当有任何属性或元素发生改变时，都会引起DOM元素的重绘和回流。当一个元素的布局不变，外观发生改变时，就会引起重绘。就像样式的改变，例如改变background-color。回流的代价是最高的，当改变一个页面的布局时就会发生回流。</p>\n<pre><code class=\"javascript\">var item = document.getElementById(&quot;test&quot;),\n    lis = document.getElementsByTagName(&#39;li&#39;),\n    i, len;\n\nfor (i = 0, len = lis.length; i &lt; len; i++) {\n    //item.offsetWidth 会不停的计算item的宽度\n    lis[i].style.width = item.offsetWidth + &#39;px&#39;;\n}\n</code></pre>\n<p>改为</p>\n<pre><code class=\"javascript\">var item = document.getElementById(&quot;test&quot;),\n    lis = document.getElementsByTagName(&#39;li&#39;),\n    itemWidth = item.offsetWidth,//缓存宽度\n    i, len;\n\nfor (i = 0, len = lis.length; i &lt; len; i++) {\n    lis[i].style.width = itemWidth + &#39;px&#39;;\n}\n</code></pre>\n<p>参考:<br>    <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByTagName\" target=\"_blank\" rel=\"external\">MDN</a></p>"},{"title":"Javascript数组去重","date":"2016-12-03T16:33:30.000Z","_content":"#### 前言 ####\n面试前端必须准备的一个问题：怎样去掉javascript的array的重复项。据我所知，百度、腾讯、盛大等都在面试里出过这个题目。 这个问题看起来简单，但是其实暗藏杀机。 考的不仅仅是实现这个功能，更能看出你对计算机程序执行的深入理解.\n<!-- more -->\n#### 实现方式 ####\n##### 1.数组去重第一种方法 #####\n```javascript\n    Array.prototype.unique1 = function(){\n        var test = [];//一个新的临时数组\n        var obj = {};\n        for(var i=0;i<this.length;i++){//遍历当前数组\n            if(!obj[this[i]]){//如果没有当前项\n                test.push(this[i]);//把当前数组的当前项push到临时数组里面\n                obj[this[i]] = 1;\n            }else{\n                obj[this[i]]++;\n            }\n    }\n    //这里只用到了test 所以只return test; obj可以计数又可以去重\n    return test;\n};\n```\n##### 2.数组去重第二种方法 #####\n```javascript\n    Array.prototype.unique2 = function(){\n        var test = [];\n        for(var i=0;i<this.length;i++){\n            if(test.indexOf(this[i]) == -1){\n                test.push(this[i]);\n            }\n        }\n        return test;\n};\n```\n#### 结语 ####\n其中第2种用到了数组的indexOf方法。此方法的目的是寻找存入参数在数组中第一次出现的位置。很显然，js引擎在实现这个方法的时候会遍历数组直到找到目标为止。所以此函数会浪费掉很多时间。 而第1中方法用的是对象。把已经出现过的通过下标的形式存入一个object内。下标的引用要比用indexOf搜索数组快的多。\n","source":"_posts/Javascript数组去重效率比较.md","raw":"---\ntitle: Javascript数组去重\ndate: 2016-12-04 00:33:30\ntags: [javascript]\ncategories: Javascript\n---\n#### 前言 ####\n面试前端必须准备的一个问题：怎样去掉javascript的array的重复项。据我所知，百度、腾讯、盛大等都在面试里出过这个题目。 这个问题看起来简单，但是其实暗藏杀机。 考的不仅仅是实现这个功能，更能看出你对计算机程序执行的深入理解.\n<!-- more -->\n#### 实现方式 ####\n##### 1.数组去重第一种方法 #####\n```javascript\n    Array.prototype.unique1 = function(){\n        var test = [];//一个新的临时数组\n        var obj = {};\n        for(var i=0;i<this.length;i++){//遍历当前数组\n            if(!obj[this[i]]){//如果没有当前项\n                test.push(this[i]);//把当前数组的当前项push到临时数组里面\n                obj[this[i]] = 1;\n            }else{\n                obj[this[i]]++;\n            }\n    }\n    //这里只用到了test 所以只return test; obj可以计数又可以去重\n    return test;\n};\n```\n##### 2.数组去重第二种方法 #####\n```javascript\n    Array.prototype.unique2 = function(){\n        var test = [];\n        for(var i=0;i<this.length;i++){\n            if(test.indexOf(this[i]) == -1){\n                test.push(this[i]);\n            }\n        }\n        return test;\n};\n```\n#### 结语 ####\n其中第2种用到了数组的indexOf方法。此方法的目的是寻找存入参数在数组中第一次出现的位置。很显然，js引擎在实现这个方法的时候会遍历数组直到找到目标为止。所以此函数会浪费掉很多时间。 而第1中方法用的是对象。把已经出现过的通过下标的形式存入一个object内。下标的引用要比用indexOf搜索数组快的多。\n","slug":"Javascript数组去重效率比较","published":1,"updated":"2019-09-25T15:10:25.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91of001ola2e9p5ib6fm","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>面试前端必须准备的一个问题：怎样去掉javascript的array的重复项。据我所知，百度、腾讯、盛大等都在面试里出过这个题目。 这个问题看起来简单，但是其实暗藏杀机。 考的不仅仅是实现这个功能，更能看出你对计算机程序执行的深入理解.<br><a id=\"more\"></a></p>\n<h4 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h4><h5 id=\"1-数组去重第一种方法\"><a href=\"#1-数组去重第一种方法\" class=\"headerlink\" title=\"1.数组去重第一种方法\"></a>1.数组去重第一种方法</h5><pre><code class=\"javascript\">    Array.prototype.unique1 = function(){\n        var test = [];//一个新的临时数组\n        var obj = {};\n        for(var i=0;i&lt;this.length;i++){//遍历当前数组\n            if(!obj[this[i]]){//如果没有当前项\n                test.push(this[i]);//把当前数组的当前项push到临时数组里面\n                obj[this[i]] = 1;\n            }else{\n                obj[this[i]]++;\n            }\n    }\n    //这里只用到了test 所以只return test; obj可以计数又可以去重\n    return test;\n};\n</code></pre>\n<h5 id=\"2-数组去重第二种方法\"><a href=\"#2-数组去重第二种方法\" class=\"headerlink\" title=\"2.数组去重第二种方法\"></a>2.数组去重第二种方法</h5><pre><code class=\"javascript\">    Array.prototype.unique2 = function(){\n        var test = [];\n        for(var i=0;i&lt;this.length;i++){\n            if(test.indexOf(this[i]) == -1){\n                test.push(this[i]);\n            }\n        }\n        return test;\n};\n</code></pre>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4><p>其中第2种用到了数组的indexOf方法。此方法的目的是寻找存入参数在数组中第一次出现的位置。很显然，js引擎在实现这个方法的时候会遍历数组直到找到目标为止。所以此函数会浪费掉很多时间。 而第1中方法用的是对象。把已经出现过的通过下标的形式存入一个object内。下标的引用要比用indexOf搜索数组快的多。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>面试前端必须准备的一个问题：怎样去掉javascript的array的重复项。据我所知，百度、腾讯、盛大等都在面试里出过这个题目。 这个问题看起来简单，但是其实暗藏杀机。 考的不仅仅是实现这个功能，更能看出你对计算机程序执行的深入理解.<br>","more":"</p>\n<h4 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h4><h5 id=\"1-数组去重第一种方法\"><a href=\"#1-数组去重第一种方法\" class=\"headerlink\" title=\"1.数组去重第一种方法\"></a>1.数组去重第一种方法</h5><pre><code class=\"javascript\">    Array.prototype.unique1 = function(){\n        var test = [];//一个新的临时数组\n        var obj = {};\n        for(var i=0;i&lt;this.length;i++){//遍历当前数组\n            if(!obj[this[i]]){//如果没有当前项\n                test.push(this[i]);//把当前数组的当前项push到临时数组里面\n                obj[this[i]] = 1;\n            }else{\n                obj[this[i]]++;\n            }\n    }\n    //这里只用到了test 所以只return test; obj可以计数又可以去重\n    return test;\n};\n</code></pre>\n<h5 id=\"2-数组去重第二种方法\"><a href=\"#2-数组去重第二种方法\" class=\"headerlink\" title=\"2.数组去重第二种方法\"></a>2.数组去重第二种方法</h5><pre><code class=\"javascript\">    Array.prototype.unique2 = function(){\n        var test = [];\n        for(var i=0;i&lt;this.length;i++){\n            if(test.indexOf(this[i]) == -1){\n                test.push(this[i]);\n            }\n        }\n        return test;\n};\n</code></pre>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4><p>其中第2种用到了数组的indexOf方法。此方法的目的是寻找存入参数在数组中第一次出现的位置。很显然，js引擎在实现这个方法的时候会遍历数组直到找到目标为止。所以此函数会浪费掉很多时间。 而第1中方法用的是对象。把已经出现过的通过下标的形式存入一个object内。下标的引用要比用indexOf搜索数组快的多。</p>"},{"title":"Js上传图片本地预览几种姿势","date":"2017-11-18T09:00:12.000Z","_content":"> 本主要总结前端开发中图片上传预览的几个方法 ** FileReader ** 和 ** URL.createObjectURL() **\n\n## FileReader\n\n1.什么是filereader？\n\n> FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 ---MDN\n\n看下怎么利用它来简单的实现一个图片预览\n```html\n<input type=\"file\" id=\"input\">\n```\n```js\n/**\n*   @param {dom} StringOrObject input元素\n*   @param {fn} Function 回调函数 返回bs64 file\n*/\n\nconst imagePreview = function(dom,fn){\n    if(typeof dom === 'string'){\n        dom = document.querySelector(dom)\n    }\n    const bindEv = function(){\n        // 这里默认单图上传\n        const file = this.files[0]\n        const reader = new FileReader()\n        reader.onload = function(ev){\n            // 这里得到的是base64图片编码\n            const bs64 = ev.target.result\n            // 返回给回调函数\n            fn && fn(bs64,file)\n        }\n        // 读取指定的file文件，读取完毕后，在onload事件里面 result属性将返回base64URL\n        reader.readAsDataURL(file)\n    }\n\n    dom.addEventListener('change',bindEv,false)\n}\n```\n```js\nimagePreview('#input',function(src,file){\n    // src 就是base64图片 可进行预览操作\n    //.file 为文件 可在此处进行上传操作\n    const img = document.createElement('img')\n    img.src = src\n    document.body.appendChild(img)\n    console.log(src)\n    console.log(file)\n})\n```\n** readAsDataURL: **\n> 开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.\n\n## FileReader的问题\n* 兼容性\n* 一些安卓5.0系统以下的bug\n\n** 兼容后面再解决，先着重解决下第二个问题 **\n![](http://oq4hkch8e.bkt.clouddn.com/bs64-filereader-bug-fix.png)\n```js\n/**\n*   正常的图片应该是\n*   data:image/gif;data:image/png;;data:image/jpeg;data:image/x-icon;\n*   而在Android的一些5.0系统以下(如4.0)的设备中,\n*   有些返回的b64字符串缺少关键image/gif标识,所以需要手动加上\n*/\n\nconst imagePreview = function(dom,fn){\n    if(typeof dom === 'string'){\n        dom = document.querySelector(dom)\n    }\n    // 增加一个类型判断函数\n    const isType = function(name,type){\n        return name.indexOf(type) > -1\n    }\n    const bindEv = function(){\n        // 这里默认单图上传\n        const file = this.files[0]\n        const reader = new FileReader()\n        reader.onload = function(ev){\n            let bs64 = ev.target.result\n            if(bs64 && bs64.indexOf('data:base64,') > -1){\n                // 去除旧有的错误头部\n                bs64 = bs64.replace(/data:base64,/,'')\n                // 声明一个空字符用来保存下面判断的类型\n                // 通过name后缀进行识别标注\n                let typeFile = '',\n                    name = file.name.toLowerCase();\n                if(name && isType(name,'.png')){\n                    typeFile = 'image/png;'\n                }\n                if(name && isType(name,'.jpg')){\n                    typeFile = 'image/jpeg;'\n                }\n                if(name && isType(name,'.gif')){\n                    typeFile = 'image/gif;'\n                }\n                if(name && isType(name,'.icon')){\n                    typeFile = 'image/x-icon;'\n                }\n                bs64 = 'data:'+typeFile+'base64,'+bs64\n            }\n            fn && fn(bs64,file)\n        }\n        reader.readAsDataURL(file)\n    }\n\n    dom.addEventListener('change',bindEv,false)\n}\n```\nFirefox | Chrome | Internet Explorer* | Opera | Safari\n------ | ----- | -------| -------- |\n3.6 |7 | 10 |未实现|未实现\n\n下面我们来看下另一种方法\n## URL.createObjectURL()\n> 在每次调用 createObjectURL() 方法时，都会创建一个新的 URL对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们\n\n```js\n// 语法:\n// 参数：blob\n// 是用来创建 URL 的 File 对象或者 Blob 对象​\nobjectURL = URL.createObjectURL(blob);\n```\n```js\nconst imagePreview = function(dom,fn){\n    if(typeof dom === 'string'){\n        dom = document.querySelector(dom)\n    }\n    // 处理下兼容\n    window.URL = window.URL || window.webkitURL\n    const bindEv = function(){\n        const file = this.files[0]\n        const bs64 = window.URL.createObjectURL(file)\n        const img = document.createElement(\"img\")\n        img.src = bs64\n        img.onload = function(){\n            window.URL.revokeObjectURL(this.src)\n        }\n        fn && fn(bs64, file)\n    }\n    dom.addEventListener('change',bindEv,false)\n}\n```\n```js\nimagePreview('#input',function(src,file){\n    // src 就是blog对象 可进行预览操作\n    // blob:null/6436b315-7d42-46e7-b447-a1a982048e61\n    //.file 为文件 可在此处进行上传操作\n    const img = document.createElement('img')\n    img.src = src\n    document.body.appendChild(img)\n    console.log(src)\n    console.log(file)\n})\n```\n在现代浏览器中，支持度还是不错的：\n\nFirefox | Chrome | Internet Explorer* | Opera | Safari(WebKit)\n------ | ----- | -------| -------- |\n3.6 |7 | 10 | 15\t| 6 [1]\n[1] 通过 webkitURL 前缀对象实现。\n\n\n## 参考\n1.[图片引用](https://www.cnblogs.com/saysmy/p/5626337.html)\n2.[MDN-FileReader](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader)\n3.[MDN-createObjectURL](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL)\n","source":"_posts/Js上传图片本地预览几种姿势.md","raw":"---\ntitle: Js上传图片本地预览几种姿势\ndate: 2017-11-18 17:00:12\ntags: [javascript,fileReader,createObjectURL]\ncategories: Javascript\n---\n> 本主要总结前端开发中图片上传预览的几个方法 ** FileReader ** 和 ** URL.createObjectURL() **\n\n## FileReader\n\n1.什么是filereader？\n\n> FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 ---MDN\n\n看下怎么利用它来简单的实现一个图片预览\n```html\n<input type=\"file\" id=\"input\">\n```\n```js\n/**\n*   @param {dom} StringOrObject input元素\n*   @param {fn} Function 回调函数 返回bs64 file\n*/\n\nconst imagePreview = function(dom,fn){\n    if(typeof dom === 'string'){\n        dom = document.querySelector(dom)\n    }\n    const bindEv = function(){\n        // 这里默认单图上传\n        const file = this.files[0]\n        const reader = new FileReader()\n        reader.onload = function(ev){\n            // 这里得到的是base64图片编码\n            const bs64 = ev.target.result\n            // 返回给回调函数\n            fn && fn(bs64,file)\n        }\n        // 读取指定的file文件，读取完毕后，在onload事件里面 result属性将返回base64URL\n        reader.readAsDataURL(file)\n    }\n\n    dom.addEventListener('change',bindEv,false)\n}\n```\n```js\nimagePreview('#input',function(src,file){\n    // src 就是base64图片 可进行预览操作\n    //.file 为文件 可在此处进行上传操作\n    const img = document.createElement('img')\n    img.src = src\n    document.body.appendChild(img)\n    console.log(src)\n    console.log(file)\n})\n```\n** readAsDataURL: **\n> 开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.\n\n## FileReader的问题\n* 兼容性\n* 一些安卓5.0系统以下的bug\n\n** 兼容后面再解决，先着重解决下第二个问题 **\n![](http://oq4hkch8e.bkt.clouddn.com/bs64-filereader-bug-fix.png)\n```js\n/**\n*   正常的图片应该是\n*   data:image/gif;data:image/png;;data:image/jpeg;data:image/x-icon;\n*   而在Android的一些5.0系统以下(如4.0)的设备中,\n*   有些返回的b64字符串缺少关键image/gif标识,所以需要手动加上\n*/\n\nconst imagePreview = function(dom,fn){\n    if(typeof dom === 'string'){\n        dom = document.querySelector(dom)\n    }\n    // 增加一个类型判断函数\n    const isType = function(name,type){\n        return name.indexOf(type) > -1\n    }\n    const bindEv = function(){\n        // 这里默认单图上传\n        const file = this.files[0]\n        const reader = new FileReader()\n        reader.onload = function(ev){\n            let bs64 = ev.target.result\n            if(bs64 && bs64.indexOf('data:base64,') > -1){\n                // 去除旧有的错误头部\n                bs64 = bs64.replace(/data:base64,/,'')\n                // 声明一个空字符用来保存下面判断的类型\n                // 通过name后缀进行识别标注\n                let typeFile = '',\n                    name = file.name.toLowerCase();\n                if(name && isType(name,'.png')){\n                    typeFile = 'image/png;'\n                }\n                if(name && isType(name,'.jpg')){\n                    typeFile = 'image/jpeg;'\n                }\n                if(name && isType(name,'.gif')){\n                    typeFile = 'image/gif;'\n                }\n                if(name && isType(name,'.icon')){\n                    typeFile = 'image/x-icon;'\n                }\n                bs64 = 'data:'+typeFile+'base64,'+bs64\n            }\n            fn && fn(bs64,file)\n        }\n        reader.readAsDataURL(file)\n    }\n\n    dom.addEventListener('change',bindEv,false)\n}\n```\nFirefox | Chrome | Internet Explorer* | Opera | Safari\n------ | ----- | -------| -------- |\n3.6 |7 | 10 |未实现|未实现\n\n下面我们来看下另一种方法\n## URL.createObjectURL()\n> 在每次调用 createObjectURL() 方法时，都会创建一个新的 URL对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们\n\n```js\n// 语法:\n// 参数：blob\n// 是用来创建 URL 的 File 对象或者 Blob 对象​\nobjectURL = URL.createObjectURL(blob);\n```\n```js\nconst imagePreview = function(dom,fn){\n    if(typeof dom === 'string'){\n        dom = document.querySelector(dom)\n    }\n    // 处理下兼容\n    window.URL = window.URL || window.webkitURL\n    const bindEv = function(){\n        const file = this.files[0]\n        const bs64 = window.URL.createObjectURL(file)\n        const img = document.createElement(\"img\")\n        img.src = bs64\n        img.onload = function(){\n            window.URL.revokeObjectURL(this.src)\n        }\n        fn && fn(bs64, file)\n    }\n    dom.addEventListener('change',bindEv,false)\n}\n```\n```js\nimagePreview('#input',function(src,file){\n    // src 就是blog对象 可进行预览操作\n    // blob:null/6436b315-7d42-46e7-b447-a1a982048e61\n    //.file 为文件 可在此处进行上传操作\n    const img = document.createElement('img')\n    img.src = src\n    document.body.appendChild(img)\n    console.log(src)\n    console.log(file)\n})\n```\n在现代浏览器中，支持度还是不错的：\n\nFirefox | Chrome | Internet Explorer* | Opera | Safari(WebKit)\n------ | ----- | -------| -------- |\n3.6 |7 | 10 | 15\t| 6 [1]\n[1] 通过 webkitURL 前缀对象实现。\n\n\n## 参考\n1.[图片引用](https://www.cnblogs.com/saysmy/p/5626337.html)\n2.[MDN-FileReader](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader)\n3.[MDN-createObjectURL](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL)\n","slug":"Js上传图片本地预览几种姿势","published":1,"updated":"2019-09-25T15:10:25.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91og001rla2e5kdpq8uy","content":"<blockquote>\n<p>本主要总结前端开发中图片上传预览的几个方法 <strong> FileReader </strong> 和 <strong> URL.createObjectURL() </strong></p>\n</blockquote>\n<h2 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h2><p>1.什么是filereader？</p>\n<blockquote>\n<p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 —MDN</p>\n</blockquote>\n<p>看下怎么利用它来简单的实现一个图片预览</p>\n<pre><code class=\"html\">&lt;input type=&quot;file&quot; id=&quot;input&quot;&gt;\n</code></pre>\n<pre><code class=\"js\">/**\n*   @param {dom} StringOrObject input元素\n*   @param {fn} Function 回调函数 返回bs64 file\n*/\n\nconst imagePreview = function(dom,fn){\n    if(typeof dom === &#39;string&#39;){\n        dom = document.querySelector(dom)\n    }\n    const bindEv = function(){\n        // 这里默认单图上传\n        const file = this.files[0]\n        const reader = new FileReader()\n        reader.onload = function(ev){\n            // 这里得到的是base64图片编码\n            const bs64 = ev.target.result\n            // 返回给回调函数\n            fn &amp;&amp; fn(bs64,file)\n        }\n        // 读取指定的file文件，读取完毕后，在onload事件里面 result属性将返回base64URL\n        reader.readAsDataURL(file)\n    }\n\n    dom.addEventListener(&#39;change&#39;,bindEv,false)\n}\n</code></pre>\n<pre><code class=\"js\">imagePreview(&#39;#input&#39;,function(src,file){\n    // src 就是base64图片 可进行预览操作\n    //.file 为文件 可在此处进行上传操作\n    const img = document.createElement(&#39;img&#39;)\n    img.src = src\n    document.body.appendChild(img)\n    console.log(src)\n    console.log(file)\n})\n</code></pre>\n<p><strong> readAsDataURL: </strong></p>\n<blockquote>\n<p>开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.</p>\n</blockquote>\n<h2 id=\"FileReader的问题\"><a href=\"#FileReader的问题\" class=\"headerlink\" title=\"FileReader的问题\"></a>FileReader的问题</h2><ul>\n<li>兼容性</li>\n<li>一些安卓5.0系统以下的bug</li>\n</ul>\n<p><strong> 兼容后面再解决，先着重解决下第二个问题 </strong><br><img src=\"http://oq4hkch8e.bkt.clouddn.com/bs64-filereader-bug-fix.png\" alt=\"\"></p>\n<pre><code class=\"js\">/**\n*   正常的图片应该是\n*   data:image/gif;data:image/png;;data:image/jpeg;data:image/x-icon;\n*   而在Android的一些5.0系统以下(如4.0)的设备中,\n*   有些返回的b64字符串缺少关键image/gif标识,所以需要手动加上\n*/\n\nconst imagePreview = function(dom,fn){\n    if(typeof dom === &#39;string&#39;){\n        dom = document.querySelector(dom)\n    }\n    // 增加一个类型判断函数\n    const isType = function(name,type){\n        return name.indexOf(type) &gt; -1\n    }\n    const bindEv = function(){\n        // 这里默认单图上传\n        const file = this.files[0]\n        const reader = new FileReader()\n        reader.onload = function(ev){\n            let bs64 = ev.target.result\n            if(bs64 &amp;&amp; bs64.indexOf(&#39;data:base64,&#39;) &gt; -1){\n                // 去除旧有的错误头部\n                bs64 = bs64.replace(/data:base64,/,&#39;&#39;)\n                // 声明一个空字符用来保存下面判断的类型\n                // 通过name后缀进行识别标注\n                let typeFile = &#39;&#39;,\n                    name = file.name.toLowerCase();\n                if(name &amp;&amp; isType(name,&#39;.png&#39;)){\n                    typeFile = &#39;image/png;&#39;\n                }\n                if(name &amp;&amp; isType(name,&#39;.jpg&#39;)){\n                    typeFile = &#39;image/jpeg;&#39;\n                }\n                if(name &amp;&amp; isType(name,&#39;.gif&#39;)){\n                    typeFile = &#39;image/gif;&#39;\n                }\n                if(name &amp;&amp; isType(name,&#39;.icon&#39;)){\n                    typeFile = &#39;image/x-icon;&#39;\n                }\n                bs64 = &#39;data:&#39;+typeFile+&#39;base64,&#39;+bs64\n            }\n            fn &amp;&amp; fn(bs64,file)\n        }\n        reader.readAsDataURL(file)\n    }\n\n    dom.addEventListener(&#39;change&#39;,bindEv,false)\n}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>Firefox</th>\n<th>Chrome</th>\n<th>Internet Explorer*</th>\n<th>Opera</th>\n<th>Safari</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3.6</td>\n<td>7</td>\n<td>10</td>\n<td>未实现</td>\n<td>未实现</td>\n</tr>\n</tbody>\n</table>\n<p>下面我们来看下另一种方法</p>\n<h2 id=\"URL-createObjectURL\"><a href=\"#URL-createObjectURL\" class=\"headerlink\" title=\"URL.createObjectURL()\"></a>URL.createObjectURL()</h2><blockquote>\n<p>在每次调用 createObjectURL() 方法时，都会创建一个新的 URL对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们</p>\n</blockquote>\n<pre><code class=\"js\">// 语法:\n// 参数：blob\n// 是用来创建 URL 的 File 对象或者 Blob 对象​\nobjectURL = URL.createObjectURL(blob);\n</code></pre>\n<pre><code class=\"js\">const imagePreview = function(dom,fn){\n    if(typeof dom === &#39;string&#39;){\n        dom = document.querySelector(dom)\n    }\n    // 处理下兼容\n    window.URL = window.URL || window.webkitURL\n    const bindEv = function(){\n        const file = this.files[0]\n        const bs64 = window.URL.createObjectURL(file)\n        const img = document.createElement(&quot;img&quot;)\n        img.src = bs64\n        img.onload = function(){\n            window.URL.revokeObjectURL(this.src)\n        }\n        fn &amp;&amp; fn(bs64, file)\n    }\n    dom.addEventListener(&#39;change&#39;,bindEv,false)\n}\n</code></pre>\n<pre><code class=\"js\">imagePreview(&#39;#input&#39;,function(src,file){\n    // src 就是blog对象 可进行预览操作\n    // blob:null/6436b315-7d42-46e7-b447-a1a982048e61\n    //.file 为文件 可在此处进行上传操作\n    const img = document.createElement(&#39;img&#39;)\n    img.src = src\n    document.body.appendChild(img)\n    console.log(src)\n    console.log(file)\n})\n</code></pre>\n<p>在现代浏览器中，支持度还是不错的：</p>\n<table>\n<thead>\n<tr>\n<th>Firefox</th>\n<th>Chrome</th>\n<th>Internet Explorer*</th>\n<th>Opera</th>\n<th>Safari(WebKit)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3.6</td>\n<td>7</td>\n<td>10</td>\n<td>15</td>\n<td>6 [1]</td>\n</tr>\n</tbody>\n</table>\n<p>[1] 通过 webkitURL 前缀对象实现。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>1.<a href=\"https://www.cnblogs.com/saysmy/p/5626337.html\" target=\"_blank\" rel=\"external\">图片引用</a><br>2.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\" target=\"_blank\" rel=\"external\">MDN-FileReader</a><br>3.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL\" target=\"_blank\" rel=\"external\">MDN-createObjectURL</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本主要总结前端开发中图片上传预览的几个方法 <strong> FileReader </strong> 和 <strong> URL.createObjectURL() </strong></p>\n</blockquote>\n<h2 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h2><p>1.什么是filereader？</p>\n<blockquote>\n<p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 —MDN</p>\n</blockquote>\n<p>看下怎么利用它来简单的实现一个图片预览</p>\n<pre><code class=\"html\">&lt;input type=&quot;file&quot; id=&quot;input&quot;&gt;\n</code></pre>\n<pre><code class=\"js\">/**\n*   @param {dom} StringOrObject input元素\n*   @param {fn} Function 回调函数 返回bs64 file\n*/\n\nconst imagePreview = function(dom,fn){\n    if(typeof dom === &#39;string&#39;){\n        dom = document.querySelector(dom)\n    }\n    const bindEv = function(){\n        // 这里默认单图上传\n        const file = this.files[0]\n        const reader = new FileReader()\n        reader.onload = function(ev){\n            // 这里得到的是base64图片编码\n            const bs64 = ev.target.result\n            // 返回给回调函数\n            fn &amp;&amp; fn(bs64,file)\n        }\n        // 读取指定的file文件，读取完毕后，在onload事件里面 result属性将返回base64URL\n        reader.readAsDataURL(file)\n    }\n\n    dom.addEventListener(&#39;change&#39;,bindEv,false)\n}\n</code></pre>\n<pre><code class=\"js\">imagePreview(&#39;#input&#39;,function(src,file){\n    // src 就是base64图片 可进行预览操作\n    //.file 为文件 可在此处进行上传操作\n    const img = document.createElement(&#39;img&#39;)\n    img.src = src\n    document.body.appendChild(img)\n    console.log(src)\n    console.log(file)\n})\n</code></pre>\n<p><strong> readAsDataURL: </strong></p>\n<blockquote>\n<p>开始读取指定的Blob对象或File对象中的内容. 当读取操作完成时,readyState属性的值会成为DONE,如果设置了onloadend事件处理程序,则调用之.同时,result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容.</p>\n</blockquote>\n<h2 id=\"FileReader的问题\"><a href=\"#FileReader的问题\" class=\"headerlink\" title=\"FileReader的问题\"></a>FileReader的问题</h2><ul>\n<li>兼容性</li>\n<li>一些安卓5.0系统以下的bug</li>\n</ul>\n<p><strong> 兼容后面再解决，先着重解决下第二个问题 </strong><br><img src=\"http://oq4hkch8e.bkt.clouddn.com/bs64-filereader-bug-fix.png\" alt=\"\"></p>\n<pre><code class=\"js\">/**\n*   正常的图片应该是\n*   data:image/gif;data:image/png;;data:image/jpeg;data:image/x-icon;\n*   而在Android的一些5.0系统以下(如4.0)的设备中,\n*   有些返回的b64字符串缺少关键image/gif标识,所以需要手动加上\n*/\n\nconst imagePreview = function(dom,fn){\n    if(typeof dom === &#39;string&#39;){\n        dom = document.querySelector(dom)\n    }\n    // 增加一个类型判断函数\n    const isType = function(name,type){\n        return name.indexOf(type) &gt; -1\n    }\n    const bindEv = function(){\n        // 这里默认单图上传\n        const file = this.files[0]\n        const reader = new FileReader()\n        reader.onload = function(ev){\n            let bs64 = ev.target.result\n            if(bs64 &amp;&amp; bs64.indexOf(&#39;data:base64,&#39;) &gt; -1){\n                // 去除旧有的错误头部\n                bs64 = bs64.replace(/data:base64,/,&#39;&#39;)\n                // 声明一个空字符用来保存下面判断的类型\n                // 通过name后缀进行识别标注\n                let typeFile = &#39;&#39;,\n                    name = file.name.toLowerCase();\n                if(name &amp;&amp; isType(name,&#39;.png&#39;)){\n                    typeFile = &#39;image/png;&#39;\n                }\n                if(name &amp;&amp; isType(name,&#39;.jpg&#39;)){\n                    typeFile = &#39;image/jpeg;&#39;\n                }\n                if(name &amp;&amp; isType(name,&#39;.gif&#39;)){\n                    typeFile = &#39;image/gif;&#39;\n                }\n                if(name &amp;&amp; isType(name,&#39;.icon&#39;)){\n                    typeFile = &#39;image/x-icon;&#39;\n                }\n                bs64 = &#39;data:&#39;+typeFile+&#39;base64,&#39;+bs64\n            }\n            fn &amp;&amp; fn(bs64,file)\n        }\n        reader.readAsDataURL(file)\n    }\n\n    dom.addEventListener(&#39;change&#39;,bindEv,false)\n}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>Firefox</th>\n<th>Chrome</th>\n<th>Internet Explorer*</th>\n<th>Opera</th>\n<th>Safari</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3.6</td>\n<td>7</td>\n<td>10</td>\n<td>未实现</td>\n<td>未实现</td>\n</tr>\n</tbody>\n</table>\n<p>下面我们来看下另一种方法</p>\n<h2 id=\"URL-createObjectURL\"><a href=\"#URL-createObjectURL\" class=\"headerlink\" title=\"URL.createObjectURL()\"></a>URL.createObjectURL()</h2><blockquote>\n<p>在每次调用 createObjectURL() 方法时，都会创建一个新的 URL对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法来释放。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们</p>\n</blockquote>\n<pre><code class=\"js\">// 语法:\n// 参数：blob\n// 是用来创建 URL 的 File 对象或者 Blob 对象​\nobjectURL = URL.createObjectURL(blob);\n</code></pre>\n<pre><code class=\"js\">const imagePreview = function(dom,fn){\n    if(typeof dom === &#39;string&#39;){\n        dom = document.querySelector(dom)\n    }\n    // 处理下兼容\n    window.URL = window.URL || window.webkitURL\n    const bindEv = function(){\n        const file = this.files[0]\n        const bs64 = window.URL.createObjectURL(file)\n        const img = document.createElement(&quot;img&quot;)\n        img.src = bs64\n        img.onload = function(){\n            window.URL.revokeObjectURL(this.src)\n        }\n        fn &amp;&amp; fn(bs64, file)\n    }\n    dom.addEventListener(&#39;change&#39;,bindEv,false)\n}\n</code></pre>\n<pre><code class=\"js\">imagePreview(&#39;#input&#39;,function(src,file){\n    // src 就是blog对象 可进行预览操作\n    // blob:null/6436b315-7d42-46e7-b447-a1a982048e61\n    //.file 为文件 可在此处进行上传操作\n    const img = document.createElement(&#39;img&#39;)\n    img.src = src\n    document.body.appendChild(img)\n    console.log(src)\n    console.log(file)\n})\n</code></pre>\n<p>在现代浏览器中，支持度还是不错的：</p>\n<table>\n<thead>\n<tr>\n<th>Firefox</th>\n<th>Chrome</th>\n<th>Internet Explorer*</th>\n<th>Opera</th>\n<th>Safari(WebKit)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3.6</td>\n<td>7</td>\n<td>10</td>\n<td>15</td>\n<td>6 [1]</td>\n</tr>\n</tbody>\n</table>\n<p>[1] 通过 webkitURL 前缀对象实现。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>1.<a href=\"https://www.cnblogs.com/saysmy/p/5626337.html\" target=\"_blank\" rel=\"external\">图片引用</a><br>2.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\" target=\"_blank\" rel=\"external\">MDN-FileReader</a><br>3.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL\" target=\"_blank\" rel=\"external\">MDN-createObjectURL</a></p>\n"},{"title":"Jquery操作select下拉框值","date":"2017-08-15T16:36:00.000Z","author":"LoadingMore","_content":"## 前言\n> 最近项目中操作select的option值得场景还是很多的，在此记录一下,以免忘记\n\n## 结构\n```html\n<select id=\"selected\">\n    <option value=\"1\" data-id=\"1000\"></option>\n    <option value=\"2\" data-id=\"1001\"></option>\n    <option value=\"3\" data-id=\"1002\"></option>\n    <option value=\"4\" data-id=\"1003\"></option>\n</select>\n```\n## 操作\n```js\n// change事件中进行操作\n$('#selected').on('change',function(){\n    // 获取被选中的option 自定义属性\n    var selectedOpt = $('#selected').find('option:selected').attr('data-id')\n\n    //获取下拉框选中项的value属性值\n    var selectedVal = $('#selected').val()\n\n    //获取下拉框选中项的index属性值\n    var selectedIndex = $(\"#selected\").get(0).selectedIndex\n\n    console.log(selectedIndex)\n})\n\n//设置下拉框值为4的option选中\nfunction setOpt(){\n    $('#selected option[value=4]').attr('selected','selected')\n}\n// setOpt()\n\n//在下拉框最后添加一个选项\nfunction addOpt(){\n    $('#selected').append('<option value=\"5\" data-id=\"1004\">蘑菇云</option>')\n}\n// addOpt()\n\n//移除下拉框最后一个选项\nfunction removeLastOpt(){\n    $('#selected option:last').remove()\n}\n// removeLastOpt()\n\n// 获取最后一个下拉框自定义属性值\nvar selectMaxIndex = $(\"#selected option:last\").attr(\"data-id\");\n```\n","source":"_posts/Jquery操作select下拉框值.md","raw":"---\ntitle: Jquery操作select下拉框值\ndate: 2017-08-16 00:36:00\ntags: [Jquery,'select']\nauthor: \"LoadingMore\"\n---\n## 前言\n> 最近项目中操作select的option值得场景还是很多的，在此记录一下,以免忘记\n\n## 结构\n```html\n<select id=\"selected\">\n    <option value=\"1\" data-id=\"1000\"></option>\n    <option value=\"2\" data-id=\"1001\"></option>\n    <option value=\"3\" data-id=\"1002\"></option>\n    <option value=\"4\" data-id=\"1003\"></option>\n</select>\n```\n## 操作\n```js\n// change事件中进行操作\n$('#selected').on('change',function(){\n    // 获取被选中的option 自定义属性\n    var selectedOpt = $('#selected').find('option:selected').attr('data-id')\n\n    //获取下拉框选中项的value属性值\n    var selectedVal = $('#selected').val()\n\n    //获取下拉框选中项的index属性值\n    var selectedIndex = $(\"#selected\").get(0).selectedIndex\n\n    console.log(selectedIndex)\n})\n\n//设置下拉框值为4的option选中\nfunction setOpt(){\n    $('#selected option[value=4]').attr('selected','selected')\n}\n// setOpt()\n\n//在下拉框最后添加一个选项\nfunction addOpt(){\n    $('#selected').append('<option value=\"5\" data-id=\"1004\">蘑菇云</option>')\n}\n// addOpt()\n\n//移除下拉框最后一个选项\nfunction removeLastOpt(){\n    $('#selected option:last').remove()\n}\n// removeLastOpt()\n\n// 获取最后一个下拉框自定义属性值\nvar selectMaxIndex = $(\"#selected option:last\").attr(\"data-id\");\n```\n","slug":"Jquery操作select下拉框值","published":1,"updated":"2019-09-25T15:10:25.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91oh001vla2e7l37fhu5","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>最近项目中操作select的option值得场景还是很多的，在此记录一下,以免忘记</p>\n</blockquote>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><pre><code class=\"html\">&lt;select id=&quot;selected&quot;&gt;\n    &lt;option value=&quot;1&quot; data-id=&quot;1000&quot;&gt;&lt;/option&gt;\n    &lt;option value=&quot;2&quot; data-id=&quot;1001&quot;&gt;&lt;/option&gt;\n    &lt;option value=&quot;3&quot; data-id=&quot;1002&quot;&gt;&lt;/option&gt;\n    &lt;option value=&quot;4&quot; data-id=&quot;1003&quot;&gt;&lt;/option&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><pre><code class=\"js\">// change事件中进行操作\n$(&#39;#selected&#39;).on(&#39;change&#39;,function(){\n    // 获取被选中的option 自定义属性\n    var selectedOpt = $(&#39;#selected&#39;).find(&#39;option:selected&#39;).attr(&#39;data-id&#39;)\n\n    //获取下拉框选中项的value属性值\n    var selectedVal = $(&#39;#selected&#39;).val()\n\n    //获取下拉框选中项的index属性值\n    var selectedIndex = $(&quot;#selected&quot;).get(0).selectedIndex\n\n    console.log(selectedIndex)\n})\n\n//设置下拉框值为4的option选中\nfunction setOpt(){\n    $(&#39;#selected option[value=4]&#39;).attr(&#39;selected&#39;,&#39;selected&#39;)\n}\n// setOpt()\n\n//在下拉框最后添加一个选项\nfunction addOpt(){\n    $(&#39;#selected&#39;).append(&#39;&lt;option value=&quot;5&quot; data-id=&quot;1004&quot;&gt;蘑菇云&lt;/option&gt;&#39;)\n}\n// addOpt()\n\n//移除下拉框最后一个选项\nfunction removeLastOpt(){\n    $(&#39;#selected option:last&#39;).remove()\n}\n// removeLastOpt()\n\n// 获取最后一个下拉框自定义属性值\nvar selectMaxIndex = $(&quot;#selected option:last&quot;).attr(&quot;data-id&quot;);\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>最近项目中操作select的option值得场景还是很多的，在此记录一下,以免忘记</p>\n</blockquote>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><pre><code class=\"html\">&lt;select id=&quot;selected&quot;&gt;\n    &lt;option value=&quot;1&quot; data-id=&quot;1000&quot;&gt;&lt;/option&gt;\n    &lt;option value=&quot;2&quot; data-id=&quot;1001&quot;&gt;&lt;/option&gt;\n    &lt;option value=&quot;3&quot; data-id=&quot;1002&quot;&gt;&lt;/option&gt;\n    &lt;option value=&quot;4&quot; data-id=&quot;1003&quot;&gt;&lt;/option&gt;\n&lt;/select&gt;\n</code></pre>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><pre><code class=\"js\">// change事件中进行操作\n$(&#39;#selected&#39;).on(&#39;change&#39;,function(){\n    // 获取被选中的option 自定义属性\n    var selectedOpt = $(&#39;#selected&#39;).find(&#39;option:selected&#39;).attr(&#39;data-id&#39;)\n\n    //获取下拉框选中项的value属性值\n    var selectedVal = $(&#39;#selected&#39;).val()\n\n    //获取下拉框选中项的index属性值\n    var selectedIndex = $(&quot;#selected&quot;).get(0).selectedIndex\n\n    console.log(selectedIndex)\n})\n\n//设置下拉框值为4的option选中\nfunction setOpt(){\n    $(&#39;#selected option[value=4]&#39;).attr(&#39;selected&#39;,&#39;selected&#39;)\n}\n// setOpt()\n\n//在下拉框最后添加一个选项\nfunction addOpt(){\n    $(&#39;#selected&#39;).append(&#39;&lt;option value=&quot;5&quot; data-id=&quot;1004&quot;&gt;蘑菇云&lt;/option&gt;&#39;)\n}\n// addOpt()\n\n//移除下拉框最后一个选项\nfunction removeLastOpt(){\n    $(&#39;#selected option:last&#39;).remove()\n}\n// removeLastOpt()\n\n// 获取最后一个下拉框自定义属性值\nvar selectMaxIndex = $(&quot;#selected option:last&quot;).attr(&quot;data-id&quot;);\n</code></pre>\n"},{"title":"Js模仿块级作用域与ES6块级作用域","date":"2016-12-22T15:13:49.000Z","_content":">最近接触ES6多了起来，感觉自己之前js的基础还没有多牢固，趁着下班时间，着手温习下高程3，今天看到块级作用域这块，索性就把刚学一点的ES6做个比较，看异同，现学现卖了。\n\n## 前传\nES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n<!-- more -->\n## 为什么需要块级作用域（ES5实现方式）？ \n**第一种场景，用来计数的循环变量泄露为全局变量。**\n```javascript\nfunction outputNums(count){\n\tfor(var i=0;i<count;i++){\n\t\tconsole.log(i);// 0 1 2 3 4 5 6\n\t}\n\tconsole.log(i); //7\n}\noutputNums(7)\n```\n该函数定义了for循环，变量i初始值为0，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。在Javascript中，变量i是定义在outputNums()的活动对象中，因此函数内部可以随处访问。  \n* 解决方法：匿名函数可以用来模仿块级作用域\n```javascript\n(function(){\n\t//这里是块级作用域\n})()\n\n以上立即执行函数相当于\nvar func = function(){\n\t//这里是块级作用域\n};\nfunc();\n```\n定义一个匿名函数，立即调用它，调用方式是在函数名字后面添加一对圆括号，即**func()**;  \n如果省去变量直接加()呢？  \n```javascript\nfunction(){\n\t//这里是块级作用域\n}()；//报错\n```\n因为JavaScript将function关键字当做一个函数声明的开始，而声明后面不能跟圆括号，然而表达式后面可以跟圆括号，将函数声明转化为函数表达式，只需如下：\n```javascript\n(function(){\n\t//这里是块级作用域\n})()；\n```\n改写后：\n```javascript\nfunction outputNums(count){\n\t(function(){\n\t\tfor(var i=0;i<count;i++){\n\t\t\tconsole.log(i);// 0 1 2 3 4 5 6\n\t\t}\n\t})()；\n\tconsole.log(i); //报错\n}\noutputNums(7)\n```\n我们在for循环外面加了一个私有作用域，在匿名函数定义的任何变量，都会在执行结束时销毁，因此i只能在循环中使用，使用后即被销毁，在私有作用域中可以访问变量count，是因为匿名函数是一个闭包，可以访问包含作用域中的所有变量。\n举个例子：\n```javascript\n(function(){\n\tvar nowDate = new Date();\n\tif(nowDate.getMonth == 0 && nowDate.getDate == 1){\n\t\talert(\"新年快乐！\");\n\t}\n})()\n```\n上面这段代码，会在阳历一月一日，弹出新年祝福！在多人开发团队合作中，通过创建私有作用域，每个开发人员既可以使用自己的变量，也不用担心弄乱全局作用域。\n\n**第二种场景，内层变量可能会覆盖外层变量。**\n```javascript\nvar nowDate = new Date();\nfunction func(){\n\tconsole.log(nowDate);\n\tif(false){\n\t\tvar  nowDate = \"新年快乐\";\n\t}\n}\nfunc()//undefined\n```\n导致导致上面的结果原因是变量提升，导致内层nowDate覆盖外层nowDate；\n错误还原如下：\n```javascript\nvar nowDate = new Date();\nfunction func(){\n\tvar nowDate;\n\tconsole.log(nowDate);\n\tif(false){\n\t\tnowDate = \"新年快乐\";\n\t}\n}\nfunc()//undefined\n```\n## ES6的块级作用域 \n\n**let实际上为javascript增加了块级作用域**\n```javascript\nfunction func(){\n\tlet n = 5;\n\tif(true){\n\t\tlet n = 10;\n\t}\n\tconsole.log(n);//5\n}\n```\n上面两段代码都声明了n，运行后输出5，这表明外层代码不收内层代码的影响，如果用var 定义变量n，最后结果会输出10.\n- ES6允许块级作用域的任意嵌套。\n```javascript\n{{{{ let n = \"新年快乐\" }}}}\n```\n下面这段代码使用了四层的会计作用域，外层的作用域无法读取内层作用域。\n```javascript\n{{{\n\t{ let n = \"新年快乐\" }\n\tconsole.log(n);//报错\n}}}\n```\n内层作用域可以定义外层作用域的同名变量。\n```javascript\n{{{\n\tlet n = \"我是n\"\n\t{ let n = \"我也可以是n\" }\n\tconsole.log(n);//我是n\n}}}\n```\n## 展望下未来\n**块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。**\n```javascript\n// IIFE 写法\n(function () {\n  var nowDate = \"新年快乐\";\n  //...\n})();\n\n// 块级作用域写法\n{\n  let nowDate =\"新年快乐\";\n  //...\n}\n```\n结语：具体怎么用，还是得看支持的程度。 \n共勉！","source":"_posts/Js模仿块级作用域与ES6块级作用域.md","raw":"---\ntitle: Js模仿块级作用域与ES6块级作用域\ndate: 2016-12-22 23:13:49\ntags: [javascript]\ncategories: Javascript\n---\n>最近接触ES6多了起来，感觉自己之前js的基础还没有多牢固，趁着下班时间，着手温习下高程3，今天看到块级作用域这块，索性就把刚学一点的ES6做个比较，看异同，现学现卖了。\n\n## 前传\nES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。\n<!-- more -->\n## 为什么需要块级作用域（ES5实现方式）？ \n**第一种场景，用来计数的循环变量泄露为全局变量。**\n```javascript\nfunction outputNums(count){\n\tfor(var i=0;i<count;i++){\n\t\tconsole.log(i);// 0 1 2 3 4 5 6\n\t}\n\tconsole.log(i); //7\n}\noutputNums(7)\n```\n该函数定义了for循环，变量i初始值为0，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。在Javascript中，变量i是定义在outputNums()的活动对象中，因此函数内部可以随处访问。  \n* 解决方法：匿名函数可以用来模仿块级作用域\n```javascript\n(function(){\n\t//这里是块级作用域\n})()\n\n以上立即执行函数相当于\nvar func = function(){\n\t//这里是块级作用域\n};\nfunc();\n```\n定义一个匿名函数，立即调用它，调用方式是在函数名字后面添加一对圆括号，即**func()**;  \n如果省去变量直接加()呢？  \n```javascript\nfunction(){\n\t//这里是块级作用域\n}()；//报错\n```\n因为JavaScript将function关键字当做一个函数声明的开始，而声明后面不能跟圆括号，然而表达式后面可以跟圆括号，将函数声明转化为函数表达式，只需如下：\n```javascript\n(function(){\n\t//这里是块级作用域\n})()；\n```\n改写后：\n```javascript\nfunction outputNums(count){\n\t(function(){\n\t\tfor(var i=0;i<count;i++){\n\t\t\tconsole.log(i);// 0 1 2 3 4 5 6\n\t\t}\n\t})()；\n\tconsole.log(i); //报错\n}\noutputNums(7)\n```\n我们在for循环外面加了一个私有作用域，在匿名函数定义的任何变量，都会在执行结束时销毁，因此i只能在循环中使用，使用后即被销毁，在私有作用域中可以访问变量count，是因为匿名函数是一个闭包，可以访问包含作用域中的所有变量。\n举个例子：\n```javascript\n(function(){\n\tvar nowDate = new Date();\n\tif(nowDate.getMonth == 0 && nowDate.getDate == 1){\n\t\talert(\"新年快乐！\");\n\t}\n})()\n```\n上面这段代码，会在阳历一月一日，弹出新年祝福！在多人开发团队合作中，通过创建私有作用域，每个开发人员既可以使用自己的变量，也不用担心弄乱全局作用域。\n\n**第二种场景，内层变量可能会覆盖外层变量。**\n```javascript\nvar nowDate = new Date();\nfunction func(){\n\tconsole.log(nowDate);\n\tif(false){\n\t\tvar  nowDate = \"新年快乐\";\n\t}\n}\nfunc()//undefined\n```\n导致导致上面的结果原因是变量提升，导致内层nowDate覆盖外层nowDate；\n错误还原如下：\n```javascript\nvar nowDate = new Date();\nfunction func(){\n\tvar nowDate;\n\tconsole.log(nowDate);\n\tif(false){\n\t\tnowDate = \"新年快乐\";\n\t}\n}\nfunc()//undefined\n```\n## ES6的块级作用域 \n\n**let实际上为javascript增加了块级作用域**\n```javascript\nfunction func(){\n\tlet n = 5;\n\tif(true){\n\t\tlet n = 10;\n\t}\n\tconsole.log(n);//5\n}\n```\n上面两段代码都声明了n，运行后输出5，这表明外层代码不收内层代码的影响，如果用var 定义变量n，最后结果会输出10.\n- ES6允许块级作用域的任意嵌套。\n```javascript\n{{{{ let n = \"新年快乐\" }}}}\n```\n下面这段代码使用了四层的会计作用域，外层的作用域无法读取内层作用域。\n```javascript\n{{{\n\t{ let n = \"新年快乐\" }\n\tconsole.log(n);//报错\n}}}\n```\n内层作用域可以定义外层作用域的同名变量。\n```javascript\n{{{\n\tlet n = \"我是n\"\n\t{ let n = \"我也可以是n\" }\n\tconsole.log(n);//我是n\n}}}\n```\n## 展望下未来\n**块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。**\n```javascript\n// IIFE 写法\n(function () {\n  var nowDate = \"新年快乐\";\n  //...\n})();\n\n// 块级作用域写法\n{\n  let nowDate =\"新年快乐\";\n  //...\n}\n```\n结语：具体怎么用，还是得看支持的程度。 \n共勉！","slug":"Js模仿块级作用域与ES6块级作用域","published":1,"updated":"2019-09-25T15:10:25.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91oi001yla2eq6vthf2n","content":"<blockquote>\n<p>最近接触ES6多了起来，感觉自己之前js的基础还没有多牢固，趁着下班时间，着手温习下高程3，今天看到块级作用域这块，索性就把刚学一点的ES6做个比较，看异同，现学现卖了。</p>\n</blockquote>\n<h2 id=\"前传\"><a href=\"#前传\" class=\"headerlink\" title=\"前传\"></a>前传</h2><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br><a id=\"more\"></a></p>\n<h2 id=\"为什么需要块级作用域（ES5实现方式）？\"><a href=\"#为什么需要块级作用域（ES5实现方式）？\" class=\"headerlink\" title=\"为什么需要块级作用域（ES5实现方式）？\"></a>为什么需要块级作用域（ES5实现方式）？</h2><p><strong>第一种场景，用来计数的循环变量泄露为全局变量。</strong></p>\n<pre><code class=\"javascript\">function outputNums(count){\n    for(var i=0;i&lt;count;i++){\n        console.log(i);// 0 1 2 3 4 5 6\n    }\n    console.log(i); //7\n}\noutputNums(7)\n</code></pre>\n<p>该函数定义了for循环，变量i初始值为0，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。在Javascript中，变量i是定义在outputNums()的活动对象中，因此函数内部可以随处访问。  </p>\n<ul>\n<li>解决方法：匿名函数可以用来模仿块级作用域<br>```javascript<br>(function(){<br>  //这里是块级作用域<br>})()</li>\n</ul>\n<p>以上立即执行函数相当于<br>var func = function(){<br>    //这里是块级作用域<br>};<br>func();</p>\n<pre><code>定义一个匿名函数，立即调用它，调用方式是在函数名字后面添加一对圆括号，即**func()**;  \n如果省去变量直接加()呢？  \n```javascript\nfunction(){\n    //这里是块级作用域\n}()；//报错\n</code></pre><p>因为JavaScript将function关键字当做一个函数声明的开始，而声明后面不能跟圆括号，然而表达式后面可以跟圆括号，将函数声明转化为函数表达式，只需如下：</p>\n<pre><code class=\"javascript\">(function(){\n    //这里是块级作用域\n})()；\n</code></pre>\n<p>改写后：</p>\n<pre><code class=\"javascript\">function outputNums(count){\n    (function(){\n        for(var i=0;i&lt;count;i++){\n            console.log(i);// 0 1 2 3 4 5 6\n        }\n    })()；\n    console.log(i); //报错\n}\noutputNums(7)\n</code></pre>\n<p>我们在for循环外面加了一个私有作用域，在匿名函数定义的任何变量，都会在执行结束时销毁，因此i只能在循环中使用，使用后即被销毁，在私有作用域中可以访问变量count，是因为匿名函数是一个闭包，可以访问包含作用域中的所有变量。<br>举个例子：</p>\n<pre><code class=\"javascript\">(function(){\n    var nowDate = new Date();\n    if(nowDate.getMonth == 0 &amp;&amp; nowDate.getDate == 1){\n        alert(&quot;新年快乐！&quot;);\n    }\n})()\n</code></pre>\n<p>上面这段代码，会在阳历一月一日，弹出新年祝福！在多人开发团队合作中，通过创建私有作用域，每个开发人员既可以使用自己的变量，也不用担心弄乱全局作用域。</p>\n<p><strong>第二种场景，内层变量可能会覆盖外层变量。</strong></p>\n<pre><code class=\"javascript\">var nowDate = new Date();\nfunction func(){\n    console.log(nowDate);\n    if(false){\n        var  nowDate = &quot;新年快乐&quot;;\n    }\n}\nfunc()//undefined\n</code></pre>\n<p>导致导致上面的结果原因是变量提升，导致内层nowDate覆盖外层nowDate；<br>错误还原如下：</p>\n<pre><code class=\"javascript\">var nowDate = new Date();\nfunction func(){\n    var nowDate;\n    console.log(nowDate);\n    if(false){\n        nowDate = &quot;新年快乐&quot;;\n    }\n}\nfunc()//undefined\n</code></pre>\n<h2 id=\"ES6的块级作用域\"><a href=\"#ES6的块级作用域\" class=\"headerlink\" title=\"ES6的块级作用域\"></a>ES6的块级作用域</h2><p><strong>let实际上为javascript增加了块级作用域</strong></p>\n<pre><code class=\"javascript\">function func(){\n    let n = 5;\n    if(true){\n        let n = 10;\n    }\n    console.log(n);//5\n}\n</code></pre>\n<p>上面两段代码都声明了n，运行后输出5，这表明外层代码不收内层代码的影响，如果用var 定义变量n，最后结果会输出10.</p>\n<ul>\n<li>ES6允许块级作用域的任意嵌套。<pre><code class=\"javascript\">{{{{ let n = \"新年快乐\" }}}}\n</code></pre>\n下面这段代码使用了四层的会计作用域，外层的作用域无法读取内层作用域。<pre><code class=\"javascript\">{{{\n\t{ let n = \"新年快乐\" }\n\tconsole.log(n);//报错\n}}}\n</code></pre>\n内层作用域可以定义外层作用域的同名变量。<pre><code class=\"javascript\">{{{\n\tlet n = \"我是n\"\n\t{ let n = \"我也可以是n\" }\n\tconsole.log(n);//我是n\n}}}\n</code></pre>\n<h2 id=\"展望下未来\"><a href=\"#展望下未来\" class=\"headerlink\" title=\"展望下未来\"></a>展望下未来</h2><strong>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</strong><br>```javascript<br>// IIFE 写法<br>(function () {<br>var nowDate = “新年快乐”;<br>//…<br>})();</li>\n</ul>\n<p>// 块级作用域写法<br>{<br>  let nowDate =”新年快乐”;<br>  //…<br>}<br>```<br>结语：具体怎么用，还是得看支持的程度。<br>共勉！</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近接触ES6多了起来，感觉自己之前js的基础还没有多牢固，趁着下班时间，着手温习下高程3，今天看到块级作用域这块，索性就把刚学一点的ES6做个比较，看异同，现学现卖了。</p>\n</blockquote>\n<h2 id=\"前传\"><a href=\"#前传\" class=\"headerlink\" title=\"前传\"></a>前传</h2><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。<br>","more":"</p>\n<h2 id=\"为什么需要块级作用域（ES5实现方式）？\"><a href=\"#为什么需要块级作用域（ES5实现方式）？\" class=\"headerlink\" title=\"为什么需要块级作用域（ES5实现方式）？\"></a>为什么需要块级作用域（ES5实现方式）？</h2><p><strong>第一种场景，用来计数的循环变量泄露为全局变量。</strong></p>\n<pre><code class=\"javascript\">function outputNums(count){\n    for(var i=0;i&lt;count;i++){\n        console.log(i);// 0 1 2 3 4 5 6\n    }\n    console.log(i); //7\n}\noutputNums(7)\n</code></pre>\n<p>该函数定义了for循环，变量i初始值为0，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。在Javascript中，变量i是定义在outputNums()的活动对象中，因此函数内部可以随处访问。  </p>\n<ul>\n<li>解决方法：匿名函数可以用来模仿块级作用域<br>```javascript<br>(function(){<br>  //这里是块级作用域<br>})()</li>\n</ul>\n<p>以上立即执行函数相当于<br>var func = function(){<br>    //这里是块级作用域<br>};<br>func();</p>\n<pre><code>定义一个匿名函数，立即调用它，调用方式是在函数名字后面添加一对圆括号，即**func()**;  \n如果省去变量直接加()呢？  \n```javascript\nfunction(){\n    //这里是块级作用域\n}()；//报错\n</code></pre><p>因为JavaScript将function关键字当做一个函数声明的开始，而声明后面不能跟圆括号，然而表达式后面可以跟圆括号，将函数声明转化为函数表达式，只需如下：</p>\n<pre><code class=\"javascript\">(function(){\n    //这里是块级作用域\n})()；\n</code></pre>\n<p>改写后：</p>\n<pre><code class=\"javascript\">function outputNums(count){\n    (function(){\n        for(var i=0;i&lt;count;i++){\n            console.log(i);// 0 1 2 3 4 5 6\n        }\n    })()；\n    console.log(i); //报错\n}\noutputNums(7)\n</code></pre>\n<p>我们在for循环外面加了一个私有作用域，在匿名函数定义的任何变量，都会在执行结束时销毁，因此i只能在循环中使用，使用后即被销毁，在私有作用域中可以访问变量count，是因为匿名函数是一个闭包，可以访问包含作用域中的所有变量。<br>举个例子：</p>\n<pre><code class=\"javascript\">(function(){\n    var nowDate = new Date();\n    if(nowDate.getMonth == 0 &amp;&amp; nowDate.getDate == 1){\n        alert(&quot;新年快乐！&quot;);\n    }\n})()\n</code></pre>\n<p>上面这段代码，会在阳历一月一日，弹出新年祝福！在多人开发团队合作中，通过创建私有作用域，每个开发人员既可以使用自己的变量，也不用担心弄乱全局作用域。</p>\n<p><strong>第二种场景，内层变量可能会覆盖外层变量。</strong></p>\n<pre><code class=\"javascript\">var nowDate = new Date();\nfunction func(){\n    console.log(nowDate);\n    if(false){\n        var  nowDate = &quot;新年快乐&quot;;\n    }\n}\nfunc()//undefined\n</code></pre>\n<p>导致导致上面的结果原因是变量提升，导致内层nowDate覆盖外层nowDate；<br>错误还原如下：</p>\n<pre><code class=\"javascript\">var nowDate = new Date();\nfunction func(){\n    var nowDate;\n    console.log(nowDate);\n    if(false){\n        nowDate = &quot;新年快乐&quot;;\n    }\n}\nfunc()//undefined\n</code></pre>\n<h2 id=\"ES6的块级作用域\"><a href=\"#ES6的块级作用域\" class=\"headerlink\" title=\"ES6的块级作用域\"></a>ES6的块级作用域</h2><p><strong>let实际上为javascript增加了块级作用域</strong></p>\n<pre><code class=\"javascript\">function func(){\n    let n = 5;\n    if(true){\n        let n = 10;\n    }\n    console.log(n);//5\n}\n</code></pre>\n<p>上面两段代码都声明了n，运行后输出5，这表明外层代码不收内层代码的影响，如果用var 定义变量n，最后结果会输出10.</p>\n<ul>\n<li>ES6允许块级作用域的任意嵌套。<pre><code class=\"javascript\">{{{{ let n = \"新年快乐\" }}}}\n</code></pre>\n下面这段代码使用了四层的会计作用域，外层的作用域无法读取内层作用域。<pre><code class=\"javascript\">{{{\n\t{ let n = \"新年快乐\" }\n\tconsole.log(n);//报错\n}}}\n</code></pre>\n内层作用域可以定义外层作用域的同名变量。<pre><code class=\"javascript\">{{{\n\tlet n = \"我是n\"\n\t{ let n = \"我也可以是n\" }\n\tconsole.log(n);//我是n\n}}}\n</code></pre>\n<h2 id=\"展望下未来\"><a href=\"#展望下未来\" class=\"headerlink\" title=\"展望下未来\"></a>展望下未来</h2><strong>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</strong><br>```javascript<br>// IIFE 写法<br>(function () {<br>var nowDate = “新年快乐”;<br>//…<br>})();</li>\n</ul>\n<p>// 块级作用域写法<br>{<br>  let nowDate =”新年快乐”;<br>  //…<br>}<br>```<br>结语：具体怎么用，还是得看支持的程度。<br>共勉！</p>"},{"title":"Python爬虫框架scrapy安装报错解决办法","date":"2017-04-12T13:16:23.000Z","_content":"> 最近尝试入门python,接触这门语言的目的很明确,就是爬虫,用来爬取数据,我对数据一直抱有神秘感，很感兴趣，所以闲暇之余,开始入门python,它大名鼎鼎的爬虫框架scrapy自然躲不过我的搜索,所以安装测试,于是便开始了这篇踩坑文章\n\n<!-- more -->\n### 报错原因\n![][1]\n我的报错原因就是如图中所示: ** error: Unable to find vcvarsall.bat**\n网上也收了很多解决办法,但都是不但可行，对于初学者我来学还是蛮吃力,最终看到有篇帖子说是因为缺少c++一些环境变量引起的,安装Visual Studio 2015可以结局问题,所以网上找了个简版安装包,已经共享在了百度云盘:\n** [我是下载链接][2]**\n\n### 安装步骤\n勾选如下几项即可\n![][3]\n\n安装完毕后关闭即可;\n\n这个时候在命令行里:\n** pip install scrapy **\n这个时候基本上会顺利的安装完毕了\n[1]: http://oiukswkar.bkt.clouddn.com/scrapy-error.png\n[2]: http://pan.baidu.com/s/1pLTpCTl\n[3]: http://oiukswkar.bkt.clouddn.com/visul.png\n","source":"_posts/Python爬虫框架scrapy安装报错解决办法.md","raw":"---\ntitle: Python爬虫框架scrapy安装报错解决办法\ndate: 2017-04-12 21:16:23\ntags: [python,'scrapy']\ncategories: Python\n---\n> 最近尝试入门python,接触这门语言的目的很明确,就是爬虫,用来爬取数据,我对数据一直抱有神秘感，很感兴趣，所以闲暇之余,开始入门python,它大名鼎鼎的爬虫框架scrapy自然躲不过我的搜索,所以安装测试,于是便开始了这篇踩坑文章\n\n<!-- more -->\n### 报错原因\n![][1]\n我的报错原因就是如图中所示: ** error: Unable to find vcvarsall.bat**\n网上也收了很多解决办法,但都是不但可行，对于初学者我来学还是蛮吃力,最终看到有篇帖子说是因为缺少c++一些环境变量引起的,安装Visual Studio 2015可以结局问题,所以网上找了个简版安装包,已经共享在了百度云盘:\n** [我是下载链接][2]**\n\n### 安装步骤\n勾选如下几项即可\n![][3]\n\n安装完毕后关闭即可;\n\n这个时候在命令行里:\n** pip install scrapy **\n这个时候基本上会顺利的安装完毕了\n[1]: http://oiukswkar.bkt.clouddn.com/scrapy-error.png\n[2]: http://pan.baidu.com/s/1pLTpCTl\n[3]: http://oiukswkar.bkt.clouddn.com/visul.png\n","slug":"Python爬虫框架scrapy安装报错解决办法","published":1,"updated":"2019-09-25T15:10:25.210Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ol0022la2e5el5j3o9","content":"<blockquote>\n<p>最近尝试入门python,接触这门语言的目的很明确,就是爬虫,用来爬取数据,我对数据一直抱有神秘感，很感兴趣，所以闲暇之余,开始入门python,它大名鼎鼎的爬虫框架scrapy自然躲不过我的搜索,所以安装测试,于是便开始了这篇踩坑文章</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"报错原因\"><a href=\"#报错原因\" class=\"headerlink\" title=\"报错原因\"></a>报错原因</h3><p><img src=\"http://oiukswkar.bkt.clouddn.com/scrapy-error.png\" alt=\"\"><br>我的报错原因就是如图中所示: <strong> error: Unable to find vcvarsall.bat</strong><br>网上也收了很多解决办法,但都是不但可行，对于初学者我来学还是蛮吃力,最终看到有篇帖子说是因为缺少c++一些环境变量引起的,安装Visual Studio 2015可以结局问题,所以网上找了个简版安装包,已经共享在了百度云盘:<br><strong> <a href=\"http://pan.baidu.com/s/1pLTpCTl\" target=\"_blank\" rel=\"external\">我是下载链接</a></strong></p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><p>勾选如下几项即可<br><img src=\"http://oiukswkar.bkt.clouddn.com/visul.png\" alt=\"\"></p>\n<p>安装完毕后关闭即可;</p>\n<p>这个时候在命令行里:<br><strong> pip install scrapy </strong><br>这个时候基本上会顺利的安装完毕了</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近尝试入门python,接触这门语言的目的很明确,就是爬虫,用来爬取数据,我对数据一直抱有神秘感，很感兴趣，所以闲暇之余,开始入门python,它大名鼎鼎的爬虫框架scrapy自然躲不过我的搜索,所以安装测试,于是便开始了这篇踩坑文章</p>\n</blockquote>","more":"<h3 id=\"报错原因\"><a href=\"#报错原因\" class=\"headerlink\" title=\"报错原因\"></a>报错原因</h3><p><img src=\"http://oiukswkar.bkt.clouddn.com/scrapy-error.png\" alt=\"\"><br>我的报错原因就是如图中所示: <strong> error: Unable to find vcvarsall.bat</strong><br>网上也收了很多解决办法,但都是不但可行，对于初学者我来学还是蛮吃力,最终看到有篇帖子说是因为缺少c++一些环境变量引起的,安装Visual Studio 2015可以结局问题,所以网上找了个简版安装包,已经共享在了百度云盘:<br><strong> <a href=\"http://pan.baidu.com/s/1pLTpCTl\" target=\"_blank\" rel=\"external\">我是下载链接</a></strong></p>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><p>勾选如下几项即可<br><img src=\"http://oiukswkar.bkt.clouddn.com/visul.png\" alt=\"\"></p>\n<p>安装完毕后关闭即可;</p>\n<p>这个时候在命令行里:<br><strong> pip install scrapy </strong><br>这个时候基本上会顺利的安装完毕了</p>"},{"title":"VSCode打开多tab页","date":"2019-10-12T15:52:16.000Z","_content":"\n> 安装的vscode每次打开新的文件，前一次打开的就被覆盖掉了，很是抓狂，好在官方提供的配置开关.\n\n## 设置\n```js\n\"workbench.editor.showTabs\": true\n```\n\n在设置里搜索`workbench.editor.showTabs`即可看到开关按钮","source":"_posts/VSCode打开多tab页.md","raw":"---\ntitle: VSCode打开多tab页\ndate: 2019-10-12 23:52:16\ntags: [vscode, VSCode]\ncategories: VSCode\n---\n\n> 安装的vscode每次打开新的文件，前一次打开的就被覆盖掉了，很是抓狂，好在官方提供的配置开关.\n\n## 设置\n```js\n\"workbench.editor.showTabs\": true\n```\n\n在设置里搜索`workbench.editor.showTabs`即可看到开关按钮","slug":"VSCode打开多tab页","published":1,"updated":"2019-10-19T00:03:25.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91om0025la2e1kk3wgh6","content":"<blockquote>\n<p>安装的vscode每次打开新的文件，前一次打开的就被覆盖掉了，很是抓狂，好在官方提供的配置开关.</p>\n</blockquote>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><pre><code class=\"js\">&quot;workbench.editor.showTabs&quot;: true\n</code></pre>\n<p>在设置里搜索<code>workbench.editor.showTabs</code>即可看到开关按钮</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>安装的vscode每次打开新的文件，前一次打开的就被覆盖掉了，很是抓狂，好在官方提供的配置开关.</p>\n</blockquote>\n<h2 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h2><pre><code class=\"js\">&quot;workbench.editor.showTabs&quot;: true\n</code></pre>\n<p>在设置里搜索<code>workbench.editor.showTabs</code>即可看到开关按钮</p>\n"},{"title":"React Native 常见错误总结","date":"2016-12-21T11:58:16.000Z","_content":"> 随着RN的不断深入学习，遇到的坑也越来越多，错误也千奇百怪，自己就本着自己遇到的，和网上查询，总结为一篇博文，以备查阅，本文会持续更新...\n\n<!-- more -->\n## <font color=\"#FF0000\">错误1：Element type is invalid…: </font>\n错误描述:\nElement type is invalid: expected a String(for built-in components) or a class/function(for composite components) but got:object. check the render method of ‘….’\n<font color=\"limegreen\">错误分析： </font>\n这个错误是很不容易发现的原因是由于ES5语法和ES6语法混乱搭配导致的。比如用ES6 导出 用ES5导入, 就可能会产生上述错误.\n- - -\n## <font color=\"#FF0000\">错误2：cannot call a class as a function </font>\n<font color=\"limegreen\">错误分析： </font>\n这种错误一般都是手误导致的, 错误直译就是不能调用一个类作为一个函数。比如组件的单词写错。\n- - -\n## <font color=\"#FF0000\">错误3： invariant violation:expected a component class,got[object object] </font>\n<font color=\"limegreen\">错误分析： </font>\n创建自定义组件首字母要大写，否则会报错.\n- - -\n## <font color=\"#FF0000\">错误4：Module 0 is not a registered callable module.</font>\n<font color=\"limegreen\">错误分析： </font>\n 将gradle升级成最新版本(cdAndroid 进入android目录执行:sudo./gradlew clean) 或者通过android studio工具升级.\n- - -\n## <font color=\"#FF0000\">错误5：Element type is invalid: expected a string (for built-in components) or a class/function but got: object</font>\n<font color=\"limegreen\">错误分析： </font>\n 发生原因一般是你引用了无效的组件，如果组件确实正确，看下引用的组件是否正常导出：（export defalut）\n- - -\n## <font color=\"#FF0000\">错误6：react native  undefined is not an object (evaluating this....</font>\n<font color=\"limegreen\">错误分析： </font>\n  发生该错误的一般是忘记bind(this),只要回调函数中需要用到this的，一般都需要bind.\n- - -\n## <font color=\"#FF0000\">错误7：react native - expected a component class, got [object Object]</font>\n<font color=\"limegreen\">错误分析： </font>\n该错误可能是你引用了小写的组件，组件首字母一定要大写，比如<login/>应该写成<Login/>\n- - -\n## <font color=\"#FF0000\">错误8：使用ListView时报错：Sticky header index 0 was outside the range {...}</font>\n<font color=\"limegreen\">错误分析： </font>\n看起来是个数组越界错误，但多数情况下是由于ListView的子组件渲染错误（如套数据时没有检查undefined等）引起，而非ListView本身的问题。\n- - -\n## <font color=\"#FF0000\">错误9：使用Image时报错：You are trying to render the global Image variable as a React element. You probably forgot to require Image.</font>\n<font color=\"limegreen\">错误分析： </font>\n由于React的Image组件和全局的Image对象重名，所以使用Image组件时一定要记得在文件开头正确引入React的Image组件。\n- - -\n## <font color=\"#FF0000\">错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间</font>\n<font color=\"limegreen\">错误分析： </font>\n将automaticallyAdjustContentInsets属性设为{false}.\n- - -\n## <font color=\"#FF0000\">错误11：报错：Adjacent JSX elements must be wrapped in an enclosing tag.</font>\n<font color=\"limegreen\">错误分析： </font>\nrender方法中必须只能包含一个根元素。\n- - -\n## <font color=\"#FF0000\">错误12：报错：Invariant Violation: onlyChild must be passed a children with exactly one child</font>\n<font color=\"limegreen\">错误分析： </font>\n一般是Touchable开头的几个组件，如果没有子元素或者指定多个并列子元素都会报错。\n- - -\n## <font color=\"#FF0000\">错误13：报错：Invariant Violation: onlyChild must be passed a children with exactly one child</font>\n<font color=\"limegreen\">错误分析： </font>\n一般是Touchable开头的几个组件，如果没有子元素或者指定多个并列子元素都会报错。\n- - -\n## <font color=\"#FF0000\">错误14：报错：null is not an object (evaluating 'this.state.xxx')</font>\n<font color=\"limegreen\">错误分析： </font>\nES6的初始化需要把初始化的对象放在Constructor方法中，而不是放在getInitialState中；而如果是采用的是React.createClass的话就是可以把初始化放在getInitialState之中\n- - -\n## <font color=\"#FF0000\">错误15：React Native(RN)启动不成功,unable to download js bundle错误解决方案</font>\n<font color=\"limegreen\">错误分析： </font>\n.首先需要设置IP和端口，默认端口是8081，手机(模拟器)和电脑在同一个网络中，查询电脑的IP地址  \n.最后重点  Android项目关闭终端重新执行运行命令，iOS项目也需要关闭服务终端,重新启动packager\n- - -\n## <font color=\"#FF0000\">错误16：WebStorm不识别React Native语法解决方案</font>\n<font color=\"limegreen\">解决办法： </font>\n遇到这个问题还是比较简单，只需要开启JSX语法支持即可，具体解决方案如下:\nPreferences -> Languages and Frameworks -> JavaScript -> language version下拉框里选JSX Harmony\n- - -\n## <font color=\"#FF0000\">错误17：com.android.ddmlib.InstallException: Unable to upload some APKs解决方案</font>\n魅族 Meizu m2 note / 魅族 Meizu MX4 / 华为 Huawei Mate 7 / 华为 Huawei P8 / 小米 Redmi Note 2 / 乐视 Letv X500 无法安装以上手机安装apk时, 可能会报一个 com.android.ddmlib.InstallException: Unable to upload some APKs,\n<font color=\"limegreen\">解决办法： </font>\n 我们需要修改如下几个位置:  \n\n需要将 android/build.gradle 里的 gradle:1.3.1 改为 gradle:1.2.3\n需要将 android/gradle/wrapper/gradle-wrapper.properties里的 distributionUrl 版本改为gradle-2.2-all.zip\n- - -\n","source":"_posts/React-Native-常见错误总结.md","raw":"---\ntitle: React Native 常见错误总结\ndate: 2016-12-21 19:58:16\ntags: [React,React-native]\ncategories: React\n---\n> 随着RN的不断深入学习，遇到的坑也越来越多，错误也千奇百怪，自己就本着自己遇到的，和网上查询，总结为一篇博文，以备查阅，本文会持续更新...\n\n<!-- more -->\n## <font color=\"#FF0000\">错误1：Element type is invalid…: </font>\n错误描述:\nElement type is invalid: expected a String(for built-in components) or a class/function(for composite components) but got:object. check the render method of ‘….’\n<font color=\"limegreen\">错误分析： </font>\n这个错误是很不容易发现的原因是由于ES5语法和ES6语法混乱搭配导致的。比如用ES6 导出 用ES5导入, 就可能会产生上述错误.\n- - -\n## <font color=\"#FF0000\">错误2：cannot call a class as a function </font>\n<font color=\"limegreen\">错误分析： </font>\n这种错误一般都是手误导致的, 错误直译就是不能调用一个类作为一个函数。比如组件的单词写错。\n- - -\n## <font color=\"#FF0000\">错误3： invariant violation:expected a component class,got[object object] </font>\n<font color=\"limegreen\">错误分析： </font>\n创建自定义组件首字母要大写，否则会报错.\n- - -\n## <font color=\"#FF0000\">错误4：Module 0 is not a registered callable module.</font>\n<font color=\"limegreen\">错误分析： </font>\n 将gradle升级成最新版本(cdAndroid 进入android目录执行:sudo./gradlew clean) 或者通过android studio工具升级.\n- - -\n## <font color=\"#FF0000\">错误5：Element type is invalid: expected a string (for built-in components) or a class/function but got: object</font>\n<font color=\"limegreen\">错误分析： </font>\n 发生原因一般是你引用了无效的组件，如果组件确实正确，看下引用的组件是否正常导出：（export defalut）\n- - -\n## <font color=\"#FF0000\">错误6：react native  undefined is not an object (evaluating this....</font>\n<font color=\"limegreen\">错误分析： </font>\n  发生该错误的一般是忘记bind(this),只要回调函数中需要用到this的，一般都需要bind.\n- - -\n## <font color=\"#FF0000\">错误7：react native - expected a component class, got [object Object]</font>\n<font color=\"limegreen\">错误分析： </font>\n该错误可能是你引用了小写的组件，组件首字母一定要大写，比如<login/>应该写成<Login/>\n- - -\n## <font color=\"#FF0000\">错误8：使用ListView时报错：Sticky header index 0 was outside the range {...}</font>\n<font color=\"limegreen\">错误分析： </font>\n看起来是个数组越界错误，但多数情况下是由于ListView的子组件渲染错误（如套数据时没有检查undefined等）引起，而非ListView本身的问题。\n- - -\n## <font color=\"#FF0000\">错误9：使用Image时报错：You are trying to render the global Image variable as a React element. You probably forgot to require Image.</font>\n<font color=\"limegreen\">错误分析： </font>\n由于React的Image组件和全局的Image对象重名，所以使用Image组件时一定要记得在文件开头正确引入React的Image组件。\n- - -\n## <font color=\"#FF0000\">错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间</font>\n<font color=\"limegreen\">错误分析： </font>\n将automaticallyAdjustContentInsets属性设为{false}.\n- - -\n## <font color=\"#FF0000\">错误11：报错：Adjacent JSX elements must be wrapped in an enclosing tag.</font>\n<font color=\"limegreen\">错误分析： </font>\nrender方法中必须只能包含一个根元素。\n- - -\n## <font color=\"#FF0000\">错误12：报错：Invariant Violation: onlyChild must be passed a children with exactly one child</font>\n<font color=\"limegreen\">错误分析： </font>\n一般是Touchable开头的几个组件，如果没有子元素或者指定多个并列子元素都会报错。\n- - -\n## <font color=\"#FF0000\">错误13：报错：Invariant Violation: onlyChild must be passed a children with exactly one child</font>\n<font color=\"limegreen\">错误分析： </font>\n一般是Touchable开头的几个组件，如果没有子元素或者指定多个并列子元素都会报错。\n- - -\n## <font color=\"#FF0000\">错误14：报错：null is not an object (evaluating 'this.state.xxx')</font>\n<font color=\"limegreen\">错误分析： </font>\nES6的初始化需要把初始化的对象放在Constructor方法中，而不是放在getInitialState中；而如果是采用的是React.createClass的话就是可以把初始化放在getInitialState之中\n- - -\n## <font color=\"#FF0000\">错误15：React Native(RN)启动不成功,unable to download js bundle错误解决方案</font>\n<font color=\"limegreen\">错误分析： </font>\n.首先需要设置IP和端口，默认端口是8081，手机(模拟器)和电脑在同一个网络中，查询电脑的IP地址  \n.最后重点  Android项目关闭终端重新执行运行命令，iOS项目也需要关闭服务终端,重新启动packager\n- - -\n## <font color=\"#FF0000\">错误16：WebStorm不识别React Native语法解决方案</font>\n<font color=\"limegreen\">解决办法： </font>\n遇到这个问题还是比较简单，只需要开启JSX语法支持即可，具体解决方案如下:\nPreferences -> Languages and Frameworks -> JavaScript -> language version下拉框里选JSX Harmony\n- - -\n## <font color=\"#FF0000\">错误17：com.android.ddmlib.InstallException: Unable to upload some APKs解决方案</font>\n魅族 Meizu m2 note / 魅族 Meizu MX4 / 华为 Huawei Mate 7 / 华为 Huawei P8 / 小米 Redmi Note 2 / 乐视 Letv X500 无法安装以上手机安装apk时, 可能会报一个 com.android.ddmlib.InstallException: Unable to upload some APKs,\n<font color=\"limegreen\">解决办法： </font>\n 我们需要修改如下几个位置:  \n\n需要将 android/build.gradle 里的 gradle:1.3.1 改为 gradle:1.2.3\n需要将 android/gradle/wrapper/gradle-wrapper.properties里的 distributionUrl 版本改为gradle-2.2-all.zip\n- - -\n","slug":"React-Native-常见错误总结","published":1,"updated":"2019-09-25T15:10:25.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91on002ala2ev802kwwc","content":"<blockquote>\n<p>随着RN的不断深入学习，遇到的坑也越来越多，错误也千奇百怪，自己就本着自己遇到的，和网上查询，总结为一篇博文，以备查阅，本文会持续更新…</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"错误1：Element-type-is-invalid…\"><a href=\"#错误1：Element-type-is-invalid…\" class=\"headerlink\" title=\"错误1：Element type is invalid…: \"></a><font color=\"#FF0000\">错误1：Element type is invalid…: </font></h2><p>错误描述:<br>Element type is invalid: expected a String(for built-in components) or a class/function(for composite components) but got:object. check the render method of ‘….’</p>\n<p><font color=\"limegreen\">错误分析： </font><br>这个错误是很不容易发现的原因是由于ES5语法和ES6语法混乱搭配导致的。比如用ES6 导出 用ES5导入, 就可能会产生上述错误.</p>\n<hr>\n<h2 id=\"错误2：cannot-call-a-class-as-a-function\"><a href=\"#错误2：cannot-call-a-class-as-a-function\" class=\"headerlink\" title=\"错误2：cannot call a class as a function \"></a><font color=\"#FF0000\">错误2：cannot call a class as a function </font></h2><p><font color=\"limegreen\">错误分析： </font><br>这种错误一般都是手误导致的, 错误直译就是不能调用一个类作为一个函数。比如组件的单词写错。</p>\n<hr>\n<h2 id=\"错误3：-invariant-violation-expected-a-component-class-got-object-object\"><a href=\"#错误3：-invariant-violation-expected-a-component-class-got-object-object\" class=\"headerlink\" title=\"错误3： invariant violation:expected a component class,got[object object] \"></a><font color=\"#FF0000\">错误3： invariant violation:expected a component class,got[object object] </font></h2><p><font color=\"limegreen\">错误分析： </font><br>创建自定义组件首字母要大写，否则会报错.</p>\n<hr>\n<h2 id=\"错误4：Module-0-is-not-a-registered-callable-module\"><a href=\"#错误4：Module-0-is-not-a-registered-callable-module\" class=\"headerlink\" title=\"错误4：Module 0 is not a registered callable module.\"></a><font color=\"#FF0000\">错误4：Module 0 is not a registered callable module.</font></h2><p><font color=\"limegreen\">错误分析： </font><br> 将gradle升级成最新版本(cdAndroid 进入android目录执行:sudo./gradlew clean) 或者通过android studio工具升级.</p>\n<hr>\n<h2 id=\"错误5：Element-type-is-invalid-expected-a-string-for-built-in-components-or-a-class-function-but-got-object\"><a href=\"#错误5：Element-type-is-invalid-expected-a-string-for-built-in-components-or-a-class-function-but-got-object\" class=\"headerlink\" title=\"错误5：Element type is invalid: expected a string (for built-in components) or a class/function but got: object\"></a><font color=\"#FF0000\">错误5：Element type is invalid: expected a string (for built-in components) or a class/function but got: object</font></h2><p><font color=\"limegreen\">错误分析： </font><br> 发生原因一般是你引用了无效的组件，如果组件确实正确，看下引用的组件是否正常导出：（export defalut）</p>\n<hr>\n<h2 id=\"错误6：react-native-undefined-is-not-an-object-evaluating-this…\"><a href=\"#错误6：react-native-undefined-is-not-an-object-evaluating-this…\" class=\"headerlink\" title=\"错误6：react native  undefined is not an object (evaluating this….\"></a><font color=\"#FF0000\">错误6：react native  undefined is not an object (evaluating this….</font></h2><p><font color=\"limegreen\">错误分析： </font><br>  发生该错误的一般是忘记bind(this),只要回调函数中需要用到this的，一般都需要bind.</p>\n<hr>\n<h2 id=\"错误7：react-native-expected-a-component-class-got-object-Object\"><a href=\"#错误7：react-native-expected-a-component-class-got-object-Object\" class=\"headerlink\" title=\"错误7：react native - expected a component class, got [object Object]\"></a><font color=\"#FF0000\">错误7：react native - expected a component class, got [object Object]</font></h2><p><font color=\"limegreen\">错误分析： </font><br>该错误可能是你引用了小写的组件，组件首字母一定要大写，比如<login>应该写成<login></login></login></p>\n<hr>\n<h2 id=\"错误8：使用ListView时报错：Sticky-header-index-0-was-outside-the-range-…\"><a href=\"#错误8：使用ListView时报错：Sticky-header-index-0-was-outside-the-range-…\" class=\"headerlink\" title=\"错误8：使用ListView时报错：Sticky header index 0 was outside the range {…}\"></a><font color=\"#FF0000\">错误8：使用ListView时报错：Sticky header index 0 was outside the range {…}</font></h2><p><font color=\"limegreen\">错误分析： </font><br>看起来是个数组越界错误，但多数情况下是由于ListView的子组件渲染错误（如套数据时没有检查undefined等）引起，而非ListView本身的问题。</p>\n<hr>\n<h2 id=\"错误9：使用Image时报错：You-are-trying-to-render-the-global-Image-variable-as-a-React-element-You-probably-forgot-to-require-Image\"><a href=\"#错误9：使用Image时报错：You-are-trying-to-render-the-global-Image-variable-as-a-React-element-You-probably-forgot-to-require-Image\" class=\"headerlink\" title=\"错误9：使用Image时报错：You are trying to render the global Image variable as a React element. You probably forgot to require Image.\"></a><font color=\"#FF0000\">错误9：使用Image时报错：You are trying to render the global Image variable as a React element. You probably forgot to require Image.</font></h2><p><font color=\"limegreen\">错误分析： </font><br>由于React的Image组件和全局的Image对象重名，所以使用Image组件时一定要记得在文件开头正确引入React的Image组件。</p>\n<hr>\n<h2 id=\"错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间\"><a href=\"#错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间\" class=\"headerlink\" title=\"错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间\"></a><font color=\"#FF0000\">错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间</font></h2><p><font color=\"limegreen\">错误分析： </font><br>将automaticallyAdjustContentInsets属性设为{false}.</p>\n<hr>\n<h2 id=\"错误11：报错：Adjacent-JSX-elements-must-be-wrapped-in-an-enclosing-tag\"><a href=\"#错误11：报错：Adjacent-JSX-elements-must-be-wrapped-in-an-enclosing-tag\" class=\"headerlink\" title=\"错误11：报错：Adjacent JSX elements must be wrapped in an enclosing tag.\"></a><font color=\"#FF0000\">错误11：报错：Adjacent JSX elements must be wrapped in an enclosing tag.</font></h2><p><font color=\"limegreen\">错误分析： </font><br>render方法中必须只能包含一个根元素。</p>\n<hr>\n<h2 id=\"错误12：报错：Invariant-Violation-onlyChild-must-be-passed-a-children-with-exactly-one-child\"><a href=\"#错误12：报错：Invariant-Violation-onlyChild-must-be-passed-a-children-with-exactly-one-child\" class=\"headerlink\" title=\"错误12：报错：Invariant Violation: onlyChild must be passed a children with exactly one child\"></a><font color=\"#FF0000\">错误12：报错：Invariant Violation: onlyChild must be passed a children with exactly one child</font></h2><p><font color=\"limegreen\">错误分析： </font><br>一般是Touchable开头的几个组件，如果没有子元素或者指定多个并列子元素都会报错。</p>\n<hr>\n<h2 id=\"错误13：报错：Invariant-Violation-onlyChild-must-be-passed-a-children-with-exactly-one-child\"><a href=\"#错误13：报错：Invariant-Violation-onlyChild-must-be-passed-a-children-with-exactly-one-child\" class=\"headerlink\" title=\"错误13：报错：Invariant Violation: onlyChild must be passed a children with exactly one child\"></a><font color=\"#FF0000\">错误13：报错：Invariant Violation: onlyChild must be passed a children with exactly one child</font></h2><p><font color=\"limegreen\">错误分析： </font><br>一般是Touchable开头的几个组件，如果没有子元素或者指定多个并列子元素都会报错。</p>\n<hr>\n<h2 id=\"错误14：报错：null-is-not-an-object-evaluating-‘this-state-xxx’\"><a href=\"#错误14：报错：null-is-not-an-object-evaluating-‘this-state-xxx’\" class=\"headerlink\" title=\"错误14：报错：null is not an object (evaluating ‘this.state.xxx’)\"></a><font color=\"#FF0000\">错误14：报错：null is not an object (evaluating ‘this.state.xxx’)</font></h2><p><font color=\"limegreen\">错误分析： </font><br>ES6的初始化需要把初始化的对象放在Constructor方法中，而不是放在getInitialState中；而如果是采用的是React.createClass的话就是可以把初始化放在getInitialState之中</p>\n<hr>\n<h2 id=\"错误15：React-Native-RN-启动不成功-unable-to-download-js-bundle错误解决方案\"><a href=\"#错误15：React-Native-RN-启动不成功-unable-to-download-js-bundle错误解决方案\" class=\"headerlink\" title=\"错误15：React Native(RN)启动不成功,unable to download js bundle错误解决方案\"></a><font color=\"#FF0000\">错误15：React Native(RN)启动不成功,unable to download js bundle错误解决方案</font></h2><p><font color=\"limegreen\">错误分析： </font><br>.首先需要设置IP和端口，默认端口是8081，手机(模拟器)和电脑在同一个网络中，查询电脑的IP地址<br>.最后重点  Android项目关闭终端重新执行运行命令，iOS项目也需要关闭服务终端,重新启动packager</p>\n<hr>\n<h2 id=\"错误16：WebStorm不识别React-Native语法解决方案\"><a href=\"#错误16：WebStorm不识别React-Native语法解决方案\" class=\"headerlink\" title=\"错误16：WebStorm不识别React Native语法解决方案\"></a><font color=\"#FF0000\">错误16：WebStorm不识别React Native语法解决方案</font></h2><p><font color=\"limegreen\">解决办法： </font><br>遇到这个问题还是比较简单，只需要开启JSX语法支持即可，具体解决方案如下:<br>Preferences -&gt; Languages and Frameworks -&gt; JavaScript -&gt; language version下拉框里选JSX Harmony</p>\n<hr>\n<h2 id=\"错误17：com-android-ddmlib-InstallException-Unable-to-upload-some-APKs解决方案\"><a href=\"#错误17：com-android-ddmlib-InstallException-Unable-to-upload-some-APKs解决方案\" class=\"headerlink\" title=\"错误17：com.android.ddmlib.InstallException: Unable to upload some APKs解决方案\"></a><font color=\"#FF0000\">错误17：com.android.ddmlib.InstallException: Unable to upload some APKs解决方案</font></h2><p>魅族 Meizu m2 note / 魅族 Meizu MX4 / 华为 Huawei Mate 7 / 华为 Huawei P8 / 小米 Redmi Note 2 / 乐视 Letv X500 无法安装以上手机安装apk时, 可能会报一个 com.android.ddmlib.InstallException: Unable to upload some APKs,</p>\n<p><font color=\"limegreen\">解决办法： </font><br> 我们需要修改如下几个位置:  </p>\n<p>需要将 android/build.gradle 里的 gradle:1.3.1 改为 gradle:1.2.3<br>需要将 android/gradle/wrapper/gradle-wrapper.properties里的 distributionUrl 版本改为gradle-2.2-all.zip</p>\n<hr>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>随着RN的不断深入学习，遇到的坑也越来越多，错误也千奇百怪，自己就本着自己遇到的，和网上查询，总结为一篇博文，以备查阅，本文会持续更新…</p>\n</blockquote>","more":"<h2 id=\"错误1：Element-type-is-invalid…\"><a href=\"#错误1：Element-type-is-invalid…\" class=\"headerlink\" title=\"错误1：Element type is invalid…: \"></a><font color=\"#FF0000\">错误1：Element type is invalid…: </font></h2><p>错误描述:<br>Element type is invalid: expected a String(for built-in components) or a class/function(for composite components) but got:object. check the render method of ‘….’</p>\n<p><font color=\"limegreen\">错误分析： </font><br>这个错误是很不容易发现的原因是由于ES5语法和ES6语法混乱搭配导致的。比如用ES6 导出 用ES5导入, 就可能会产生上述错误.</p>\n<hr>\n<h2 id=\"错误2：cannot-call-a-class-as-a-function\"><a href=\"#错误2：cannot-call-a-class-as-a-function\" class=\"headerlink\" title=\"错误2：cannot call a class as a function \"></a><font color=\"#FF0000\">错误2：cannot call a class as a function </font></h2><p><font color=\"limegreen\">错误分析： </font><br>这种错误一般都是手误导致的, 错误直译就是不能调用一个类作为一个函数。比如组件的单词写错。</p>\n<hr>\n<h2 id=\"错误3：-invariant-violation-expected-a-component-class-got-object-object\"><a href=\"#错误3：-invariant-violation-expected-a-component-class-got-object-object\" class=\"headerlink\" title=\"错误3： invariant violation:expected a component class,got[object object] \"></a><font color=\"#FF0000\">错误3： invariant violation:expected a component class,got[object object] </font></h2><p><font color=\"limegreen\">错误分析： </font><br>创建自定义组件首字母要大写，否则会报错.</p>\n<hr>\n<h2 id=\"错误4：Module-0-is-not-a-registered-callable-module\"><a href=\"#错误4：Module-0-is-not-a-registered-callable-module\" class=\"headerlink\" title=\"错误4：Module 0 is not a registered callable module.\"></a><font color=\"#FF0000\">错误4：Module 0 is not a registered callable module.</font></h2><p><font color=\"limegreen\">错误分析： </font><br> 将gradle升级成最新版本(cdAndroid 进入android目录执行:sudo./gradlew clean) 或者通过android studio工具升级.</p>\n<hr>\n<h2 id=\"错误5：Element-type-is-invalid-expected-a-string-for-built-in-components-or-a-class-function-but-got-object\"><a href=\"#错误5：Element-type-is-invalid-expected-a-string-for-built-in-components-or-a-class-function-but-got-object\" class=\"headerlink\" title=\"错误5：Element type is invalid: expected a string (for built-in components) or a class/function but got: object\"></a><font color=\"#FF0000\">错误5：Element type is invalid: expected a string (for built-in components) or a class/function but got: object</font></h2><p><font color=\"limegreen\">错误分析： </font><br> 发生原因一般是你引用了无效的组件，如果组件确实正确，看下引用的组件是否正常导出：（export defalut）</p>\n<hr>\n<h2 id=\"错误6：react-native-undefined-is-not-an-object-evaluating-this…\"><a href=\"#错误6：react-native-undefined-is-not-an-object-evaluating-this…\" class=\"headerlink\" title=\"错误6：react native  undefined is not an object (evaluating this….\"></a><font color=\"#FF0000\">错误6：react native  undefined is not an object (evaluating this….</font></h2><p><font color=\"limegreen\">错误分析： </font><br>  发生该错误的一般是忘记bind(this),只要回调函数中需要用到this的，一般都需要bind.</p>\n<hr>\n<h2 id=\"错误7：react-native-expected-a-component-class-got-object-Object\"><a href=\"#错误7：react-native-expected-a-component-class-got-object-Object\" class=\"headerlink\" title=\"错误7：react native - expected a component class, got [object Object]\"></a><font color=\"#FF0000\">错误7：react native - expected a component class, got [object Object]</font></h2><p><font color=\"limegreen\">错误分析： </font><br>该错误可能是你引用了小写的组件，组件首字母一定要大写，比如<login>应该写成<login></login></login></p>\n<hr>\n<h2 id=\"错误8：使用ListView时报错：Sticky-header-index-0-was-outside-the-range-…\"><a href=\"#错误8：使用ListView时报错：Sticky-header-index-0-was-outside-the-range-…\" class=\"headerlink\" title=\"错误8：使用ListView时报错：Sticky header index 0 was outside the range {…}\"></a><font color=\"#FF0000\">错误8：使用ListView时报错：Sticky header index 0 was outside the range {…}</font></h2><p><font color=\"limegreen\">错误分析： </font><br>看起来是个数组越界错误，但多数情况下是由于ListView的子组件渲染错误（如套数据时没有检查undefined等）引起，而非ListView本身的问题。</p>\n<hr>\n<h2 id=\"错误9：使用Image时报错：You-are-trying-to-render-the-global-Image-variable-as-a-React-element-You-probably-forgot-to-require-Image\"><a href=\"#错误9：使用Image时报错：You-are-trying-to-render-the-global-Image-variable-as-a-React-element-You-probably-forgot-to-require-Image\" class=\"headerlink\" title=\"错误9：使用Image时报错：You are trying to render the global Image variable as a React element. You probably forgot to require Image.\"></a><font color=\"#FF0000\">错误9：使用Image时报错：You are trying to render the global Image variable as a React element. You probably forgot to require Image.</font></h2><p><font color=\"limegreen\">错误分析： </font><br>由于React的Image组件和全局的Image对象重名，所以使用Image组件时一定要记得在文件开头正确引入React的Image组件。</p>\n<hr>\n<h2 id=\"错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间\"><a href=\"#错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间\" class=\"headerlink\" title=\"错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间\"></a><font color=\"#FF0000\">错误10：在使用Navigator的同时使用ListView或ScrollView，后两者的头部会多出一些空间</font></h2><p><font color=\"limegreen\">错误分析： </font><br>将automaticallyAdjustContentInsets属性设为{false}.</p>\n<hr>\n<h2 id=\"错误11：报错：Adjacent-JSX-elements-must-be-wrapped-in-an-enclosing-tag\"><a href=\"#错误11：报错：Adjacent-JSX-elements-must-be-wrapped-in-an-enclosing-tag\" class=\"headerlink\" title=\"错误11：报错：Adjacent JSX elements must be wrapped in an enclosing tag.\"></a><font color=\"#FF0000\">错误11：报错：Adjacent JSX elements must be wrapped in an enclosing tag.</font></h2><p><font color=\"limegreen\">错误分析： </font><br>render方法中必须只能包含一个根元素。</p>\n<hr>\n<h2 id=\"错误12：报错：Invariant-Violation-onlyChild-must-be-passed-a-children-with-exactly-one-child\"><a href=\"#错误12：报错：Invariant-Violation-onlyChild-must-be-passed-a-children-with-exactly-one-child\" class=\"headerlink\" title=\"错误12：报错：Invariant Violation: onlyChild must be passed a children with exactly one child\"></a><font color=\"#FF0000\">错误12：报错：Invariant Violation: onlyChild must be passed a children with exactly one child</font></h2><p><font color=\"limegreen\">错误分析： </font><br>一般是Touchable开头的几个组件，如果没有子元素或者指定多个并列子元素都会报错。</p>\n<hr>\n<h2 id=\"错误13：报错：Invariant-Violation-onlyChild-must-be-passed-a-children-with-exactly-one-child\"><a href=\"#错误13：报错：Invariant-Violation-onlyChild-must-be-passed-a-children-with-exactly-one-child\" class=\"headerlink\" title=\"错误13：报错：Invariant Violation: onlyChild must be passed a children with exactly one child\"></a><font color=\"#FF0000\">错误13：报错：Invariant Violation: onlyChild must be passed a children with exactly one child</font></h2><p><font color=\"limegreen\">错误分析： </font><br>一般是Touchable开头的几个组件，如果没有子元素或者指定多个并列子元素都会报错。</p>\n<hr>\n<h2 id=\"错误14：报错：null-is-not-an-object-evaluating-‘this-state-xxx’\"><a href=\"#错误14：报错：null-is-not-an-object-evaluating-‘this-state-xxx’\" class=\"headerlink\" title=\"错误14：报错：null is not an object (evaluating ‘this.state.xxx’)\"></a><font color=\"#FF0000\">错误14：报错：null is not an object (evaluating ‘this.state.xxx’)</font></h2><p><font color=\"limegreen\">错误分析： </font><br>ES6的初始化需要把初始化的对象放在Constructor方法中，而不是放在getInitialState中；而如果是采用的是React.createClass的话就是可以把初始化放在getInitialState之中</p>\n<hr>\n<h2 id=\"错误15：React-Native-RN-启动不成功-unable-to-download-js-bundle错误解决方案\"><a href=\"#错误15：React-Native-RN-启动不成功-unable-to-download-js-bundle错误解决方案\" class=\"headerlink\" title=\"错误15：React Native(RN)启动不成功,unable to download js bundle错误解决方案\"></a><font color=\"#FF0000\">错误15：React Native(RN)启动不成功,unable to download js bundle错误解决方案</font></h2><p><font color=\"limegreen\">错误分析： </font><br>.首先需要设置IP和端口，默认端口是8081，手机(模拟器)和电脑在同一个网络中，查询电脑的IP地址<br>.最后重点  Android项目关闭终端重新执行运行命令，iOS项目也需要关闭服务终端,重新启动packager</p>\n<hr>\n<h2 id=\"错误16：WebStorm不识别React-Native语法解决方案\"><a href=\"#错误16：WebStorm不识别React-Native语法解决方案\" class=\"headerlink\" title=\"错误16：WebStorm不识别React Native语法解决方案\"></a><font color=\"#FF0000\">错误16：WebStorm不识别React Native语法解决方案</font></h2><p><font color=\"limegreen\">解决办法： </font><br>遇到这个问题还是比较简单，只需要开启JSX语法支持即可，具体解决方案如下:<br>Preferences -&gt; Languages and Frameworks -&gt; JavaScript -&gt; language version下拉框里选JSX Harmony</p>\n<hr>\n<h2 id=\"错误17：com-android-ddmlib-InstallException-Unable-to-upload-some-APKs解决方案\"><a href=\"#错误17：com-android-ddmlib-InstallException-Unable-to-upload-some-APKs解决方案\" class=\"headerlink\" title=\"错误17：com.android.ddmlib.InstallException: Unable to upload some APKs解决方案\"></a><font color=\"#FF0000\">错误17：com.android.ddmlib.InstallException: Unable to upload some APKs解决方案</font></h2><p>魅族 Meizu m2 note / 魅族 Meizu MX4 / 华为 Huawei Mate 7 / 华为 Huawei P8 / 小米 Redmi Note 2 / 乐视 Letv X500 无法安装以上手机安装apk时, 可能会报一个 com.android.ddmlib.InstallException: Unable to upload some APKs,</p>\n<p><font color=\"limegreen\">解决办法： </font><br> 我们需要修改如下几个位置:  </p>\n<p>需要将 android/build.gradle 里的 gradle:1.3.1 改为 gradle:1.2.3<br>需要将 android/gradle/wrapper/gradle-wrapper.properties里的 distributionUrl 版本改为gradle-2.2-all.zip</p>\n<hr>"},{"title":" Vue2.x开发Chrome插件记录","subtitle":"","date":"2017-06-04T13:37:58.000Z","author":"Yuqi Bi","header-img":"form-opts.png","cdn":"header-on","_content":"### 背景\n作为一名web开发者,对[Animate.css](https://daneden.github.io/animate.css/)这个动画库不会陌生,它把常见的动画都封装了起来，非常实用。但是有时候在开发中，仅仅只是需要某一两个动画效果，把整个CSS文件都引入，这样不是太好。\n<!-- more -->\n需求就出现了，能不能有一个工具可以直接预览Animate.css对应的动画效果，并且生成对应的动画代码呢？\n\n作为web开发者，平时跟Chrome浏览器打交道最多，于是就想着整一个Chrome插件可以及时预览对应Animate.css中的动画效果并生成对应的动画代码，这样在实际开发中碰到一些需要使用到Animate.css中的动画效果时，可以大大的提高我们的开发效率。\n\n插件如下图所示：\n![](http://oq4hkch8e.bkt.clouddn.com/prevcss.gif)\n** [插件下载地址](http://pan.baidu.com/s/1bpozy8J) **\n** [插件源码](https://github.com/BiYuqi/v-chrome) **\n** [web网页版本](http://loadingmore.com/web-prev-animate/) **\n### 开始\n** Chrome插件开发基本知识 **\n在应用商店中下载下来的插件基本上都是以.crx为文件后缀，该文件其实就是一个压缩包，包括插件所需要的html、css、javascript、图片资源等等文件。\n\n开发一个插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。\n\n比如我这个插件的目录文件如下：\n![](http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170604220601.png)\n\n** manifest.json文件 **\n文件中需要注意一下的mainfest.json(很重要)这个文件，这个json文件的作用是提供插件的各种信息，例如插件能够做的事情，以及插件的文件配置等等信息。下面是一个清单文件的示例：\n```js\n{\n    \"manifest_version\": 2,\n    \"name\": \"Prev CSS3 Animate\",\n    \"description\": \"Preview CSS3 animation effects\",\n    \"version\": \"1.0\",\n    \"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\",\n    \"permissions\": [\n        \"http://*/*\",\n        \"https://*/*\",\n        \"file:///*\"\n     ],\n    \"content_scripts\": [\n        {\n            \"matches\": [\n                \"http://*/*\",\n                \"file:///*/*\"\n            ],\n            \"css\": [\"dist/style.css\"]\n        }\n    ],\n    \"browser_action\": {\n        \"default_icon\": \"img/icon4.png\",\n        \"default_popup\": \"index.html\"\n    }\n}\n```\n第一行声明我们使用清单文件格式的版本 2，必须包含（版本 1 是旧的，已弃用，不建议使用）\n\n接下来的部分定义扩展程序的名称、描述与版本。这些都会在 Chrome 浏览器中使用，向用户显示已安装的扩展程序，同时在 Chrome 网上应用店中向潜在的新用户显示您的扩展程序。名称应该简练，描述不要比一句话左右还长\n\nbrowser_action 对应的是默认的logo(本文是icon4.png)以及文件入口(文本为index.html),这两个资源都必须在扩展程序包中存在，图片是扩展的显示，html是扩展具体运行的基础文件。\n\n### 功能实现\n整个插件的核心交互功能非常简单，如文章开头的动图所示，用户选择对相应动画，代码区域显示对应的代码。这种简单数据交互使用vuejs再适合不过了，vuejs基础知识这里就不再细说了。可直接拷贝代码\n\n这里需要注意的一点是，chrome 扩展的运行环境有一些特殊要求，称为 Content Security Policy (CSP)，使得通常的 vue 不能被正常使用。如果用的是 vue 1.x，那么可以下载 csp 版本,** [看这里](https://github.com/vuejs/vue/tree/csp/dist) ** 如果是 2.x 版本，请参考官网文档的 ** [这一段](https://vuefe.cn/v2/guide/installation.html#CSP-环境) **\n\n其实2.x解决cps问题很简单，只需要在manifest.json里面加入这样一行即可随意使用2.x版本的Vue\n```js\n\"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\"\n```\n核心代码：\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <!-- 因为使用的webpack 所以直接饮用了打包后的文件 -->\n        <link rel=\"stylesheet\" href=\"dist/style.css\">\n    </head>\n    <body>\n        <div id=\"app-prev-css\">\n            <div class=\"header\">Prev CSS3 Animate.css</div>\n            <div class=\"prev-box\">\n                <div :class=\"[activeClass, errorClass]\"></div>\n            </div>\n            <div class=\"select-line\">\n                <select v-model=\"selected\">\n                    <option v-for=\"(option,index) in options\" :value=\"option\">{{option}}</option>\n                </select>\n                <button type=\"button\" @click=\"copyTips\" class=\"copy-btn\" data-clipboard-target=\"#copyCss\">复制</button>\n            </div>\n            <div class=\"prev-css\" v-html=\"cssText\" id=\"copyCss\" v-cloak>{{cssText}}</div>\n            <div class=\"tips\" v-show=\"isShow\" v-cloak>复制成功！</div>\n        </div>\n        <!-- 因为使用的webpack 所以直接饮用了打包后的文件 -->\n        <script src=\"dist/bundle.js\"></script>\n    </body>\n</html>\n```\nCSS就不列出来了，可以在源代码中查看。\n\n下面来使用vuejs来实现插件的功能。\n```html\n<select v-model=\"selected\">\n    <option v-for=\"(option,index) in options\" :value=\"option\">{{option}}</option>\n</select>\n```\n使用 v-for 指令进行列表渲染。\n\n用v-bind方法来绑定option的value值\n\n在select中使用v-model方法来监听选中的值\n\n```js\nnew Vue({\n    el:\"#app-prev-css\",\n    data () {\n        return {\n            selected:'bounce',\n            activeClass: 'animated',\n            errorClass: 'bounce',\n            isShow:false,\n            options:[\n                'bounce','flash','pulse','rubberBand','shake','headShake','swing','tada','wobble','jello',\n                'bounceIn','bounceInDown','bounceInLeft','bounceInRight','bounceInUp',\n                'bounceOut','bounceOutDown','bounceOutLeft','bounceOutRight','bounceOutUp',\n                'fadeIn','fadeInDown','fadeInDownBig','fadeInLeft','fadeInLeftBig','fadeInRight',\n                'fadeInRightBig','fadeInUp','fadeInUpBig','fadeOut','fadeOutDown','fadeOutDownBig',\n                'fadeOutLeft','fadeOutLeftBig','fadeOutRight','fadeOutRightBig','fadeOutUp','fadeOutUpBig',\n                'flip','flipInX','flipInY','flipOutX','flipOutY','lightSpeedIn','lightSpeedOut',\n                'rotateIn','rotateInDownLeft','rotateInDownRight','rotateInUpLeft','rotateInUpRight',\n                'rotateOut','rotateOutDownLeft','rotateOutDownRight','rotateOutUpLeft','rotateOutUpRight',\n                'slideInUp','slideInDown','slideInLeft','slideInRight','slideOutUp','slideOutDown','slideOutLeft',\n                'slideOutRight','zoomIn','zoomInDown','zoomInLeft','zoomInRight','zoomInUp',\n                'zoomOut','zoomOutDown','zoomOutLeft','zoomOutRight','zoomOutUp','hinge','rollIn','rollOut'\n            ]\n        }\n    }\n})\n```\n### 代码同步显示\n接下来是代码同步功能，即在代码区域显示对应animate对齐的CSS代码。\n\n这里我们用vuejs中的computed属性方法来返回数据\n```js\ncomputed:{\n    cssText () {\n        // 数据我单独放在json里面了 返回对应名字动画即可\n        var  baseData = data[this.selected]\n\n        // 处理数据 优化显示方式 换行 缩进代码 使用了showdown => html\n        var converter =  new showdown.Converter({\n          tables: true\n        });\n        baseData = converter.makeHtml(baseData);\n\n        baseData = baseData.replace(/(.*?)gs/g,\"<div>$1</div>\")\n        baseData = baseData.replace(/<p>|<\\/p>/g,\"\")\n        baseData = baseData.replace(/\\b(sp)\\b/g,\"<span class='space'></span>\")\n        baseData = baseData.replace(/\\b(sp2)\\b/g,\"<span class='space2'></span>\")\n        // 返回\n        return baseData\n    }\n},\n```\n\n### 复制代码\n使用了Clipboard插件,具体使用方法[github地址看这里](https://github.com/zenorocha/clipboard.js)\n```html\n<!-- 点击按钮绑定 data-clipboard-target=\"#copyCss\" -->\n<button type=\"button\" @click=\"copyTips\" class=\"copy-btn\" data-clipboard-target=\"#copyCss\">复制</button>\n\n<!-- 代码区域使用 id copyCss-->\n<div class=\"prev-css\" v-html=\"cssText\" id=\"copyCss\" v-cloak>{{cssText}}</div>\n```\n接下来就是js\n```js\nmounted:function() {\n    this.$nextTick(function(){\n        new Clipboard('.copy-btn');\n    })\n}\n```\n开发好之后，可以直接在chrome中运行来调试。打开扩展面板，勾选开发者模式，然后加载刚开发扩展所在的目录就可以直接运行\n\n一个简单的插件就完成了，通过这一个简单的chrome插件就可以体验到vuejs在web开发中简单、优雅的魅力，还有什么理由不用起来呢。\n\n![](http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE201.png)\n\n![](http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170604223202.png)\n","source":"_posts/Vue2-X开发Chrome插件记录.md","raw":"---\ntitle: \" Vue2.x开发Chrome插件记录\"\nsubtitle: \"\"\ndate: 2017-06-04 21:37:58\nauthor: \"Yuqi Bi\"\nheader-img: \"form-opts.png\"\ncdn: 'header-on'\ntags: ['Vue','chrome插件']\n---\n### 背景\n作为一名web开发者,对[Animate.css](https://daneden.github.io/animate.css/)这个动画库不会陌生,它把常见的动画都封装了起来，非常实用。但是有时候在开发中，仅仅只是需要某一两个动画效果，把整个CSS文件都引入，这样不是太好。\n<!-- more -->\n需求就出现了，能不能有一个工具可以直接预览Animate.css对应的动画效果，并且生成对应的动画代码呢？\n\n作为web开发者，平时跟Chrome浏览器打交道最多，于是就想着整一个Chrome插件可以及时预览对应Animate.css中的动画效果并生成对应的动画代码，这样在实际开发中碰到一些需要使用到Animate.css中的动画效果时，可以大大的提高我们的开发效率。\n\n插件如下图所示：\n![](http://oq4hkch8e.bkt.clouddn.com/prevcss.gif)\n** [插件下载地址](http://pan.baidu.com/s/1bpozy8J) **\n** [插件源码](https://github.com/BiYuqi/v-chrome) **\n** [web网页版本](http://loadingmore.com/web-prev-animate/) **\n### 开始\n** Chrome插件开发基本知识 **\n在应用商店中下载下来的插件基本上都是以.crx为文件后缀，该文件其实就是一个压缩包，包括插件所需要的html、css、javascript、图片资源等等文件。\n\n开发一个插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。\n\n比如我这个插件的目录文件如下：\n![](http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170604220601.png)\n\n** manifest.json文件 **\n文件中需要注意一下的mainfest.json(很重要)这个文件，这个json文件的作用是提供插件的各种信息，例如插件能够做的事情，以及插件的文件配置等等信息。下面是一个清单文件的示例：\n```js\n{\n    \"manifest_version\": 2,\n    \"name\": \"Prev CSS3 Animate\",\n    \"description\": \"Preview CSS3 animation effects\",\n    \"version\": \"1.0\",\n    \"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\",\n    \"permissions\": [\n        \"http://*/*\",\n        \"https://*/*\",\n        \"file:///*\"\n     ],\n    \"content_scripts\": [\n        {\n            \"matches\": [\n                \"http://*/*\",\n                \"file:///*/*\"\n            ],\n            \"css\": [\"dist/style.css\"]\n        }\n    ],\n    \"browser_action\": {\n        \"default_icon\": \"img/icon4.png\",\n        \"default_popup\": \"index.html\"\n    }\n}\n```\n第一行声明我们使用清单文件格式的版本 2，必须包含（版本 1 是旧的，已弃用，不建议使用）\n\n接下来的部分定义扩展程序的名称、描述与版本。这些都会在 Chrome 浏览器中使用，向用户显示已安装的扩展程序，同时在 Chrome 网上应用店中向潜在的新用户显示您的扩展程序。名称应该简练，描述不要比一句话左右还长\n\nbrowser_action 对应的是默认的logo(本文是icon4.png)以及文件入口(文本为index.html),这两个资源都必须在扩展程序包中存在，图片是扩展的显示，html是扩展具体运行的基础文件。\n\n### 功能实现\n整个插件的核心交互功能非常简单，如文章开头的动图所示，用户选择对相应动画，代码区域显示对应的代码。这种简单数据交互使用vuejs再适合不过了，vuejs基础知识这里就不再细说了。可直接拷贝代码\n\n这里需要注意的一点是，chrome 扩展的运行环境有一些特殊要求，称为 Content Security Policy (CSP)，使得通常的 vue 不能被正常使用。如果用的是 vue 1.x，那么可以下载 csp 版本,** [看这里](https://github.com/vuejs/vue/tree/csp/dist) ** 如果是 2.x 版本，请参考官网文档的 ** [这一段](https://vuefe.cn/v2/guide/installation.html#CSP-环境) **\n\n其实2.x解决cps问题很简单，只需要在manifest.json里面加入这样一行即可随意使用2.x版本的Vue\n```js\n\"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\"\n```\n核心代码：\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <!-- 因为使用的webpack 所以直接饮用了打包后的文件 -->\n        <link rel=\"stylesheet\" href=\"dist/style.css\">\n    </head>\n    <body>\n        <div id=\"app-prev-css\">\n            <div class=\"header\">Prev CSS3 Animate.css</div>\n            <div class=\"prev-box\">\n                <div :class=\"[activeClass, errorClass]\"></div>\n            </div>\n            <div class=\"select-line\">\n                <select v-model=\"selected\">\n                    <option v-for=\"(option,index) in options\" :value=\"option\">{{option}}</option>\n                </select>\n                <button type=\"button\" @click=\"copyTips\" class=\"copy-btn\" data-clipboard-target=\"#copyCss\">复制</button>\n            </div>\n            <div class=\"prev-css\" v-html=\"cssText\" id=\"copyCss\" v-cloak>{{cssText}}</div>\n            <div class=\"tips\" v-show=\"isShow\" v-cloak>复制成功！</div>\n        </div>\n        <!-- 因为使用的webpack 所以直接饮用了打包后的文件 -->\n        <script src=\"dist/bundle.js\"></script>\n    </body>\n</html>\n```\nCSS就不列出来了，可以在源代码中查看。\n\n下面来使用vuejs来实现插件的功能。\n```html\n<select v-model=\"selected\">\n    <option v-for=\"(option,index) in options\" :value=\"option\">{{option}}</option>\n</select>\n```\n使用 v-for 指令进行列表渲染。\n\n用v-bind方法来绑定option的value值\n\n在select中使用v-model方法来监听选中的值\n\n```js\nnew Vue({\n    el:\"#app-prev-css\",\n    data () {\n        return {\n            selected:'bounce',\n            activeClass: 'animated',\n            errorClass: 'bounce',\n            isShow:false,\n            options:[\n                'bounce','flash','pulse','rubberBand','shake','headShake','swing','tada','wobble','jello',\n                'bounceIn','bounceInDown','bounceInLeft','bounceInRight','bounceInUp',\n                'bounceOut','bounceOutDown','bounceOutLeft','bounceOutRight','bounceOutUp',\n                'fadeIn','fadeInDown','fadeInDownBig','fadeInLeft','fadeInLeftBig','fadeInRight',\n                'fadeInRightBig','fadeInUp','fadeInUpBig','fadeOut','fadeOutDown','fadeOutDownBig',\n                'fadeOutLeft','fadeOutLeftBig','fadeOutRight','fadeOutRightBig','fadeOutUp','fadeOutUpBig',\n                'flip','flipInX','flipInY','flipOutX','flipOutY','lightSpeedIn','lightSpeedOut',\n                'rotateIn','rotateInDownLeft','rotateInDownRight','rotateInUpLeft','rotateInUpRight',\n                'rotateOut','rotateOutDownLeft','rotateOutDownRight','rotateOutUpLeft','rotateOutUpRight',\n                'slideInUp','slideInDown','slideInLeft','slideInRight','slideOutUp','slideOutDown','slideOutLeft',\n                'slideOutRight','zoomIn','zoomInDown','zoomInLeft','zoomInRight','zoomInUp',\n                'zoomOut','zoomOutDown','zoomOutLeft','zoomOutRight','zoomOutUp','hinge','rollIn','rollOut'\n            ]\n        }\n    }\n})\n```\n### 代码同步显示\n接下来是代码同步功能，即在代码区域显示对应animate对齐的CSS代码。\n\n这里我们用vuejs中的computed属性方法来返回数据\n```js\ncomputed:{\n    cssText () {\n        // 数据我单独放在json里面了 返回对应名字动画即可\n        var  baseData = data[this.selected]\n\n        // 处理数据 优化显示方式 换行 缩进代码 使用了showdown => html\n        var converter =  new showdown.Converter({\n          tables: true\n        });\n        baseData = converter.makeHtml(baseData);\n\n        baseData = baseData.replace(/(.*?)gs/g,\"<div>$1</div>\")\n        baseData = baseData.replace(/<p>|<\\/p>/g,\"\")\n        baseData = baseData.replace(/\\b(sp)\\b/g,\"<span class='space'></span>\")\n        baseData = baseData.replace(/\\b(sp2)\\b/g,\"<span class='space2'></span>\")\n        // 返回\n        return baseData\n    }\n},\n```\n\n### 复制代码\n使用了Clipboard插件,具体使用方法[github地址看这里](https://github.com/zenorocha/clipboard.js)\n```html\n<!-- 点击按钮绑定 data-clipboard-target=\"#copyCss\" -->\n<button type=\"button\" @click=\"copyTips\" class=\"copy-btn\" data-clipboard-target=\"#copyCss\">复制</button>\n\n<!-- 代码区域使用 id copyCss-->\n<div class=\"prev-css\" v-html=\"cssText\" id=\"copyCss\" v-cloak>{{cssText}}</div>\n```\n接下来就是js\n```js\nmounted:function() {\n    this.$nextTick(function(){\n        new Clipboard('.copy-btn');\n    })\n}\n```\n开发好之后，可以直接在chrome中运行来调试。打开扩展面板，勾选开发者模式，然后加载刚开发扩展所在的目录就可以直接运行\n\n一个简单的插件就完成了，通过这一个简单的chrome插件就可以体验到vuejs在web开发中简单、优雅的魅力，还有什么理由不用起来呢。\n\n![](http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE201.png)\n\n![](http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170604223202.png)\n","slug":"Vue2-X开发Chrome插件记录","published":1,"updated":"2019-09-25T15:10:25.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91oo002dla2edi7ahfga","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>作为一名web开发者,对<a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\" rel=\"external\">Animate.css</a>这个动画库不会陌生,它把常见的动画都封装了起来，非常实用。但是有时候在开发中，仅仅只是需要某一两个动画效果，把整个CSS文件都引入，这样不是太好。<br><a id=\"more\"></a><br>需求就出现了，能不能有一个工具可以直接预览Animate.css对应的动画效果，并且生成对应的动画代码呢？</p>\n<p>作为web开发者，平时跟Chrome浏览器打交道最多，于是就想着整一个Chrome插件可以及时预览对应Animate.css中的动画效果并生成对应的动画代码，这样在实际开发中碰到一些需要使用到Animate.css中的动画效果时，可以大大的提高我们的开发效率。</p>\n<p>插件如下图所示：<br><img src=\"http://oq4hkch8e.bkt.clouddn.com/prevcss.gif\" alt=\"\"><br><strong> <a href=\"http://pan.baidu.com/s/1bpozy8J\" target=\"_blank\" rel=\"external\">插件下载地址</a> </strong><br><strong> <a href=\"https://github.com/BiYuqi/v-chrome\" target=\"_blank\" rel=\"external\">插件源码</a> </strong><br><strong> <a href=\"http://loadingmore.com/web-prev-animate/\">web网页版本</a> </strong></p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p><strong> Chrome插件开发基本知识 </strong><br>在应用商店中下载下来的插件基本上都是以.crx为文件后缀，该文件其实就是一个压缩包，包括插件所需要的html、css、javascript、图片资源等等文件。</p>\n<p>开发一个插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。</p>\n<p>比如我这个插件的目录文件如下：<br><img src=\"http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170604220601.png\" alt=\"\"></p>\n<p><strong> manifest.json文件 </strong><br>文件中需要注意一下的mainfest.json(很重要)这个文件，这个json文件的作用是提供插件的各种信息，例如插件能够做的事情，以及插件的文件配置等等信息。下面是一个清单文件的示例：</p>\n<pre><code class=\"js\">{\n    &quot;manifest_version&quot;: 2,\n    &quot;name&quot;: &quot;Prev CSS3 Animate&quot;,\n    &quot;description&quot;: &quot;Preview CSS3 animation effects&quot;,\n    &quot;version&quot;: &quot;1.0&quot;,\n    &quot;content_security_policy&quot;: &quot;script-src &#39;self&#39; &#39;unsafe-eval&#39;; object-src &#39;self&#39;&quot;,\n    &quot;permissions&quot;: [\n        &quot;http://*/*&quot;,\n        &quot;https://*/*&quot;,\n        &quot;file:///*&quot;\n     ],\n    &quot;content_scripts&quot;: [\n        {\n            &quot;matches&quot;: [\n                &quot;http://*/*&quot;,\n                &quot;file:///*/*&quot;\n            ],\n            &quot;css&quot;: [&quot;dist/style.css&quot;]\n        }\n    ],\n    &quot;browser_action&quot;: {\n        &quot;default_icon&quot;: &quot;img/icon4.png&quot;,\n        &quot;default_popup&quot;: &quot;index.html&quot;\n    }\n}\n</code></pre>\n<p>第一行声明我们使用清单文件格式的版本 2，必须包含（版本 1 是旧的，已弃用，不建议使用）</p>\n<p>接下来的部分定义扩展程序的名称、描述与版本。这些都会在 Chrome 浏览器中使用，向用户显示已安装的扩展程序，同时在 Chrome 网上应用店中向潜在的新用户显示您的扩展程序。名称应该简练，描述不要比一句话左右还长</p>\n<p>browser_action 对应的是默认的logo(本文是icon4.png)以及文件入口(文本为index.html),这两个资源都必须在扩展程序包中存在，图片是扩展的显示，html是扩展具体运行的基础文件。</p>\n<h3 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h3><p>整个插件的核心交互功能非常简单，如文章开头的动图所示，用户选择对相应动画，代码区域显示对应的代码。这种简单数据交互使用vuejs再适合不过了，vuejs基础知识这里就不再细说了。可直接拷贝代码</p>\n<p>这里需要注意的一点是，chrome 扩展的运行环境有一些特殊要求，称为 Content Security Policy (CSP)，使得通常的 vue 不能被正常使用。如果用的是 vue 1.x，那么可以下载 csp 版本,<strong> <a href=\"https://github.com/vuejs/vue/tree/csp/dist\" target=\"_blank\" rel=\"external\">看这里</a> </strong> 如果是 2.x 版本，请参考官网文档的 <strong> <a href=\"https://vuefe.cn/v2/guide/installation.html#CSP-环境\" target=\"_blank\" rel=\"external\">这一段</a> </strong></p>\n<p>其实2.x解决cps问题很简单，只需要在manifest.json里面加入这样一行即可随意使用2.x版本的Vue</p>\n<pre><code class=\"js\">&quot;content_security_policy&quot;: &quot;script-src &#39;self&#39; &#39;unsafe-eval&#39;; object-src &#39;self&#39;&quot;\n</code></pre>\n<p>核心代码：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n        &lt;!-- 因为使用的webpack 所以直接饮用了打包后的文件 --&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;dist/style.css&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app-prev-css&quot;&gt;\n            &lt;div class=&quot;header&quot;&gt;Prev CSS3 Animate.css&lt;/div&gt;\n            &lt;div class=&quot;prev-box&quot;&gt;\n                &lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;select-line&quot;&gt;\n                &lt;select v-model=&quot;selected&quot;&gt;\n                    &lt;option v-for=&quot;(option,index) in options&quot; :value=&quot;option&quot;&gt;{{option}}&lt;/option&gt;\n                &lt;/select&gt;\n                &lt;button type=&quot;button&quot; @click=&quot;copyTips&quot; class=&quot;copy-btn&quot; data-clipboard-target=&quot;#copyCss&quot;&gt;复制&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;prev-css&quot; v-html=&quot;cssText&quot; id=&quot;copyCss&quot; v-cloak&gt;{{cssText}}&lt;/div&gt;\n            &lt;div class=&quot;tips&quot; v-show=&quot;isShow&quot; v-cloak&gt;复制成功！&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;!-- 因为使用的webpack 所以直接饮用了打包后的文件 --&gt;\n        &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>CSS就不列出来了，可以在源代码中查看。</p>\n<p>下面来使用vuejs来实现插件的功能。</p>\n<pre><code class=\"html\">&lt;select v-model=&quot;selected&quot;&gt;\n    &lt;option v-for=&quot;(option,index) in options&quot; :value=&quot;option&quot;&gt;{{option}}&lt;/option&gt;\n&lt;/select&gt;\n</code></pre>\n<p>使用 v-for 指令进行列表渲染。</p>\n<p>用v-bind方法来绑定option的value值</p>\n<p>在select中使用v-model方法来监听选中的值</p>\n<pre><code class=\"js\">new Vue({\n    el:&quot;#app-prev-css&quot;,\n    data () {\n        return {\n            selected:&#39;bounce&#39;,\n            activeClass: &#39;animated&#39;,\n            errorClass: &#39;bounce&#39;,\n            isShow:false,\n            options:[\n                &#39;bounce&#39;,&#39;flash&#39;,&#39;pulse&#39;,&#39;rubberBand&#39;,&#39;shake&#39;,&#39;headShake&#39;,&#39;swing&#39;,&#39;tada&#39;,&#39;wobble&#39;,&#39;jello&#39;,\n                &#39;bounceIn&#39;,&#39;bounceInDown&#39;,&#39;bounceInLeft&#39;,&#39;bounceInRight&#39;,&#39;bounceInUp&#39;,\n                &#39;bounceOut&#39;,&#39;bounceOutDown&#39;,&#39;bounceOutLeft&#39;,&#39;bounceOutRight&#39;,&#39;bounceOutUp&#39;,\n                &#39;fadeIn&#39;,&#39;fadeInDown&#39;,&#39;fadeInDownBig&#39;,&#39;fadeInLeft&#39;,&#39;fadeInLeftBig&#39;,&#39;fadeInRight&#39;,\n                &#39;fadeInRightBig&#39;,&#39;fadeInUp&#39;,&#39;fadeInUpBig&#39;,&#39;fadeOut&#39;,&#39;fadeOutDown&#39;,&#39;fadeOutDownBig&#39;,\n                &#39;fadeOutLeft&#39;,&#39;fadeOutLeftBig&#39;,&#39;fadeOutRight&#39;,&#39;fadeOutRightBig&#39;,&#39;fadeOutUp&#39;,&#39;fadeOutUpBig&#39;,\n                &#39;flip&#39;,&#39;flipInX&#39;,&#39;flipInY&#39;,&#39;flipOutX&#39;,&#39;flipOutY&#39;,&#39;lightSpeedIn&#39;,&#39;lightSpeedOut&#39;,\n                &#39;rotateIn&#39;,&#39;rotateInDownLeft&#39;,&#39;rotateInDownRight&#39;,&#39;rotateInUpLeft&#39;,&#39;rotateInUpRight&#39;,\n                &#39;rotateOut&#39;,&#39;rotateOutDownLeft&#39;,&#39;rotateOutDownRight&#39;,&#39;rotateOutUpLeft&#39;,&#39;rotateOutUpRight&#39;,\n                &#39;slideInUp&#39;,&#39;slideInDown&#39;,&#39;slideInLeft&#39;,&#39;slideInRight&#39;,&#39;slideOutUp&#39;,&#39;slideOutDown&#39;,&#39;slideOutLeft&#39;,\n                &#39;slideOutRight&#39;,&#39;zoomIn&#39;,&#39;zoomInDown&#39;,&#39;zoomInLeft&#39;,&#39;zoomInRight&#39;,&#39;zoomInUp&#39;,\n                &#39;zoomOut&#39;,&#39;zoomOutDown&#39;,&#39;zoomOutLeft&#39;,&#39;zoomOutRight&#39;,&#39;zoomOutUp&#39;,&#39;hinge&#39;,&#39;rollIn&#39;,&#39;rollOut&#39;\n            ]\n        }\n    }\n})\n</code></pre>\n<h3 id=\"代码同步显示\"><a href=\"#代码同步显示\" class=\"headerlink\" title=\"代码同步显示\"></a>代码同步显示</h3><p>接下来是代码同步功能，即在代码区域显示对应animate对齐的CSS代码。</p>\n<p>这里我们用vuejs中的computed属性方法来返回数据</p>\n<pre><code class=\"js\">computed:{\n    cssText () {\n        // 数据我单独放在json里面了 返回对应名字动画即可\n        var  baseData = data[this.selected]\n\n        // 处理数据 优化显示方式 换行 缩进代码 使用了showdown =&gt; html\n        var converter =  new showdown.Converter({\n          tables: true\n        });\n        baseData = converter.makeHtml(baseData);\n\n        baseData = baseData.replace(/(.*?)gs/g,&quot;&lt;div&gt;$1&lt;/div&gt;&quot;)\n        baseData = baseData.replace(/&lt;p&gt;|&lt;\\/p&gt;/g,&quot;&quot;)\n        baseData = baseData.replace(/\\b(sp)\\b/g,&quot;&lt;span class=&#39;space&#39;&gt;&lt;/span&gt;&quot;)\n        baseData = baseData.replace(/\\b(sp2)\\b/g,&quot;&lt;span class=&#39;space2&#39;&gt;&lt;/span&gt;&quot;)\n        // 返回\n        return baseData\n    }\n},\n</code></pre>\n<h3 id=\"复制代码\"><a href=\"#复制代码\" class=\"headerlink\" title=\"复制代码\"></a>复制代码</h3><p>使用了Clipboard插件,具体使用方法<a href=\"https://github.com/zenorocha/clipboard.js\" target=\"_blank\" rel=\"external\">github地址看这里</a></p>\n<pre><code class=\"html\">&lt;!-- 点击按钮绑定 data-clipboard-target=&quot;#copyCss&quot; --&gt;\n&lt;button type=&quot;button&quot; @click=&quot;copyTips&quot; class=&quot;copy-btn&quot; data-clipboard-target=&quot;#copyCss&quot;&gt;复制&lt;/button&gt;\n\n&lt;!-- 代码区域使用 id copyCss--&gt;\n&lt;div class=&quot;prev-css&quot; v-html=&quot;cssText&quot; id=&quot;copyCss&quot; v-cloak&gt;{{cssText}}&lt;/div&gt;\n</code></pre>\n<p>接下来就是js</p>\n<pre><code class=\"js\">mounted:function() {\n    this.$nextTick(function(){\n        new Clipboard(&#39;.copy-btn&#39;);\n    })\n}\n</code></pre>\n<p>开发好之后，可以直接在chrome中运行来调试。打开扩展面板，勾选开发者模式，然后加载刚开发扩展所在的目录就可以直接运行</p>\n<p>一个简单的插件就完成了，通过这一个简单的chrome插件就可以体验到vuejs在web开发中简单、优雅的魅力，还有什么理由不用起来呢。</p>\n<p><img src=\"http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE201.png\" alt=\"\"></p>\n<p><img src=\"http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170604223202.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>作为一名web开发者,对<a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\" rel=\"external\">Animate.css</a>这个动画库不会陌生,它把常见的动画都封装了起来，非常实用。但是有时候在开发中，仅仅只是需要某一两个动画效果，把整个CSS文件都引入，这样不是太好。<br>","more":"<br>需求就出现了，能不能有一个工具可以直接预览Animate.css对应的动画效果，并且生成对应的动画代码呢？</p>\n<p>作为web开发者，平时跟Chrome浏览器打交道最多，于是就想着整一个Chrome插件可以及时预览对应Animate.css中的动画效果并生成对应的动画代码，这样在实际开发中碰到一些需要使用到Animate.css中的动画效果时，可以大大的提高我们的开发效率。</p>\n<p>插件如下图所示：<br><img src=\"http://oq4hkch8e.bkt.clouddn.com/prevcss.gif\" alt=\"\"><br><strong> <a href=\"http://pan.baidu.com/s/1bpozy8J\" target=\"_blank\" rel=\"external\">插件下载地址</a> </strong><br><strong> <a href=\"https://github.com/BiYuqi/v-chrome\" target=\"_blank\" rel=\"external\">插件源码</a> </strong><br><strong> <a href=\"http://loadingmore.com/web-prev-animate/\">web网页版本</a> </strong></p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p><strong> Chrome插件开发基本知识 </strong><br>在应用商店中下载下来的插件基本上都是以.crx为文件后缀，该文件其实就是一个压缩包，包括插件所需要的html、css、javascript、图片资源等等文件。</p>\n<p>开发一个插件就跟我们平时做web开发流程没多大的区别，就是先搭好基本的页面，然后使用js来写交互逻辑等功能。</p>\n<p>比如我这个插件的目录文件如下：<br><img src=\"http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170604220601.png\" alt=\"\"></p>\n<p><strong> manifest.json文件 </strong><br>文件中需要注意一下的mainfest.json(很重要)这个文件，这个json文件的作用是提供插件的各种信息，例如插件能够做的事情，以及插件的文件配置等等信息。下面是一个清单文件的示例：</p>\n<pre><code class=\"js\">{\n    &quot;manifest_version&quot;: 2,\n    &quot;name&quot;: &quot;Prev CSS3 Animate&quot;,\n    &quot;description&quot;: &quot;Preview CSS3 animation effects&quot;,\n    &quot;version&quot;: &quot;1.0&quot;,\n    &quot;content_security_policy&quot;: &quot;script-src &#39;self&#39; &#39;unsafe-eval&#39;; object-src &#39;self&#39;&quot;,\n    &quot;permissions&quot;: [\n        &quot;http://*/*&quot;,\n        &quot;https://*/*&quot;,\n        &quot;file:///*&quot;\n     ],\n    &quot;content_scripts&quot;: [\n        {\n            &quot;matches&quot;: [\n                &quot;http://*/*&quot;,\n                &quot;file:///*/*&quot;\n            ],\n            &quot;css&quot;: [&quot;dist/style.css&quot;]\n        }\n    ],\n    &quot;browser_action&quot;: {\n        &quot;default_icon&quot;: &quot;img/icon4.png&quot;,\n        &quot;default_popup&quot;: &quot;index.html&quot;\n    }\n}\n</code></pre>\n<p>第一行声明我们使用清单文件格式的版本 2，必须包含（版本 1 是旧的，已弃用，不建议使用）</p>\n<p>接下来的部分定义扩展程序的名称、描述与版本。这些都会在 Chrome 浏览器中使用，向用户显示已安装的扩展程序，同时在 Chrome 网上应用店中向潜在的新用户显示您的扩展程序。名称应该简练，描述不要比一句话左右还长</p>\n<p>browser_action 对应的是默认的logo(本文是icon4.png)以及文件入口(文本为index.html),这两个资源都必须在扩展程序包中存在，图片是扩展的显示，html是扩展具体运行的基础文件。</p>\n<h3 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h3><p>整个插件的核心交互功能非常简单，如文章开头的动图所示，用户选择对相应动画，代码区域显示对应的代码。这种简单数据交互使用vuejs再适合不过了，vuejs基础知识这里就不再细说了。可直接拷贝代码</p>\n<p>这里需要注意的一点是，chrome 扩展的运行环境有一些特殊要求，称为 Content Security Policy (CSP)，使得通常的 vue 不能被正常使用。如果用的是 vue 1.x，那么可以下载 csp 版本,<strong> <a href=\"https://github.com/vuejs/vue/tree/csp/dist\" target=\"_blank\" rel=\"external\">看这里</a> </strong> 如果是 2.x 版本，请参考官网文档的 <strong> <a href=\"https://vuefe.cn/v2/guide/installation.html#CSP-环境\" target=\"_blank\" rel=\"external\">这一段</a> </strong></p>\n<p>其实2.x解决cps问题很简单，只需要在manifest.json里面加入这样一行即可随意使用2.x版本的Vue</p>\n<pre><code class=\"js\">&quot;content_security_policy&quot;: &quot;script-src &#39;self&#39; &#39;unsafe-eval&#39;; object-src &#39;self&#39;&quot;\n</code></pre>\n<p>核心代码：</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n        &lt;!-- 因为使用的webpack 所以直接饮用了打包后的文件 --&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;dist/style.css&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;app-prev-css&quot;&gt;\n            &lt;div class=&quot;header&quot;&gt;Prev CSS3 Animate.css&lt;/div&gt;\n            &lt;div class=&quot;prev-box&quot;&gt;\n                &lt;div :class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;select-line&quot;&gt;\n                &lt;select v-model=&quot;selected&quot;&gt;\n                    &lt;option v-for=&quot;(option,index) in options&quot; :value=&quot;option&quot;&gt;{{option}}&lt;/option&gt;\n                &lt;/select&gt;\n                &lt;button type=&quot;button&quot; @click=&quot;copyTips&quot; class=&quot;copy-btn&quot; data-clipboard-target=&quot;#copyCss&quot;&gt;复制&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;prev-css&quot; v-html=&quot;cssText&quot; id=&quot;copyCss&quot; v-cloak&gt;{{cssText}}&lt;/div&gt;\n            &lt;div class=&quot;tips&quot; v-show=&quot;isShow&quot; v-cloak&gt;复制成功！&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;!-- 因为使用的webpack 所以直接饮用了打包后的文件 --&gt;\n        &lt;script src=&quot;dist/bundle.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>CSS就不列出来了，可以在源代码中查看。</p>\n<p>下面来使用vuejs来实现插件的功能。</p>\n<pre><code class=\"html\">&lt;select v-model=&quot;selected&quot;&gt;\n    &lt;option v-for=&quot;(option,index) in options&quot; :value=&quot;option&quot;&gt;{{option}}&lt;/option&gt;\n&lt;/select&gt;\n</code></pre>\n<p>使用 v-for 指令进行列表渲染。</p>\n<p>用v-bind方法来绑定option的value值</p>\n<p>在select中使用v-model方法来监听选中的值</p>\n<pre><code class=\"js\">new Vue({\n    el:&quot;#app-prev-css&quot;,\n    data () {\n        return {\n            selected:&#39;bounce&#39;,\n            activeClass: &#39;animated&#39;,\n            errorClass: &#39;bounce&#39;,\n            isShow:false,\n            options:[\n                &#39;bounce&#39;,&#39;flash&#39;,&#39;pulse&#39;,&#39;rubberBand&#39;,&#39;shake&#39;,&#39;headShake&#39;,&#39;swing&#39;,&#39;tada&#39;,&#39;wobble&#39;,&#39;jello&#39;,\n                &#39;bounceIn&#39;,&#39;bounceInDown&#39;,&#39;bounceInLeft&#39;,&#39;bounceInRight&#39;,&#39;bounceInUp&#39;,\n                &#39;bounceOut&#39;,&#39;bounceOutDown&#39;,&#39;bounceOutLeft&#39;,&#39;bounceOutRight&#39;,&#39;bounceOutUp&#39;,\n                &#39;fadeIn&#39;,&#39;fadeInDown&#39;,&#39;fadeInDownBig&#39;,&#39;fadeInLeft&#39;,&#39;fadeInLeftBig&#39;,&#39;fadeInRight&#39;,\n                &#39;fadeInRightBig&#39;,&#39;fadeInUp&#39;,&#39;fadeInUpBig&#39;,&#39;fadeOut&#39;,&#39;fadeOutDown&#39;,&#39;fadeOutDownBig&#39;,\n                &#39;fadeOutLeft&#39;,&#39;fadeOutLeftBig&#39;,&#39;fadeOutRight&#39;,&#39;fadeOutRightBig&#39;,&#39;fadeOutUp&#39;,&#39;fadeOutUpBig&#39;,\n                &#39;flip&#39;,&#39;flipInX&#39;,&#39;flipInY&#39;,&#39;flipOutX&#39;,&#39;flipOutY&#39;,&#39;lightSpeedIn&#39;,&#39;lightSpeedOut&#39;,\n                &#39;rotateIn&#39;,&#39;rotateInDownLeft&#39;,&#39;rotateInDownRight&#39;,&#39;rotateInUpLeft&#39;,&#39;rotateInUpRight&#39;,\n                &#39;rotateOut&#39;,&#39;rotateOutDownLeft&#39;,&#39;rotateOutDownRight&#39;,&#39;rotateOutUpLeft&#39;,&#39;rotateOutUpRight&#39;,\n                &#39;slideInUp&#39;,&#39;slideInDown&#39;,&#39;slideInLeft&#39;,&#39;slideInRight&#39;,&#39;slideOutUp&#39;,&#39;slideOutDown&#39;,&#39;slideOutLeft&#39;,\n                &#39;slideOutRight&#39;,&#39;zoomIn&#39;,&#39;zoomInDown&#39;,&#39;zoomInLeft&#39;,&#39;zoomInRight&#39;,&#39;zoomInUp&#39;,\n                &#39;zoomOut&#39;,&#39;zoomOutDown&#39;,&#39;zoomOutLeft&#39;,&#39;zoomOutRight&#39;,&#39;zoomOutUp&#39;,&#39;hinge&#39;,&#39;rollIn&#39;,&#39;rollOut&#39;\n            ]\n        }\n    }\n})\n</code></pre>\n<h3 id=\"代码同步显示\"><a href=\"#代码同步显示\" class=\"headerlink\" title=\"代码同步显示\"></a>代码同步显示</h3><p>接下来是代码同步功能，即在代码区域显示对应animate对齐的CSS代码。</p>\n<p>这里我们用vuejs中的computed属性方法来返回数据</p>\n<pre><code class=\"js\">computed:{\n    cssText () {\n        // 数据我单独放在json里面了 返回对应名字动画即可\n        var  baseData = data[this.selected]\n\n        // 处理数据 优化显示方式 换行 缩进代码 使用了showdown =&gt; html\n        var converter =  new showdown.Converter({\n          tables: true\n        });\n        baseData = converter.makeHtml(baseData);\n\n        baseData = baseData.replace(/(.*?)gs/g,&quot;&lt;div&gt;$1&lt;/div&gt;&quot;)\n        baseData = baseData.replace(/&lt;p&gt;|&lt;\\/p&gt;/g,&quot;&quot;)\n        baseData = baseData.replace(/\\b(sp)\\b/g,&quot;&lt;span class=&#39;space&#39;&gt;&lt;/span&gt;&quot;)\n        baseData = baseData.replace(/\\b(sp2)\\b/g,&quot;&lt;span class=&#39;space2&#39;&gt;&lt;/span&gt;&quot;)\n        // 返回\n        return baseData\n    }\n},\n</code></pre>\n<h3 id=\"复制代码\"><a href=\"#复制代码\" class=\"headerlink\" title=\"复制代码\"></a>复制代码</h3><p>使用了Clipboard插件,具体使用方法<a href=\"https://github.com/zenorocha/clipboard.js\" target=\"_blank\" rel=\"external\">github地址看这里</a></p>\n<pre><code class=\"html\">&lt;!-- 点击按钮绑定 data-clipboard-target=&quot;#copyCss&quot; --&gt;\n&lt;button type=&quot;button&quot; @click=&quot;copyTips&quot; class=&quot;copy-btn&quot; data-clipboard-target=&quot;#copyCss&quot;&gt;复制&lt;/button&gt;\n\n&lt;!-- 代码区域使用 id copyCss--&gt;\n&lt;div class=&quot;prev-css&quot; v-html=&quot;cssText&quot; id=&quot;copyCss&quot; v-cloak&gt;{{cssText}}&lt;/div&gt;\n</code></pre>\n<p>接下来就是js</p>\n<pre><code class=\"js\">mounted:function() {\n    this.$nextTick(function(){\n        new Clipboard(&#39;.copy-btn&#39;);\n    })\n}\n</code></pre>\n<p>开发好之后，可以直接在chrome中运行来调试。打开扩展面板，勾选开发者模式，然后加载刚开发扩展所在的目录就可以直接运行</p>\n<p>一个简单的插件就完成了，通过这一个简单的chrome插件就可以体验到vuejs在web开发中简单、优雅的魅力，还有什么理由不用起来呢。</p>\n<p><img src=\"http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE201.png\" alt=\"\"></p>\n<p><img src=\"http://oq4hkch8e.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170604223202.png\" alt=\"\"></p>"},{"title":"Vuex在IE上的报错处理","date":"2017-08-09T11:16:07.000Z","author":"Yuqi Bi","_content":"> 最近在做一个后台项目，其中遇到了vuex在IE浏览器中报错的问题，于是就有了这篇博文进行记录\n\n## 报错语句\n```js\nSCRIPT5022: [vuex] vuex requires a Promise polyfill in this browser.\n```\n\n## 解决办法\n1.先安装babel-polyfill\n```js\nnpm install babel-polyfill --save-dev\n\n```\n2.build/webpack.base.config.js下修改文件\n```js\n// 入口文件改为如下\nentry: {\n  app: ['babel-polyfill','./src/main.js']\n}\n```\n## 原因\nIE浏览器没有内置Promise对象。不仅如此，几乎所有的ES6新增的方法在IE都不能用，比如Array.from。因为babel只会转译语法，并不会新增方法\n","source":"_posts/Vuex在IE上的报错处理.md","raw":"---\ntitle: Vuex在IE上的报错处理\ndate: 2017-08-09 19:16:07\ntags: [Vue]\nauthor: \"Yuqi Bi\"\n---\n> 最近在做一个后台项目，其中遇到了vuex在IE浏览器中报错的问题，于是就有了这篇博文进行记录\n\n## 报错语句\n```js\nSCRIPT5022: [vuex] vuex requires a Promise polyfill in this browser.\n```\n\n## 解决办法\n1.先安装babel-polyfill\n```js\nnpm install babel-polyfill --save-dev\n\n```\n2.build/webpack.base.config.js下修改文件\n```js\n// 入口文件改为如下\nentry: {\n  app: ['babel-polyfill','./src/main.js']\n}\n```\n## 原因\nIE浏览器没有内置Promise对象。不仅如此，几乎所有的ES6新增的方法在IE都不能用，比如Array.from。因为babel只会转译语法，并不会新增方法\n","slug":"Vuex在IE上的报错处理","published":1,"updated":"2019-09-25T15:10:25.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91oq002gla2e7389znqf","content":"<blockquote>\n<p>最近在做一个后台项目，其中遇到了vuex在IE浏览器中报错的问题，于是就有了这篇博文进行记录</p>\n</blockquote>\n<h2 id=\"报错语句\"><a href=\"#报错语句\" class=\"headerlink\" title=\"报错语句\"></a>报错语句</h2><pre><code class=\"js\">SCRIPT5022: [vuex] vuex requires a Promise polyfill in this browser.\n</code></pre>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>1.先安装babel-polyfill</p>\n<pre><code class=\"js\">npm install babel-polyfill --save-dev\n</code></pre>\n<p>2.build/webpack.base.config.js下修改文件</p>\n<pre><code class=\"js\">// 入口文件改为如下\nentry: {\n  app: [&#39;babel-polyfill&#39;,&#39;./src/main.js&#39;]\n}\n</code></pre>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>IE浏览器没有内置Promise对象。不仅如此，几乎所有的ES6新增的方法在IE都不能用，比如Array.from。因为babel只会转译语法，并不会新增方法</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近在做一个后台项目，其中遇到了vuex在IE浏览器中报错的问题，于是就有了这篇博文进行记录</p>\n</blockquote>\n<h2 id=\"报错语句\"><a href=\"#报错语句\" class=\"headerlink\" title=\"报错语句\"></a>报错语句</h2><pre><code class=\"js\">SCRIPT5022: [vuex] vuex requires a Promise polyfill in this browser.\n</code></pre>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>1.先安装babel-polyfill</p>\n<pre><code class=\"js\">npm install babel-polyfill --save-dev\n</code></pre>\n<p>2.build/webpack.base.config.js下修改文件</p>\n<pre><code class=\"js\">// 入口文件改为如下\nentry: {\n  app: [&#39;babel-polyfill&#39;,&#39;./src/main.js&#39;]\n}\n</code></pre>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>IE浏览器没有内置Promise对象。不仅如此，几乎所有的ES6新增的方法在IE都不能用，比如Array.from。因为babel只会转译语法，并不会新增方法</p>\n"},{"title":"Vue起步","date":"2017-01-11T13:04:22.000Z","_content":"> 此贴代表我的Vue.js之旅开始了，留个位置\n\n\n<!-- more -->\n** Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：**\n```javascript\n# 最新稳定版\n$ npm install vue\n```\n```javascript\n# 全局安装 vue-cli\n$ npm install --global vue-cli\n```\n```javascript\n# 创建一个基于 webpack 模板的新项目\n$ vue init webpack my-project\n```\n```javascript\n# 安装依赖，走你\n$ cd my-project\n$ npm install\n$ npm run dev\n```\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/vuee.png\n","source":"_posts/Vue起步.md","raw":"---\ntitle: Vue起步\ndate: 2017-01-11 21:04:22\ntags: [Vue,\"vue起步\"]\ncategories: Vue\n---\n> 此贴代表我的Vue.js之旅开始了，留个位置\n\n\n<!-- more -->\n** Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：**\n```javascript\n# 最新稳定版\n$ npm install vue\n```\n```javascript\n# 全局安装 vue-cli\n$ npm install --global vue-cli\n```\n```javascript\n# 创建一个基于 webpack 模板的新项目\n$ vue init webpack my-project\n```\n```javascript\n# 安装依赖，走你\n$ cd my-project\n$ npm install\n$ npm run dev\n```\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/vuee.png\n","slug":"Vue起步","published":1,"updated":"2019-09-25T15:10:25.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91or002jla2ewh4dcy4w","content":"<blockquote>\n<p>此贴代表我的Vue.js之旅开始了，留个位置</p>\n</blockquote>\n<a id=\"more\"></a>\n<p><strong> Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：</strong></p>\n<pre><code class=\"javascript\"># 最新稳定版\n$ npm install vue\n</code></pre>\n<pre><code class=\"javascript\"># 全局安装 vue-cli\n$ npm install --global vue-cli\n</code></pre>\n<pre><code class=\"javascript\"># 创建一个基于 webpack 模板的新项目\n$ vue init webpack my-project\n</code></pre>\n<pre><code class=\"javascript\"># 安装依赖，走你\n$ cd my-project\n$ npm install\n$ npm run dev\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>此贴代表我的Vue.js之旅开始了，留个位置</p>\n</blockquote>","more":"<p><strong> Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：</strong></p>\n<pre><code class=\"javascript\"># 最新稳定版\n$ npm install vue\n</code></pre>\n<pre><code class=\"javascript\"># 全局安装 vue-cli\n$ npm install --global vue-cli\n</code></pre>\n<pre><code class=\"javascript\"># 创建一个基于 webpack 模板的新项目\n$ vue init webpack my-project\n</code></pre>\n<pre><code class=\"javascript\"># 安装依赖，走你\n$ cd my-project\n$ npm install\n$ npm run dev\n</code></pre>"},{"title":"github一个远程仓库的某个分支放到一个新的仓库，保留历史提交记录","date":"2018-10-03T08:18:51.000Z","_content":"> 记录下迁将一个远程仓库的某个分支放到一个新的仓库中（提交历史纪录也导过去的一点经验\n\n### 开始\norigin_seed(名字可自取，临时用，\b迁完后，\b主动取消关联) 区别于origin 目的在于将当前仓库(分支)新关联到新的仓库\n\n新建一个仓库，假设仓库名为[webpack-seed](https://github.com/BiYuqi/webpack-seed)\n\n### 切换仓库\n\n切换到旧仓库(将要迁走的仓库下, 分支自己选, 或者默认迁走master)，然后关联新仓库\n\n```js\ngit remove add origin_seed https://github.com/BiYuqi/webpack-seed.git (你的新仓库地址)\n```\n\n### 推送到新的仓库\n* 此处是将旧仓库下 web-ejs-pc 分支推送到新仓库master分支, 分支根据需要自己填写\n```js\ngit -u push origin_seed web-ejs-pc:master\n```\n\n### 取消关联，原有仓库恢复原样\n\n```js\ngit remote remove origin_seed\n```\n\n至此，可以去查看新仓库是否\b迁移成功.\n","source":"_posts/github一个远程仓库的某个分支放到一个新的仓库，保留历史提交记录.md","raw":"---\ntitle: github一个远程仓库的某个分支放到一个新的仓库，保留历史提交记录\ndate: 2018-10-03 16:18:51\ntags: [git]\ncategories: Git\n---\n> 记录下迁将一个远程仓库的某个分支放到一个新的仓库中（提交历史纪录也导过去的一点经验\n\n### 开始\norigin_seed(名字可自取，临时用，\b迁完后，\b主动取消关联) 区别于origin 目的在于将当前仓库(分支)新关联到新的仓库\n\n新建一个仓库，假设仓库名为[webpack-seed](https://github.com/BiYuqi/webpack-seed)\n\n### 切换仓库\n\n切换到旧仓库(将要迁走的仓库下, 分支自己选, 或者默认迁走master)，然后关联新仓库\n\n```js\ngit remove add origin_seed https://github.com/BiYuqi/webpack-seed.git (你的新仓库地址)\n```\n\n### 推送到新的仓库\n* 此处是将旧仓库下 web-ejs-pc 分支推送到新仓库master分支, 分支根据需要自己填写\n```js\ngit -u push origin_seed web-ejs-pc:master\n```\n\n### 取消关联，原有仓库恢复原样\n\n```js\ngit remote remove origin_seed\n```\n\n至此，可以去查看新仓库是否\b迁移成功.\n","slug":"github一个远程仓库的某个分支放到一个新的仓库，保留历史提交记录","published":1,"updated":"2019-09-25T15:10:25.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91os002mla2et5hx4cpd","content":"<blockquote>\n<p>记录下迁将一个远程仓库的某个分支放到一个新的仓库中（提交历史纪录也导过去的一点经验</p>\n</blockquote>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>origin_seed(名字可自取，临时用，\b迁完后，\b主动取消关联) 区别于origin 目的在于将当前仓库(分支)新关联到新的仓库</p>\n<p>新建一个仓库，假设仓库名为<a href=\"https://github.com/BiYuqi/webpack-seed\" target=\"_blank\" rel=\"external\">webpack-seed</a></p>\n<h3 id=\"切换仓库\"><a href=\"#切换仓库\" class=\"headerlink\" title=\"切换仓库\"></a>切换仓库</h3><p>切换到旧仓库(将要迁走的仓库下, 分支自己选, 或者默认迁走master)，然后关联新仓库</p>\n<pre><code class=\"js\">git remove add origin_seed https://github.com/BiYuqi/webpack-seed.git (你的新仓库地址)\n</code></pre>\n<h3 id=\"推送到新的仓库\"><a href=\"#推送到新的仓库\" class=\"headerlink\" title=\"推送到新的仓库\"></a>推送到新的仓库</h3><ul>\n<li>此处是将旧仓库下 web-ejs-pc 分支推送到新仓库master分支, 分支根据需要自己填写<pre><code class=\"js\">git -u push origin_seed web-ejs-pc:master\n</code></pre>\n</li>\n</ul>\n<h3 id=\"取消关联，原有仓库恢复原样\"><a href=\"#取消关联，原有仓库恢复原样\" class=\"headerlink\" title=\"取消关联，原有仓库恢复原样\"></a>取消关联，原有仓库恢复原样</h3><pre><code class=\"js\">git remote remove origin_seed\n</code></pre>\n<p>至此，可以去查看新仓库是否\b迁移成功.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录下迁将一个远程仓库的某个分支放到一个新的仓库中（提交历史纪录也导过去的一点经验</p>\n</blockquote>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>origin_seed(名字可自取，临时用，\b迁完后，\b主动取消关联) 区别于origin 目的在于将当前仓库(分支)新关联到新的仓库</p>\n<p>新建一个仓库，假设仓库名为<a href=\"https://github.com/BiYuqi/webpack-seed\" target=\"_blank\" rel=\"external\">webpack-seed</a></p>\n<h3 id=\"切换仓库\"><a href=\"#切换仓库\" class=\"headerlink\" title=\"切换仓库\"></a>切换仓库</h3><p>切换到旧仓库(将要迁走的仓库下, 分支自己选, 或者默认迁走master)，然后关联新仓库</p>\n<pre><code class=\"js\">git remove add origin_seed https://github.com/BiYuqi/webpack-seed.git (你的新仓库地址)\n</code></pre>\n<h3 id=\"推送到新的仓库\"><a href=\"#推送到新的仓库\" class=\"headerlink\" title=\"推送到新的仓库\"></a>推送到新的仓库</h3><ul>\n<li>此处是将旧仓库下 web-ejs-pc 分支推送到新仓库master分支, 分支根据需要自己填写<pre><code class=\"js\">git -u push origin_seed web-ejs-pc:master\n</code></pre>\n</li>\n</ul>\n<h3 id=\"取消关联，原有仓库恢复原样\"><a href=\"#取消关联，原有仓库恢复原样\" class=\"headerlink\" title=\"取消关联，原有仓库恢复原样\"></a>取消关联，原有仓库恢复原样</h3><pre><code class=\"js\">git remote remove origin_seed\n</code></pre>\n<p>至此，可以去查看新仓库是否\b迁移成功.</p>\n"},{"title":"Hello World","date":"2016-11-12T12:18:51.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-11-12 20:18:51\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-09-25T15:10:25.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ot002ola2e0017n8vk","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.<br><a id=\"more\"></a></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.<br>","more":"</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>"},{"title":"linux之bash命令基础","date":"2019-10-02T05:05:29.000Z","_content":"\n## <span id=\"dir\">常见linux目录</span>\n\n目录 | 用途\n----- | -----\n/ | 虚拟目录的根目录, 通常不会在这里存储文件\n/bin | 二进制目录, 存放许多用户级的[GNU]()工具\n/boot | 启动目录, 存放启动文件\n/dev | 设备目录, linux在这里创建设备节点\n/etc | 系统配置文件目录\n/home | 主目录, Linux在这里创建用户\n/lib | 库目录, 存放系统和应用程序的库文件\n/media | 媒体目录, 可移动媒体设备的常用挂载点\n/mnt | 挂载目录, 另一个即可移动媒体设备的常用挂载点\n/opt | 可选目录m 常用语存放第三方软件包和数据文件\n/proc | 进程目录, 存放现有硬件及当前进程的相关信息\n/root | root用户的主目录\n/sbin | 系统二进制目录，存放许多[GNU]管理工具\n/run | 运行目录, 存放系统运作时的运行数据\n/srv | 服务目录, 存放本地服务的相关文件\n/sys | 系统目录, 存放系统硬件信息的相关文件\n/tmp | 临时目录, 可以在该目录中创建和删除临时工作文件\n/usr | 用户二进制目录, 大量用户级的[GNU]工具和数据文件都存储在这里\n/var | 可变目录, 用以存放经常变化的文件，比如日志文件\n\n## <span id=\"file-dir\">文件和目录列表</span>\n\n**显示当前文件和目录**\n\n```shell\n» ls\n```\n```js\nREADME-zh_CN.md      commitlint.config.js example              node_modules\nREADME.md            docs                 lerna.json           package-lock.json\n```\nls是按字母排序的, 可以带参数 `-F` 用来区分文件和目录\n```shell\n» ls -F\n```\n```js\nREADME-zh_CN.md       commitlint.config.js  example/              node_modules/\nREADME.md             docs/                 lerna.json            package-lock.json\n```\n`-F`参数在目录后面加了正斜线(/)\n\n**显示隐藏文件**\n利用参数 `-a`来显示隐藏文件和普通文件, 所有以点号开始的隐藏文件都显示出来了\n```shell\n» ls -a\n```\n```js\n.git                 README-zh_CN.md      commitlint.config.js example              node_modules\n..                   .gitignore           README.md            docs                 lerna.json \n```\n**显示长列表**\n利用`ls -l`产生每个文件的更多信息, 比如目录(d), 文件(-), 字符型文件(c)或者块设备(b)\n```shell\n» ls -l\n```\n```js\n» ls -l\ntotal 176\n-rw-r--r--  1 yuqi.bi  staff   4453 Sep 25 23:10 _config.yml\n-rw-r--r--  1 yuqi.bi  staff  77732 Sep 25 23:10 package-lock.json\n-rw-r--r--  1 yuqi.bi  staff    667 Sep 25 23:10 package.json\ndrwxr-xr-x  5 yuqi.bi  staff    160 Sep 25 23:10 scaffolds\ndrwxr-xr-x  9 yuqi.bi  staff    288 Sep 25 23:10 source\n```\n\n**过滤输出列表**\n`ls` 会输出很多信息，可以针对目标文件进行过滤搜索,这里支持的是正则表达式\n\n```shell\n# 搜索以——conf开头的文件\n» ls -l _confi*\n```\n```js\n» ls -l _confi*\n-rw-r--r--  1 yuqi.bi  staff  4453 Sep 25 23:10 _config.yml\n```\n\n## <span id=\"handle-doc\">处理文件</span>\n\n**创建文件**\n\n```shell\n» touch test_one\n» ls -l test_one\n```\n显示如下：\n```js\n-rw-r--r--  1 [Here is your user name]  staff  0 Oct  3 00:06 test_one\n```\n\n`ls -l` 不会直接显示访问时间，默认是显示修改时间，如需查看需啊哟加上`--time=attime`\n\n```shell\n» ls -l --time=attime test_one \n```\n\n**复制文件**\n`cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file`\n\n基本用法： `cp 命令需要两个参数--源对象和目标对象`\n\n```shell\n» cp source destination\n```\n当source和destination 参数是文件名时，cp命令将源文件复制成一个新文件，并命名为destination.\n\neg:\n\n```shell\n» cp test_one test_two\n```\n如果目标文件已经存在，cp命令并不会提示，所以可以加`-i`来强制shell提示是否覆盖.\n```shell\n~/Desktop » cp -i test_one test_two\noverwrite test_two? (y/n [n])\n```\ncp命令`-R`参数可以递归的复制整个目录文件\n\n```shell\n» cp -R source/ target\n```\n\n也可以在cp命令中使用通配符\n\n```bash\n» cp *script new_script/\n```\n该命令静所有以script结尾的文件赋值到new_script目录中，可以通过`ls -l new_script`查看\n\n**重命名文件**\n\n`mv [-f | -i | -n] [-v] source target`\n\nmv命令可以将文件和目录移动到另一个位置或者重新命名.\n\n> Create directory `linux-demo` with demo file and demo dir\n\n```bash\n» ls -lF\ntotal 0\ndrwxr-xr-x  2 yuqi.bi staff  64 Oct  4 15:48 demo/\n-rw-r--r--  1 yuqi.bi staff   0 Oct  4 15:48 demo.txt\n```\n\n执行mv命令\n```shell\n» mv demo demo-with-mv\n\n» ls -lF de*\ntotal 0\ndrwxr-xr-x  2 yuqi.bi  staff  64 Oct  4 15:48 demo-with-mv/\n-rw-r--r--  1 yuqi.bi  staff   0 Oct  4 15:48 demo.txt\n```\n也可以使用mv移动位置并修改文件名称\n\n```shell\n» mv linux-demo linux-demo2\n```\n\n**删除文件**\n\n`rm [-dfiPRrvW] file ...`\n\n```shell\n» rm -i demo.txt\n```\n`-i` 提示是不是要真的删除文件\n\n如果要删除很多文件不受提示干扰，可用`-f` 强制删除 `-rf`递归强制删除\n\n```shell\n» rm -rf demo.txt\n```\n\n## <span id=\"handle-dir\">处理目录</span>\n\n**创建目录**\n\n`mkdir [-pv] [-m mode] directory_name ...`\n\n```shell\n» mkdir new_dir\n```\n\n如果想批量创建目录和子目录，需要加上`-p`, 可以根据需要创建缺失目录.\n\n```shell\n» mkdir -p new_dir/sub_dir_child_dir\n```\n\n**删除目录**\n\n`rmdir [-p] directory ...`\n\n默认情况下`rmdir`只删除非空目录, 只能先删除文件，才能删除目录\n\n所以想要一口气删除所有文件，还是需要用到`rm -rf [target dir name]`\n\n## <span id=\"cat-file\">查看文件</span>\n\n`file [-bcdDhiIkLnNprsvz] [--extension] [--mime-encoding] [--mime-type] [-f namefile] [-m magicfiles] [-P name=value]`\n\nfile命令是一个能够探测文件内部的工具\n\n**查看文件类型**\n```shell\n» file demo.text\n```\n会返回文件的类型\n\n**查看整个文件**\n\n- cat命令\n\n```shell\ncat demo.txt\n```\n\n`-n` 可以给所有行加上行号\n`-b` 可以只给文本行添加行号\n`-T` 移除制表符\n\n**查看部分文件**\n\n- tail 命令\n显示文件最后几行的内容\n\n`tail [-F | -f | -r] [-q] [-b number | -c number | -n number] [file ...]`\n\n`tail -n number [file]` 显示指定行数的内容\n\n- head 命令\n\n`head [-n count | -c bytes] [file ...]\n`\n查看文件起始内容\n\n```shell\n» head -n [number] [file] \n```\n\n## <span id=\"search-data\">搜索数据</span>\n\n`grep [options] pattern [file]`\n\ngrep命令会在输入或指定的文件中查找包含匹配指定模式的字符的行, 它的输出就是包含了匹配模式的行.\n\neg: 在demo.js文件中找到含有`key`的行\n```shell\n» grep key demo.js\n```\n\n- 如果进行方向搜索(即不匹配该行), 加`-v`\n```shell\n» grep -v key demo.js\n```\n\n- 如果要显示匹配模式的行所在行号, 加`-n`\n```shell\n» grep -n key demo.js\n```\n\n- 如果想知道有多少行匹配, 加`-c`\n```shell\n» grep -c key demo.js\n```\n\n- 如果要制定多个匹配模式, 加`-e`指定每一个模式\n```shell\n» grep -e key -e word demo.js\n```\n\n- 支持正则表达式\n```shell\n» grep [k-z] demo.js\n```","source":"_posts/linux之bash命令基础.md","raw":"---\ntitle: linux之bash命令基础\ndate: 2019-10-02 13:05:29\ntags: [linux, bash, shell]\ncategories: Linux\n---\n\n## <span id=\"dir\">常见linux目录</span>\n\n目录 | 用途\n----- | -----\n/ | 虚拟目录的根目录, 通常不会在这里存储文件\n/bin | 二进制目录, 存放许多用户级的[GNU]()工具\n/boot | 启动目录, 存放启动文件\n/dev | 设备目录, linux在这里创建设备节点\n/etc | 系统配置文件目录\n/home | 主目录, Linux在这里创建用户\n/lib | 库目录, 存放系统和应用程序的库文件\n/media | 媒体目录, 可移动媒体设备的常用挂载点\n/mnt | 挂载目录, 另一个即可移动媒体设备的常用挂载点\n/opt | 可选目录m 常用语存放第三方软件包和数据文件\n/proc | 进程目录, 存放现有硬件及当前进程的相关信息\n/root | root用户的主目录\n/sbin | 系统二进制目录，存放许多[GNU]管理工具\n/run | 运行目录, 存放系统运作时的运行数据\n/srv | 服务目录, 存放本地服务的相关文件\n/sys | 系统目录, 存放系统硬件信息的相关文件\n/tmp | 临时目录, 可以在该目录中创建和删除临时工作文件\n/usr | 用户二进制目录, 大量用户级的[GNU]工具和数据文件都存储在这里\n/var | 可变目录, 用以存放经常变化的文件，比如日志文件\n\n## <span id=\"file-dir\">文件和目录列表</span>\n\n**显示当前文件和目录**\n\n```shell\n» ls\n```\n```js\nREADME-zh_CN.md      commitlint.config.js example              node_modules\nREADME.md            docs                 lerna.json           package-lock.json\n```\nls是按字母排序的, 可以带参数 `-F` 用来区分文件和目录\n```shell\n» ls -F\n```\n```js\nREADME-zh_CN.md       commitlint.config.js  example/              node_modules/\nREADME.md             docs/                 lerna.json            package-lock.json\n```\n`-F`参数在目录后面加了正斜线(/)\n\n**显示隐藏文件**\n利用参数 `-a`来显示隐藏文件和普通文件, 所有以点号开始的隐藏文件都显示出来了\n```shell\n» ls -a\n```\n```js\n.git                 README-zh_CN.md      commitlint.config.js example              node_modules\n..                   .gitignore           README.md            docs                 lerna.json \n```\n**显示长列表**\n利用`ls -l`产生每个文件的更多信息, 比如目录(d), 文件(-), 字符型文件(c)或者块设备(b)\n```shell\n» ls -l\n```\n```js\n» ls -l\ntotal 176\n-rw-r--r--  1 yuqi.bi  staff   4453 Sep 25 23:10 _config.yml\n-rw-r--r--  1 yuqi.bi  staff  77732 Sep 25 23:10 package-lock.json\n-rw-r--r--  1 yuqi.bi  staff    667 Sep 25 23:10 package.json\ndrwxr-xr-x  5 yuqi.bi  staff    160 Sep 25 23:10 scaffolds\ndrwxr-xr-x  9 yuqi.bi  staff    288 Sep 25 23:10 source\n```\n\n**过滤输出列表**\n`ls` 会输出很多信息，可以针对目标文件进行过滤搜索,这里支持的是正则表达式\n\n```shell\n# 搜索以——conf开头的文件\n» ls -l _confi*\n```\n```js\n» ls -l _confi*\n-rw-r--r--  1 yuqi.bi  staff  4453 Sep 25 23:10 _config.yml\n```\n\n## <span id=\"handle-doc\">处理文件</span>\n\n**创建文件**\n\n```shell\n» touch test_one\n» ls -l test_one\n```\n显示如下：\n```js\n-rw-r--r--  1 [Here is your user name]  staff  0 Oct  3 00:06 test_one\n```\n\n`ls -l` 不会直接显示访问时间，默认是显示修改时间，如需查看需啊哟加上`--time=attime`\n\n```shell\n» ls -l --time=attime test_one \n```\n\n**复制文件**\n`cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file`\n\n基本用法： `cp 命令需要两个参数--源对象和目标对象`\n\n```shell\n» cp source destination\n```\n当source和destination 参数是文件名时，cp命令将源文件复制成一个新文件，并命名为destination.\n\neg:\n\n```shell\n» cp test_one test_two\n```\n如果目标文件已经存在，cp命令并不会提示，所以可以加`-i`来强制shell提示是否覆盖.\n```shell\n~/Desktop » cp -i test_one test_two\noverwrite test_two? (y/n [n])\n```\ncp命令`-R`参数可以递归的复制整个目录文件\n\n```shell\n» cp -R source/ target\n```\n\n也可以在cp命令中使用通配符\n\n```bash\n» cp *script new_script/\n```\n该命令静所有以script结尾的文件赋值到new_script目录中，可以通过`ls -l new_script`查看\n\n**重命名文件**\n\n`mv [-f | -i | -n] [-v] source target`\n\nmv命令可以将文件和目录移动到另一个位置或者重新命名.\n\n> Create directory `linux-demo` with demo file and demo dir\n\n```bash\n» ls -lF\ntotal 0\ndrwxr-xr-x  2 yuqi.bi staff  64 Oct  4 15:48 demo/\n-rw-r--r--  1 yuqi.bi staff   0 Oct  4 15:48 demo.txt\n```\n\n执行mv命令\n```shell\n» mv demo demo-with-mv\n\n» ls -lF de*\ntotal 0\ndrwxr-xr-x  2 yuqi.bi  staff  64 Oct  4 15:48 demo-with-mv/\n-rw-r--r--  1 yuqi.bi  staff   0 Oct  4 15:48 demo.txt\n```\n也可以使用mv移动位置并修改文件名称\n\n```shell\n» mv linux-demo linux-demo2\n```\n\n**删除文件**\n\n`rm [-dfiPRrvW] file ...`\n\n```shell\n» rm -i demo.txt\n```\n`-i` 提示是不是要真的删除文件\n\n如果要删除很多文件不受提示干扰，可用`-f` 强制删除 `-rf`递归强制删除\n\n```shell\n» rm -rf demo.txt\n```\n\n## <span id=\"handle-dir\">处理目录</span>\n\n**创建目录**\n\n`mkdir [-pv] [-m mode] directory_name ...`\n\n```shell\n» mkdir new_dir\n```\n\n如果想批量创建目录和子目录，需要加上`-p`, 可以根据需要创建缺失目录.\n\n```shell\n» mkdir -p new_dir/sub_dir_child_dir\n```\n\n**删除目录**\n\n`rmdir [-p] directory ...`\n\n默认情况下`rmdir`只删除非空目录, 只能先删除文件，才能删除目录\n\n所以想要一口气删除所有文件，还是需要用到`rm -rf [target dir name]`\n\n## <span id=\"cat-file\">查看文件</span>\n\n`file [-bcdDhiIkLnNprsvz] [--extension] [--mime-encoding] [--mime-type] [-f namefile] [-m magicfiles] [-P name=value]`\n\nfile命令是一个能够探测文件内部的工具\n\n**查看文件类型**\n```shell\n» file demo.text\n```\n会返回文件的类型\n\n**查看整个文件**\n\n- cat命令\n\n```shell\ncat demo.txt\n```\n\n`-n` 可以给所有行加上行号\n`-b` 可以只给文本行添加行号\n`-T` 移除制表符\n\n**查看部分文件**\n\n- tail 命令\n显示文件最后几行的内容\n\n`tail [-F | -f | -r] [-q] [-b number | -c number | -n number] [file ...]`\n\n`tail -n number [file]` 显示指定行数的内容\n\n- head 命令\n\n`head [-n count | -c bytes] [file ...]\n`\n查看文件起始内容\n\n```shell\n» head -n [number] [file] \n```\n\n## <span id=\"search-data\">搜索数据</span>\n\n`grep [options] pattern [file]`\n\ngrep命令会在输入或指定的文件中查找包含匹配指定模式的字符的行, 它的输出就是包含了匹配模式的行.\n\neg: 在demo.js文件中找到含有`key`的行\n```shell\n» grep key demo.js\n```\n\n- 如果进行方向搜索(即不匹配该行), 加`-v`\n```shell\n» grep -v key demo.js\n```\n\n- 如果要显示匹配模式的行所在行号, 加`-n`\n```shell\n» grep -n key demo.js\n```\n\n- 如果想知道有多少行匹配, 加`-c`\n```shell\n» grep -c key demo.js\n```\n\n- 如果要制定多个匹配模式, 加`-e`指定每一个模式\n```shell\n» grep -e key -e word demo.js\n```\n\n- 支持正则表达式\n```shell\n» grep [k-z] demo.js\n```","slug":"linux之bash命令基础","published":1,"updated":"2019-10-20T07:33:07.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ov002rla2eknio7xh3","content":"<h2 id=\"常见linux目录\"><a href=\"#常见linux目录\" class=\"headerlink\" title=\"常见linux目录\"></a><span id=\"dir\">常见linux目录</span></h2><table>\n<thead>\n<tr>\n<th>目录</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/</td>\n<td>虚拟目录的根目录, 通常不会在这里存储文件</td>\n</tr>\n<tr>\n<td>/bin</td>\n<td>二进制目录, 存放许多用户级的<a href=\"\">GNU</a>工具</td>\n</tr>\n<tr>\n<td>/boot</td>\n<td>启动目录, 存放启动文件</td>\n</tr>\n<tr>\n<td>/dev</td>\n<td>设备目录, linux在这里创建设备节点</td>\n</tr>\n<tr>\n<td>/etc</td>\n<td>系统配置文件目录</td>\n</tr>\n<tr>\n<td>/home</td>\n<td>主目录, Linux在这里创建用户</td>\n</tr>\n<tr>\n<td>/lib</td>\n<td>库目录, 存放系统和应用程序的库文件</td>\n</tr>\n<tr>\n<td>/media</td>\n<td>媒体目录, 可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>/mnt</td>\n<td>挂载目录, 另一个即可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>/opt</td>\n<td>可选目录m 常用语存放第三方软件包和数据文件</td>\n</tr>\n<tr>\n<td>/proc</td>\n<td>进程目录, 存放现有硬件及当前进程的相关信息</td>\n</tr>\n<tr>\n<td>/root</td>\n<td>root用户的主目录</td>\n</tr>\n<tr>\n<td>/sbin</td>\n<td>系统二进制目录，存放许多[GNU]管理工具</td>\n</tr>\n<tr>\n<td>/run</td>\n<td>运行目录, 存放系统运作时的运行数据</td>\n</tr>\n<tr>\n<td>/srv</td>\n<td>服务目录, 存放本地服务的相关文件</td>\n</tr>\n<tr>\n<td>/sys</td>\n<td>系统目录, 存放系统硬件信息的相关文件</td>\n</tr>\n<tr>\n<td>/tmp</td>\n<td>临时目录, 可以在该目录中创建和删除临时工作文件</td>\n</tr>\n<tr>\n<td>/usr</td>\n<td>用户二进制目录, 大量用户级的[GNU]工具和数据文件都存储在这里</td>\n</tr>\n<tr>\n<td>/var</td>\n<td>可变目录, 用以存放经常变化的文件，比如日志文件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"文件和目录列表\"><a href=\"#文件和目录列表\" class=\"headerlink\" title=\"文件和目录列表\"></a><span id=\"file-dir\">文件和目录列表</span></h2><p><strong>显示当前文件和目录</strong></p>\n<pre><code class=\"shell\">» ls\n</code></pre>\n<pre><code class=\"js\">README-zh_CN.md      commitlint.config.js example              node_modules\nREADME.md            docs                 lerna.json           package-lock.json\n</code></pre>\n<p>ls是按字母排序的, 可以带参数 <code>-F</code> 用来区分文件和目录</p>\n<pre><code class=\"shell\">» ls -F\n</code></pre>\n<pre><code class=\"js\">README-zh_CN.md       commitlint.config.js  example/              node_modules/\nREADME.md             docs/                 lerna.json            package-lock.json\n</code></pre>\n<p><code>-F</code>参数在目录后面加了正斜线(/)</p>\n<p><strong>显示隐藏文件</strong><br>利用参数 <code>-a</code>来显示隐藏文件和普通文件, 所有以点号开始的隐藏文件都显示出来了</p>\n<pre><code class=\"shell\">» ls -a\n</code></pre>\n<pre><code class=\"js\">.git                 README-zh_CN.md      commitlint.config.js example              node_modules\n..                   .gitignore           README.md            docs                 lerna.json\n</code></pre>\n<p><strong>显示长列表</strong><br>利用<code>ls -l</code>产生每个文件的更多信息, 比如目录(d), 文件(-), 字符型文件(c)或者块设备(b)</p>\n<pre><code class=\"shell\">» ls -l\n</code></pre>\n<pre><code class=\"js\">» ls -l\ntotal 176\n-rw-r--r--  1 yuqi.bi  staff   4453 Sep 25 23:10 _config.yml\n-rw-r--r--  1 yuqi.bi  staff  77732 Sep 25 23:10 package-lock.json\n-rw-r--r--  1 yuqi.bi  staff    667 Sep 25 23:10 package.json\ndrwxr-xr-x  5 yuqi.bi  staff    160 Sep 25 23:10 scaffolds\ndrwxr-xr-x  9 yuqi.bi  staff    288 Sep 25 23:10 source\n</code></pre>\n<p><strong>过滤输出列表</strong><br><code>ls</code> 会输出很多信息，可以针对目标文件进行过滤搜索,这里支持的是正则表达式</p>\n<pre><code class=\"shell\"># 搜索以——conf开头的文件\n» ls -l _confi*\n</code></pre>\n<pre><code class=\"js\">» ls -l _confi*\n-rw-r--r--  1 yuqi.bi  staff  4453 Sep 25 23:10 _config.yml\n</code></pre>\n<h2 id=\"处理文件\"><a href=\"#处理文件\" class=\"headerlink\" title=\"处理文件\"></a><span id=\"handle-doc\">处理文件</span></h2><p><strong>创建文件</strong></p>\n<pre><code class=\"shell\">» touch test_one\n» ls -l test_one\n</code></pre>\n<p>显示如下：</p>\n<pre><code class=\"js\">-rw-r--r--  1 [Here is your user name]  staff  0 Oct  3 00:06 test_one\n</code></pre>\n<p><code>ls -l</code> 不会直接显示访问时间，默认是显示修改时间，如需查看需啊哟加上<code>--time=attime</code></p>\n<pre><code class=\"shell\">» ls -l --time=attime test_one\n</code></pre>\n<p><strong>复制文件</strong><br><code>cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file</code></p>\n<p>基本用法： <code>cp 命令需要两个参数--源对象和目标对象</code></p>\n<pre><code class=\"shell\">» cp source destination\n</code></pre>\n<p>当source和destination 参数是文件名时，cp命令将源文件复制成一个新文件，并命名为destination.</p>\n<p>eg:</p>\n<pre><code class=\"shell\">» cp test_one test_two\n</code></pre>\n<p>如果目标文件已经存在，cp命令并不会提示，所以可以加<code>-i</code>来强制shell提示是否覆盖.</p>\n<pre><code class=\"shell\">~/Desktop » cp -i test_one test_two\noverwrite test_two? (y/n [n])\n</code></pre>\n<p>cp命令<code>-R</code>参数可以递归的复制整个目录文件</p>\n<pre><code class=\"shell\">» cp -R source/ target\n</code></pre>\n<p>也可以在cp命令中使用通配符</p>\n<pre><code class=\"bash\">» cp *script new_script/\n</code></pre>\n<p>该命令静所有以script结尾的文件赋值到new_script目录中，可以通过<code>ls -l new_script</code>查看</p>\n<p><strong>重命名文件</strong></p>\n<p><code>mv [-f | -i | -n] [-v] source target</code></p>\n<p>mv命令可以将文件和目录移动到另一个位置或者重新命名.</p>\n<blockquote>\n<p>Create directory <code>linux-demo</code> with demo file and demo dir</p>\n</blockquote>\n<pre><code class=\"bash\">» ls -lF\ntotal 0\ndrwxr-xr-x  2 yuqi.bi staff  64 Oct  4 15:48 demo/\n-rw-r--r--  1 yuqi.bi staff   0 Oct  4 15:48 demo.txt\n</code></pre>\n<p>执行mv命令</p>\n<pre><code class=\"shell\">» mv demo demo-with-mv\n\n» ls -lF de*\ntotal 0\ndrwxr-xr-x  2 yuqi.bi  staff  64 Oct  4 15:48 demo-with-mv/\n-rw-r--r--  1 yuqi.bi  staff   0 Oct  4 15:48 demo.txt\n</code></pre>\n<p>也可以使用mv移动位置并修改文件名称</p>\n<pre><code class=\"shell\">» mv linux-demo linux-demo2\n</code></pre>\n<p><strong>删除文件</strong></p>\n<p><code>rm [-dfiPRrvW] file ...</code></p>\n<pre><code class=\"shell\">» rm -i demo.txt\n</code></pre>\n<p><code>-i</code> 提示是不是要真的删除文件</p>\n<p>如果要删除很多文件不受提示干扰，可用<code>-f</code> 强制删除 <code>-rf</code>递归强制删除</p>\n<pre><code class=\"shell\">» rm -rf demo.txt\n</code></pre>\n<h2 id=\"处理目录\"><a href=\"#处理目录\" class=\"headerlink\" title=\"处理目录\"></a><span id=\"handle-dir\">处理目录</span></h2><p><strong>创建目录</strong></p>\n<p><code>mkdir [-pv] [-m mode] directory_name ...</code></p>\n<pre><code class=\"shell\">» mkdir new_dir\n</code></pre>\n<p>如果想批量创建目录和子目录，需要加上<code>-p</code>, 可以根据需要创建缺失目录.</p>\n<pre><code class=\"shell\">» mkdir -p new_dir/sub_dir_child_dir\n</code></pre>\n<p><strong>删除目录</strong></p>\n<p><code>rmdir [-p] directory ...</code></p>\n<p>默认情况下<code>rmdir</code>只删除非空目录, 只能先删除文件，才能删除目录</p>\n<p>所以想要一口气删除所有文件，还是需要用到<code>rm -rf [target dir name]</code></p>\n<h2 id=\"查看文件\"><a href=\"#查看文件\" class=\"headerlink\" title=\"查看文件\"></a><span id=\"cat-file\">查看文件</span></h2><p><code>file [-bcdDhiIkLnNprsvz] [--extension] [--mime-encoding] [--mime-type] [-f namefile] [-m magicfiles] [-P name=value]</code></p>\n<p>file命令是一个能够探测文件内部的工具</p>\n<p><strong>查看文件类型</strong></p>\n<pre><code class=\"shell\">» file demo.text\n</code></pre>\n<p>会返回文件的类型</p>\n<p><strong>查看整个文件</strong></p>\n<ul>\n<li>cat命令</li>\n</ul>\n<pre><code class=\"shell\">cat demo.txt\n</code></pre>\n<p><code>-n</code> 可以给所有行加上行号<br><code>-b</code> 可以只给文本行添加行号<br><code>-T</code> 移除制表符</p>\n<p><strong>查看部分文件</strong></p>\n<ul>\n<li>tail 命令<br>显示文件最后几行的内容</li>\n</ul>\n<p><code>tail [-F | -f | -r] [-q] [-b number | -c number | -n number] [file ...]</code></p>\n<p><code>tail -n number [file]</code> 显示指定行数的内容</p>\n<ul>\n<li>head 命令</li>\n</ul>\n<p><code>head [-n count | -c bytes] [file ...]</code><br>查看文件起始内容</p>\n<pre><code class=\"shell\">» head -n [number] [file]\n</code></pre>\n<h2 id=\"搜索数据\"><a href=\"#搜索数据\" class=\"headerlink\" title=\"搜索数据\"></a><span id=\"search-data\">搜索数据</span></h2><p><code>grep [options] pattern [file]</code></p>\n<p>grep命令会在输入或指定的文件中查找包含匹配指定模式的字符的行, 它的输出就是包含了匹配模式的行.</p>\n<p>eg: 在demo.js文件中找到含有<code>key</code>的行</p>\n<pre><code class=\"shell\">» grep key demo.js\n</code></pre>\n<ul>\n<li><p>如果进行方向搜索(即不匹配该行), 加<code>-v</code></p>\n<pre><code class=\"shell\">» grep -v key demo.js\n</code></pre>\n</li>\n<li><p>如果要显示匹配模式的行所在行号, 加<code>-n</code></p>\n<pre><code class=\"shell\">» grep -n key demo.js\n</code></pre>\n</li>\n<li><p>如果想知道有多少行匹配, 加<code>-c</code></p>\n<pre><code class=\"shell\">» grep -c key demo.js\n</code></pre>\n</li>\n<li><p>如果要制定多个匹配模式, 加<code>-e</code>指定每一个模式</p>\n<pre><code class=\"shell\">» grep -e key -e word demo.js\n</code></pre>\n</li>\n<li><p>支持正则表达式</p>\n<pre><code class=\"shell\">» grep [k-z] demo.js\n</code></pre>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常见linux目录\"><a href=\"#常见linux目录\" class=\"headerlink\" title=\"常见linux目录\"></a><span id=\"dir\">常见linux目录</span></h2><table>\n<thead>\n<tr>\n<th>目录</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/</td>\n<td>虚拟目录的根目录, 通常不会在这里存储文件</td>\n</tr>\n<tr>\n<td>/bin</td>\n<td>二进制目录, 存放许多用户级的<a href=\"\">GNU</a>工具</td>\n</tr>\n<tr>\n<td>/boot</td>\n<td>启动目录, 存放启动文件</td>\n</tr>\n<tr>\n<td>/dev</td>\n<td>设备目录, linux在这里创建设备节点</td>\n</tr>\n<tr>\n<td>/etc</td>\n<td>系统配置文件目录</td>\n</tr>\n<tr>\n<td>/home</td>\n<td>主目录, Linux在这里创建用户</td>\n</tr>\n<tr>\n<td>/lib</td>\n<td>库目录, 存放系统和应用程序的库文件</td>\n</tr>\n<tr>\n<td>/media</td>\n<td>媒体目录, 可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>/mnt</td>\n<td>挂载目录, 另一个即可移动媒体设备的常用挂载点</td>\n</tr>\n<tr>\n<td>/opt</td>\n<td>可选目录m 常用语存放第三方软件包和数据文件</td>\n</tr>\n<tr>\n<td>/proc</td>\n<td>进程目录, 存放现有硬件及当前进程的相关信息</td>\n</tr>\n<tr>\n<td>/root</td>\n<td>root用户的主目录</td>\n</tr>\n<tr>\n<td>/sbin</td>\n<td>系统二进制目录，存放许多[GNU]管理工具</td>\n</tr>\n<tr>\n<td>/run</td>\n<td>运行目录, 存放系统运作时的运行数据</td>\n</tr>\n<tr>\n<td>/srv</td>\n<td>服务目录, 存放本地服务的相关文件</td>\n</tr>\n<tr>\n<td>/sys</td>\n<td>系统目录, 存放系统硬件信息的相关文件</td>\n</tr>\n<tr>\n<td>/tmp</td>\n<td>临时目录, 可以在该目录中创建和删除临时工作文件</td>\n</tr>\n<tr>\n<td>/usr</td>\n<td>用户二进制目录, 大量用户级的[GNU]工具和数据文件都存储在这里</td>\n</tr>\n<tr>\n<td>/var</td>\n<td>可变目录, 用以存放经常变化的文件，比如日志文件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"文件和目录列表\"><a href=\"#文件和目录列表\" class=\"headerlink\" title=\"文件和目录列表\"></a><span id=\"file-dir\">文件和目录列表</span></h2><p><strong>显示当前文件和目录</strong></p>\n<pre><code class=\"shell\">» ls\n</code></pre>\n<pre><code class=\"js\">README-zh_CN.md      commitlint.config.js example              node_modules\nREADME.md            docs                 lerna.json           package-lock.json\n</code></pre>\n<p>ls是按字母排序的, 可以带参数 <code>-F</code> 用来区分文件和目录</p>\n<pre><code class=\"shell\">» ls -F\n</code></pre>\n<pre><code class=\"js\">README-zh_CN.md       commitlint.config.js  example/              node_modules/\nREADME.md             docs/                 lerna.json            package-lock.json\n</code></pre>\n<p><code>-F</code>参数在目录后面加了正斜线(/)</p>\n<p><strong>显示隐藏文件</strong><br>利用参数 <code>-a</code>来显示隐藏文件和普通文件, 所有以点号开始的隐藏文件都显示出来了</p>\n<pre><code class=\"shell\">» ls -a\n</code></pre>\n<pre><code class=\"js\">.git                 README-zh_CN.md      commitlint.config.js example              node_modules\n..                   .gitignore           README.md            docs                 lerna.json\n</code></pre>\n<p><strong>显示长列表</strong><br>利用<code>ls -l</code>产生每个文件的更多信息, 比如目录(d), 文件(-), 字符型文件(c)或者块设备(b)</p>\n<pre><code class=\"shell\">» ls -l\n</code></pre>\n<pre><code class=\"js\">» ls -l\ntotal 176\n-rw-r--r--  1 yuqi.bi  staff   4453 Sep 25 23:10 _config.yml\n-rw-r--r--  1 yuqi.bi  staff  77732 Sep 25 23:10 package-lock.json\n-rw-r--r--  1 yuqi.bi  staff    667 Sep 25 23:10 package.json\ndrwxr-xr-x  5 yuqi.bi  staff    160 Sep 25 23:10 scaffolds\ndrwxr-xr-x  9 yuqi.bi  staff    288 Sep 25 23:10 source\n</code></pre>\n<p><strong>过滤输出列表</strong><br><code>ls</code> 会输出很多信息，可以针对目标文件进行过滤搜索,这里支持的是正则表达式</p>\n<pre><code class=\"shell\"># 搜索以——conf开头的文件\n» ls -l _confi*\n</code></pre>\n<pre><code class=\"js\">» ls -l _confi*\n-rw-r--r--  1 yuqi.bi  staff  4453 Sep 25 23:10 _config.yml\n</code></pre>\n<h2 id=\"处理文件\"><a href=\"#处理文件\" class=\"headerlink\" title=\"处理文件\"></a><span id=\"handle-doc\">处理文件</span></h2><p><strong>创建文件</strong></p>\n<pre><code class=\"shell\">» touch test_one\n» ls -l test_one\n</code></pre>\n<p>显示如下：</p>\n<pre><code class=\"js\">-rw-r--r--  1 [Here is your user name]  staff  0 Oct  3 00:06 test_one\n</code></pre>\n<p><code>ls -l</code> 不会直接显示访问时间，默认是显示修改时间，如需查看需啊哟加上<code>--time=attime</code></p>\n<pre><code class=\"shell\">» ls -l --time=attime test_one\n</code></pre>\n<p><strong>复制文件</strong><br><code>cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file</code></p>\n<p>基本用法： <code>cp 命令需要两个参数--源对象和目标对象</code></p>\n<pre><code class=\"shell\">» cp source destination\n</code></pre>\n<p>当source和destination 参数是文件名时，cp命令将源文件复制成一个新文件，并命名为destination.</p>\n<p>eg:</p>\n<pre><code class=\"shell\">» cp test_one test_two\n</code></pre>\n<p>如果目标文件已经存在，cp命令并不会提示，所以可以加<code>-i</code>来强制shell提示是否覆盖.</p>\n<pre><code class=\"shell\">~/Desktop » cp -i test_one test_two\noverwrite test_two? (y/n [n])\n</code></pre>\n<p>cp命令<code>-R</code>参数可以递归的复制整个目录文件</p>\n<pre><code class=\"shell\">» cp -R source/ target\n</code></pre>\n<p>也可以在cp命令中使用通配符</p>\n<pre><code class=\"bash\">» cp *script new_script/\n</code></pre>\n<p>该命令静所有以script结尾的文件赋值到new_script目录中，可以通过<code>ls -l new_script</code>查看</p>\n<p><strong>重命名文件</strong></p>\n<p><code>mv [-f | -i | -n] [-v] source target</code></p>\n<p>mv命令可以将文件和目录移动到另一个位置或者重新命名.</p>\n<blockquote>\n<p>Create directory <code>linux-demo</code> with demo file and demo dir</p>\n</blockquote>\n<pre><code class=\"bash\">» ls -lF\ntotal 0\ndrwxr-xr-x  2 yuqi.bi staff  64 Oct  4 15:48 demo/\n-rw-r--r--  1 yuqi.bi staff   0 Oct  4 15:48 demo.txt\n</code></pre>\n<p>执行mv命令</p>\n<pre><code class=\"shell\">» mv demo demo-with-mv\n\n» ls -lF de*\ntotal 0\ndrwxr-xr-x  2 yuqi.bi  staff  64 Oct  4 15:48 demo-with-mv/\n-rw-r--r--  1 yuqi.bi  staff   0 Oct  4 15:48 demo.txt\n</code></pre>\n<p>也可以使用mv移动位置并修改文件名称</p>\n<pre><code class=\"shell\">» mv linux-demo linux-demo2\n</code></pre>\n<p><strong>删除文件</strong></p>\n<p><code>rm [-dfiPRrvW] file ...</code></p>\n<pre><code class=\"shell\">» rm -i demo.txt\n</code></pre>\n<p><code>-i</code> 提示是不是要真的删除文件</p>\n<p>如果要删除很多文件不受提示干扰，可用<code>-f</code> 强制删除 <code>-rf</code>递归强制删除</p>\n<pre><code class=\"shell\">» rm -rf demo.txt\n</code></pre>\n<h2 id=\"处理目录\"><a href=\"#处理目录\" class=\"headerlink\" title=\"处理目录\"></a><span id=\"handle-dir\">处理目录</span></h2><p><strong>创建目录</strong></p>\n<p><code>mkdir [-pv] [-m mode] directory_name ...</code></p>\n<pre><code class=\"shell\">» mkdir new_dir\n</code></pre>\n<p>如果想批量创建目录和子目录，需要加上<code>-p</code>, 可以根据需要创建缺失目录.</p>\n<pre><code class=\"shell\">» mkdir -p new_dir/sub_dir_child_dir\n</code></pre>\n<p><strong>删除目录</strong></p>\n<p><code>rmdir [-p] directory ...</code></p>\n<p>默认情况下<code>rmdir</code>只删除非空目录, 只能先删除文件，才能删除目录</p>\n<p>所以想要一口气删除所有文件，还是需要用到<code>rm -rf [target dir name]</code></p>\n<h2 id=\"查看文件\"><a href=\"#查看文件\" class=\"headerlink\" title=\"查看文件\"></a><span id=\"cat-file\">查看文件</span></h2><p><code>file [-bcdDhiIkLnNprsvz] [--extension] [--mime-encoding] [--mime-type] [-f namefile] [-m magicfiles] [-P name=value]</code></p>\n<p>file命令是一个能够探测文件内部的工具</p>\n<p><strong>查看文件类型</strong></p>\n<pre><code class=\"shell\">» file demo.text\n</code></pre>\n<p>会返回文件的类型</p>\n<p><strong>查看整个文件</strong></p>\n<ul>\n<li>cat命令</li>\n</ul>\n<pre><code class=\"shell\">cat demo.txt\n</code></pre>\n<p><code>-n</code> 可以给所有行加上行号<br><code>-b</code> 可以只给文本行添加行号<br><code>-T</code> 移除制表符</p>\n<p><strong>查看部分文件</strong></p>\n<ul>\n<li>tail 命令<br>显示文件最后几行的内容</li>\n</ul>\n<p><code>tail [-F | -f | -r] [-q] [-b number | -c number | -n number] [file ...]</code></p>\n<p><code>tail -n number [file]</code> 显示指定行数的内容</p>\n<ul>\n<li>head 命令</li>\n</ul>\n<p><code>head [-n count | -c bytes] [file ...]</code><br>查看文件起始内容</p>\n<pre><code class=\"shell\">» head -n [number] [file]\n</code></pre>\n<h2 id=\"搜索数据\"><a href=\"#搜索数据\" class=\"headerlink\" title=\"搜索数据\"></a><span id=\"search-data\">搜索数据</span></h2><p><code>grep [options] pattern [file]</code></p>\n<p>grep命令会在输入或指定的文件中查找包含匹配指定模式的字符的行, 它的输出就是包含了匹配模式的行.</p>\n<p>eg: 在demo.js文件中找到含有<code>key</code>的行</p>\n<pre><code class=\"shell\">» grep key demo.js\n</code></pre>\n<ul>\n<li><p>如果进行方向搜索(即不匹配该行), 加<code>-v</code></p>\n<pre><code class=\"shell\">» grep -v key demo.js\n</code></pre>\n</li>\n<li><p>如果要显示匹配模式的行所在行号, 加<code>-n</code></p>\n<pre><code class=\"shell\">» grep -n key demo.js\n</code></pre>\n</li>\n<li><p>如果想知道有多少行匹配, 加<code>-c</code></p>\n<pre><code class=\"shell\">» grep -c key demo.js\n</code></pre>\n</li>\n<li><p>如果要制定多个匹配模式, 加<code>-e</code>指定每一个模式</p>\n<pre><code class=\"shell\">» grep -e key -e word demo.js\n</code></pre>\n</li>\n<li><p>支持正则表达式</p>\n<pre><code class=\"shell\">» grep [k-z] demo.js\n</code></pre>\n</li>\n</ul>\n"},{"title":"meta标签梳理","date":"2016-12-04T05:48:59.000Z","_content":"实际开发过程中meta标签大家都不陌生,大多都是去粘贴复制，对其原理和一些细节不太清楚,网上查阅一些常用的meta属性,以及什么意思,以备开发(偷懒)用.\n\n```html\n  content参数\n  width viewport 宽度(数值/device-width)\n  height viewport 高度(数值/device-height)\n  initial-scale 初始缩放比例\n  maximum-scale 最大缩放比例\n  minimum-scale 最小缩放比例\n  user-scalable 是否允许用户缩放(yes / no)\n```\n<!-- more -->\n```html\n  <!DOCTYPE html> <!-- 使用 HTML5 doctype，不区分大小写 -->\n  <html lang=\"zh-cmn-Hans\"> <!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa -->\n  <head>\n    <!-- 声明文档使用的字符编码 -->\n    <meta charset=\"utf-8\">\n    <!-- 优先使用IE最新版本和chrome -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <!-- 页面描述 -->\n    <meta name=\"description\" content=\"不超过150个字符\">\n    <!-- 页面关键词 -->\n    <meta name=\"keywords\" content=\"\">\n    <!-- 网页作者 -->\n    <meta name=\"author\" content=\"name,email@gmail.com\">\n    <!-- 搜索引擎抓取 -->\n    <meta name=\"robots\" content=\"index,follow\">\n    <!-- 为移动设备添加 viewport -->\n    <meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no\">\n    <!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边http://bigc.at/ios-webapp-viewport-meta.orz -->\n\n    <!-- iOS 设备 begin -->\n\n    <meta name=\"apple-mobile-web-app-title\" content=\"标题\">\n    <!-- 添加到主屏后的标题（iOS 6 新增） -->\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/>\n    <!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 -->\n\n    <meta name=\"format-detection\" content=\"telphone=no, email=no\"/>\n    <!-- 忽略页面中的数字识别为电话，忽略email识别 -->\n    <!-- 启用360浏览器的极速模式(webkit) -->\n    <meta name=\"renderer\" content=\"webkit\">\n    <!-- 避免IE使用兼容模式 -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->\n    <meta name=\"HandheldFriendly\" content=\"true\">\n    <!-- 微软的老式浏览器 -->\n    <meta name=\"MobileOptimized\" content=\"320\">\n    <!-- uc强制竖屏 -->\n    <meta name=\"screen-orientation\" content=\"portrait\">\n    <!-- QQ强制竖屏 -->\n    <meta name=\"x5-orientation\" content=\"portrait\">\n    <!-- UC强制全屏 -->\n    <meta name=\"full-screen\" content=\"yes\">\n    <!-- QQ强制全屏 -->\n    <meta name=\"x5-fullscreen\" content=\"true\">\n    <!-- UC应用模式 -->\n    <meta name=\"browsermode\" content=\"application\">\n    <!-- QQ应用模式 -->\n    <meta name=\"x5-page-mode\" content=\"app\">\n    <!-- windows phone 点击无高光 -->\n    <meta name=\"msapplication-tap-highlight\" content=\"no\">\n\n    <!-- iOS 图标 begin -->\n    <link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/>\n    <!-- iPhone 和 iTouch，默认 57x57 像素，必须有 -->\n    <link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/>\n    <!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 -->\n    <link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/>\n    <!-- Retina iPad，144x144 像素，可以没有，但推荐有 -->\n    <!-- iOS 图标 end -->\n\n    <!-- iOS 启动画面 begin -->\n   <link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/>\n   <!-- iPad 竖屏 768 x 1004（标准分辨率） -->\n   <link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/>\n   <!-- iPad 竖屏 1536x2008（Retina） -->\n   <link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/>\n   <!-- iPad 横屏 1024x748（标准分辨率） -->\n   <link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/>\n   <!-- iPad 横屏 2048x1496（Retina） -->\n\n    <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/>\n    <!-- 添加 RSS 订阅 -->\n    <link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/>\n    <!-- 添加 favicon icon -->\n```\n","source":"_posts/meta标签梳理.md","raw":"---\ntitle: meta标签梳理\ndate: 2016-12-04 13:48:59\ntags:\n    -HTML\ncategories: HTML\n---\n实际开发过程中meta标签大家都不陌生,大多都是去粘贴复制，对其原理和一些细节不太清楚,网上查阅一些常用的meta属性,以及什么意思,以备开发(偷懒)用.\n\n```html\n  content参数\n  width viewport 宽度(数值/device-width)\n  height viewport 高度(数值/device-height)\n  initial-scale 初始缩放比例\n  maximum-scale 最大缩放比例\n  minimum-scale 最小缩放比例\n  user-scalable 是否允许用户缩放(yes / no)\n```\n<!-- more -->\n```html\n  <!DOCTYPE html> <!-- 使用 HTML5 doctype，不区分大小写 -->\n  <html lang=\"zh-cmn-Hans\"> <!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa -->\n  <head>\n    <!-- 声明文档使用的字符编码 -->\n    <meta charset=\"utf-8\">\n    <!-- 优先使用IE最新版本和chrome -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <!-- 页面描述 -->\n    <meta name=\"description\" content=\"不超过150个字符\">\n    <!-- 页面关键词 -->\n    <meta name=\"keywords\" content=\"\">\n    <!-- 网页作者 -->\n    <meta name=\"author\" content=\"name,email@gmail.com\">\n    <!-- 搜索引擎抓取 -->\n    <meta name=\"robots\" content=\"index,follow\">\n    <!-- 为移动设备添加 viewport -->\n    <meta name=\"viewport\" content=\"initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no\">\n    <!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边http://bigc.at/ios-webapp-viewport-meta.orz -->\n\n    <!-- iOS 设备 begin -->\n\n    <meta name=\"apple-mobile-web-app-title\" content=\"标题\">\n    <!-- 添加到主屏后的标题（iOS 6 新增） -->\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/>\n    <!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 -->\n\n    <meta name=\"format-detection\" content=\"telphone=no, email=no\"/>\n    <!-- 忽略页面中的数字识别为电话，忽略email识别 -->\n    <!-- 启用360浏览器的极速模式(webkit) -->\n    <meta name=\"renderer\" content=\"webkit\">\n    <!-- 避免IE使用兼容模式 -->\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->\n    <meta name=\"HandheldFriendly\" content=\"true\">\n    <!-- 微软的老式浏览器 -->\n    <meta name=\"MobileOptimized\" content=\"320\">\n    <!-- uc强制竖屏 -->\n    <meta name=\"screen-orientation\" content=\"portrait\">\n    <!-- QQ强制竖屏 -->\n    <meta name=\"x5-orientation\" content=\"portrait\">\n    <!-- UC强制全屏 -->\n    <meta name=\"full-screen\" content=\"yes\">\n    <!-- QQ强制全屏 -->\n    <meta name=\"x5-fullscreen\" content=\"true\">\n    <!-- UC应用模式 -->\n    <meta name=\"browsermode\" content=\"application\">\n    <!-- QQ应用模式 -->\n    <meta name=\"x5-page-mode\" content=\"app\">\n    <!-- windows phone 点击无高光 -->\n    <meta name=\"msapplication-tap-highlight\" content=\"no\">\n\n    <!-- iOS 图标 begin -->\n    <link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/>\n    <!-- iPhone 和 iTouch，默认 57x57 像素，必须有 -->\n    <link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/>\n    <!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 -->\n    <link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/>\n    <!-- Retina iPad，144x144 像素，可以没有，但推荐有 -->\n    <!-- iOS 图标 end -->\n\n    <!-- iOS 启动画面 begin -->\n   <link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/>\n   <!-- iPad 竖屏 768 x 1004（标准分辨率） -->\n   <link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/>\n   <!-- iPad 竖屏 1536x2008（Retina） -->\n   <link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/>\n   <!-- iPad 横屏 1024x748（标准分辨率） -->\n   <link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/>\n   <!-- iPad 横屏 2048x1496（Retina） -->\n\n    <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/>\n    <!-- 添加 RSS 订阅 -->\n    <link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/>\n    <!-- 添加 favicon icon -->\n```\n","slug":"meta标签梳理","published":1,"updated":"2019-09-25T15:10:25.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ow002vla2e3td5nxo7","content":"<p>实际开发过程中meta标签大家都不陌生,大多都是去粘贴复制，对其原理和一些细节不太清楚,网上查阅一些常用的meta属性,以及什么意思,以备开发(偷懒)用.</p>\n<pre><code class=\"html\">  content参数\n  width viewport 宽度(数值/device-width)\n  height viewport 高度(数值/device-height)\n  initial-scale 初始缩放比例\n  maximum-scale 最大缩放比例\n  minimum-scale 最小缩放比例\n  user-scalable 是否允许用户缩放(yes / no)\n</code></pre>\n<a id=\"more\"></a>\n<pre><code class=\"html\">  &lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;\n  &lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;\n  &lt;head&gt;\n    &lt;!-- 声明文档使用的字符编码 --&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;!-- 优先使用IE最新版本和chrome --&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n    &lt;!-- 页面描述 --&gt;\n    &lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;&gt;\n    &lt;!-- 页面关键词 --&gt;\n    &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;\n    &lt;!-- 网页作者 --&gt;\n    &lt;meta name=&quot;author&quot; content=&quot;name,email@gmail.com&quot;&gt;\n    &lt;!-- 搜索引擎抓取 --&gt;\n    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;\n    &lt;!-- 为移动设备添加 viewport --&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no&quot;&gt;\n    &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边http://bigc.at/ios-webapp-viewport-meta.orz --&gt;\n\n    &lt;!-- iOS 设备 begin --&gt;\n\n    &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;\n    &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;\n    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;\n    &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;\n\n    &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;\n    &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;\n    &lt;!-- 启用360浏览器的极速模式(webkit) --&gt;\n    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;\n    &lt;!-- 避免IE使用兼容模式 --&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;\n    &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;\n    &lt;!-- 微软的老式浏览器 --&gt;\n    &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;\n    &lt;!-- uc强制竖屏 --&gt;\n    &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;\n    &lt;!-- QQ强制竖屏 --&gt;\n    &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;\n    &lt;!-- UC强制全屏 --&gt;\n    &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;\n    &lt;!-- QQ强制全屏 --&gt;\n    &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;\n    &lt;!-- UC应用模式 --&gt;\n    &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;\n    &lt;!-- QQ应用模式 --&gt;\n    &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;\n    &lt;!-- windows phone 点击无高光 --&gt;\n    &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;\n\n    &lt;!-- iOS 图标 begin --&gt;\n    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;\n    &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;\n    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;\n    &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;\n    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;\n    &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;\n    &lt;!-- iOS 图标 end --&gt;\n\n    &lt;!-- iOS 启动画面 begin --&gt;\n   &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;\n   &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;\n   &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;\n   &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;\n   &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;\n   &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;\n   &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;\n   &lt;!-- iPad 横屏 2048x1496（Retina） --&gt;\n\n    &lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt;\n    &lt;!-- 添加 RSS 订阅 --&gt;\n    &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt;\n    &lt;!-- 添加 favicon icon --&gt;\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>实际开发过程中meta标签大家都不陌生,大多都是去粘贴复制，对其原理和一些细节不太清楚,网上查阅一些常用的meta属性,以及什么意思,以备开发(偷懒)用.</p>\n<pre><code class=\"html\">  content参数\n  width viewport 宽度(数值/device-width)\n  height viewport 高度(数值/device-height)\n  initial-scale 初始缩放比例\n  maximum-scale 最大缩放比例\n  minimum-scale 最小缩放比例\n  user-scalable 是否允许用户缩放(yes / no)\n</code></pre>","more":"<pre><code class=\"html\">  &lt;!DOCTYPE html&gt; &lt;!-- 使用 HTML5 doctype，不区分大小写 --&gt;\n  &lt;html lang=&quot;zh-cmn-Hans&quot;&gt; &lt;!-- 更加标准的 lang 属性写法 http://zhi.hu/XyIa --&gt;\n  &lt;head&gt;\n    &lt;!-- 声明文档使用的字符编码 --&gt;\n    &lt;meta charset=&quot;utf-8&quot;&gt;\n    &lt;!-- 优先使用IE最新版本和chrome --&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n    &lt;!-- 页面描述 --&gt;\n    &lt;meta name=&quot;description&quot; content=&quot;不超过150个字符&quot;&gt;\n    &lt;!-- 页面关键词 --&gt;\n    &lt;meta name=&quot;keywords&quot; content=&quot;&quot;&gt;\n    &lt;!-- 网页作者 --&gt;\n    &lt;meta name=&quot;author&quot; content=&quot;name,email@gmail.com&quot;&gt;\n    &lt;!-- 搜索引擎抓取 --&gt;\n    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;\n    &lt;!-- 为移动设备添加 viewport --&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no&quot;&gt;\n    &lt;!-- `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边http://bigc.at/ios-webapp-viewport-meta.orz --&gt;\n\n    &lt;!-- iOS 设备 begin --&gt;\n\n    &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;&gt;\n    &lt;!-- 添加到主屏后的标题（iOS 6 新增） --&gt;\n    &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;\n    &lt;!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 --&gt;\n\n    &lt;meta name=&quot;format-detection&quot; content=&quot;telphone=no, email=no&quot;/&gt;\n    &lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;\n    &lt;!-- 启用360浏览器的极速模式(webkit) --&gt;\n    &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;\n    &lt;!-- 避免IE使用兼容模式 --&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;\n    &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;\n    &lt;!-- 微软的老式浏览器 --&gt;\n    &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt;\n    &lt;!-- uc强制竖屏 --&gt;\n    &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;\n    &lt;!-- QQ强制竖屏 --&gt;\n    &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt;\n    &lt;!-- UC强制全屏 --&gt;\n    &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;\n    &lt;!-- QQ强制全屏 --&gt;\n    &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;\n    &lt;!-- UC应用模式 --&gt;\n    &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt;\n    &lt;!-- QQ应用模式 --&gt;\n    &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt;\n    &lt;!-- windows phone 点击无高光 --&gt;\n    &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt;\n\n    &lt;!-- iOS 图标 begin --&gt;\n    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;/apple-touch-icon-57x57-precomposed.png&quot;/&gt;\n    &lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;\n    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;/apple-touch-icon-114x114-precomposed.png&quot;/&gt;\n    &lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;\n    &lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;144x144&quot; href=&quot;/apple-touch-icon-144x144-precomposed.png&quot;/&gt;\n    &lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;\n    &lt;!-- iOS 图标 end --&gt;\n\n    &lt;!-- iOS 启动画面 begin --&gt;\n   &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;768x1004&quot; href=&quot;/splash-screen-768x1004.png&quot;/&gt;\n   &lt;!-- iPad 竖屏 768 x 1004（标准分辨率） --&gt;\n   &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1536x2008&quot; href=&quot;/splash-screen-1536x2008.png&quot;/&gt;\n   &lt;!-- iPad 竖屏 1536x2008（Retina） --&gt;\n   &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;1024x748&quot; href=&quot;/Default-Portrait-1024x748.png&quot;/&gt;\n   &lt;!-- iPad 横屏 1024x748（标准分辨率） --&gt;\n   &lt;link rel=&quot;apple-touch-startup-image&quot; sizes=&quot;2048x1496&quot; href=&quot;/splash-screen-2048x1496.png&quot;/&gt;\n   &lt;!-- iPad 横屏 2048x1496（Retina） --&gt;\n\n    &lt;link rel=&quot;alternate&quot; type=&quot;application/rss+xml&quot; title=&quot;RSS&quot; href=&quot;/rss.xml&quot;/&gt;\n    &lt;!-- 添加 RSS 订阅 --&gt;\n    &lt;link rel=&quot;shortcut icon&quot; type=&quot;image/ico&quot; href=&quot;/favicon.ico&quot;/&gt;\n    &lt;!-- 添加 favicon icon --&gt;\n</code></pre>"},{"title":"React.createClass和extends React.Component的区别","date":"2016-12-18T13:54:19.000Z","_content":"> createClass本质上是一个工厂函数，extens的方式更加接近最新的ES6规范的class写法。两种方式在预防上的差别主要体现在方法的定义和静态属性的声明上.createClass方式的方法定义使用逗号隔开，因为createClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必不要使用逗号隔开，这是ES6class 的语法规范。\n\n\n<!-- more -->\n## React.createClass和extends Component的区别主要在于：\n* 1.语法区别\n* 2.模块的导出\n* 3.状态的区别\n* 4.实例函数／回调函数的绑定(this)\n* 5.propType 和 getDefaultProps\n\n## 一、语法区别\nReact.createClass\n```javascript\nimport React from 'react';\nconst ListDemo = React.create({\n\trender(){\n\t\treturn (\n\t\t\t<div></div>\n\t\t)\n\t}\n})；\nmodule.exports = ListDemo;\n```\nReact.Component\n```javascript\nimport React from 'react';\nclass ListDemo extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props)\n\t}\n\trender(){\n\t\treturn (\n\t\t\t<div></div>\n\t\t)\n\t}\n}\nexport default ListDemo;\n```\n后一种方法使用ES6的语法，用constructor构造器来构造默认的属性和状态。类中方法的定义不再需要尾随 function，而且方法之间不需要以 , 分隔.\n\n## 二、模块的导出\n> 在 ES6 语法中，模块的导出使用 export default 代替 module.exports，如下所示：\n\n\n```javascript\n// ES5 语法\nvar ListDemo = React.createClass({\n    ...\n});\n\nmodule.exports = ListDemo;\n\n// ES6 语法\nclass ListDemo extends React.Component {\n    ...\n}\nexport default ListDemo\n```\n## 三、状态的区别\nReact.createClass\n使用 ES5 语法时，React Native 组件的状态变量是在 getInitialState 函数中初始化的，如下所示：\n```javascript\nimport React from 'react';\nconst ListDemo = React.create({\n\t// return an object\n\tgetInitialState(){\n\t        return {\n\t            isEditing: false\n\t        }\n   \t },\n\trender: function(){\n\t\treturn (\n\t\t\t<div></div>\n\t\t)\n\t}\n})；\nmodule.exports = ListDemo;\n```\nReact.Component\n到了 ES6 语法中，React Native 团队修改了状态变量的初始化方式，取消了单独的 getInitialState 函数，将初始化放在构造函数中，并提供 this.state 实例变量用来存储状态变量，如下所示：\n```javascript\nimport React from 'react';\nclass ListDemo extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n           \t\t scrollTop: new Animated.Value(0),\n        \t};\n\t}\n\trender(){\n\t\treturn (\n\t\t\t<div></div>\n\t\t)\n\t}\n}\nexport default ListDemo;\n```\n## 四、实例函数／回调函数的绑定(this)\nReact.createClass：会正确绑定this\nES5 语法中，React Native 的 createClass 函数提供的一个便利的功能是自动绑定类作用域中的函数到组件实例，例如 createClass 里面定义的函数可以通过 this 直接指向本组件的某个成员函数\n```javascript\nimport React from 'react';\nlet ListDemo = React.createClass({\n    _handleClick : function() { // 这个方法将作为回调函数使用\n        console.log('onClick');\n    },\n    render : function() {\n        return (\n            <View style={styles.container}>\n                <Text style={styles.normal}\n                    onPress={this._handleClick}>\n                    确定\n                </Text>\n            </View>\n        );\n    },\n});\nmodule.exports = ListDemo;\n```\nReact.Component\n到了 ES6 的 class 定义中，开发者必须手动进行回调函数的绑定操作，React Native 团队推荐在组件的构造函数中进行，如下所示：\n```javascript\nimport React from 'react';\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    _handleClick() {\n        console.log('onClick');\n    }\n    render() {\n        return (\n            <View style={styles.container}>\n                <Text style={styles.normal}\n                    onPress={this._handleClick.bind(this)}>\n                    确定\n                </Text>\n            </View>\n        );\n    }\n}\nexport default ListDemo;\n```\n> 我们还可以在 constructor 中来改变 this.handleClick 执行的上下文，这应该是相对上面一种来说更好的办法，万一我们需要改变语法结构，这种方式完全不需要去改动 JSX 的部分：\n\n```javascript\nimport React from 'react';\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n        // 手动执行绑定操作\n        this._handleClick = this._handleClick.bind(this);\n    }\n    _handleClick() {\n        console.log('onClick');\n    }\n    render() {\n        return (\n            <View style={styles.container}>\n                <Text style={styles.normal}\n                    onPress={this._handleClick}>\n                    确定\n                </Text>\n            </View>\n        );\n    }\n}\nexport default ListDemo;\n```\n## 五、propType 和 getDefaultProps\nReact.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.\n```javascript\nimport React from 'react';\n\nconst ListDemo = React.createClass({  \n  propTypes: {\n    name: React.PropTypes.string\n  },\n  getDefaultProps() {\n    return {\n\n    };\n  },\n  render() {\n    return (\n      <div></div>\n    );\n  }\n});\n\nexport default ListDemo;\n```\nReact.Component：通过设置两个属性propTypes和defaultProps\n```javascript\nimport React form 'react';\nclass ListDemo extends React.Component{\n    static propTypes = { // as static property\n        name: React.PropTypes.string\n    };\n    static defaultProps = { // as static property\n        name: ''\n    };\n    constructor(props){\n        super(props)\n    }\n    render(){\n        return <div></div>\n    }\n}\nexport default ListDemo;\n```\n\n** 最近使用RN比较多,慢慢填坑路... 慢慢写吧!**\n","source":"_posts/react-native-之-React-createClass和extends-React-Component的区别.md","raw":"---\ntitle: React.createClass和extends React.Component的区别\ndate: 2016-12-18 21:54:19\ntags: [React,React-native]\ncategories: React\n---\n> createClass本质上是一个工厂函数，extens的方式更加接近最新的ES6规范的class写法。两种方式在预防上的差别主要体现在方法的定义和静态属性的声明上.createClass方式的方法定义使用逗号隔开，因为createClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必不要使用逗号隔开，这是ES6class 的语法规范。\n\n\n<!-- more -->\n## React.createClass和extends Component的区别主要在于：\n* 1.语法区别\n* 2.模块的导出\n* 3.状态的区别\n* 4.实例函数／回调函数的绑定(this)\n* 5.propType 和 getDefaultProps\n\n## 一、语法区别\nReact.createClass\n```javascript\nimport React from 'react';\nconst ListDemo = React.create({\n\trender(){\n\t\treturn (\n\t\t\t<div></div>\n\t\t)\n\t}\n})；\nmodule.exports = ListDemo;\n```\nReact.Component\n```javascript\nimport React from 'react';\nclass ListDemo extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props)\n\t}\n\trender(){\n\t\treturn (\n\t\t\t<div></div>\n\t\t)\n\t}\n}\nexport default ListDemo;\n```\n后一种方法使用ES6的语法，用constructor构造器来构造默认的属性和状态。类中方法的定义不再需要尾随 function，而且方法之间不需要以 , 分隔.\n\n## 二、模块的导出\n> 在 ES6 语法中，模块的导出使用 export default 代替 module.exports，如下所示：\n\n\n```javascript\n// ES5 语法\nvar ListDemo = React.createClass({\n    ...\n});\n\nmodule.exports = ListDemo;\n\n// ES6 语法\nclass ListDemo extends React.Component {\n    ...\n}\nexport default ListDemo\n```\n## 三、状态的区别\nReact.createClass\n使用 ES5 语法时，React Native 组件的状态变量是在 getInitialState 函数中初始化的，如下所示：\n```javascript\nimport React from 'react';\nconst ListDemo = React.create({\n\t// return an object\n\tgetInitialState(){\n\t        return {\n\t            isEditing: false\n\t        }\n   \t },\n\trender: function(){\n\t\treturn (\n\t\t\t<div></div>\n\t\t)\n\t}\n})；\nmodule.exports = ListDemo;\n```\nReact.Component\n到了 ES6 语法中，React Native 团队修改了状态变量的初始化方式，取消了单独的 getInitialState 函数，将初始化放在构造函数中，并提供 this.state 实例变量用来存储状态变量，如下所示：\n```javascript\nimport React from 'react';\nclass ListDemo extends React.Component {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n           \t\t scrollTop: new Animated.Value(0),\n        \t};\n\t}\n\trender(){\n\t\treturn (\n\t\t\t<div></div>\n\t\t)\n\t}\n}\nexport default ListDemo;\n```\n## 四、实例函数／回调函数的绑定(this)\nReact.createClass：会正确绑定this\nES5 语法中，React Native 的 createClass 函数提供的一个便利的功能是自动绑定类作用域中的函数到组件实例，例如 createClass 里面定义的函数可以通过 this 直接指向本组件的某个成员函数\n```javascript\nimport React from 'react';\nlet ListDemo = React.createClass({\n    _handleClick : function() { // 这个方法将作为回调函数使用\n        console.log('onClick');\n    },\n    render : function() {\n        return (\n            <View style={styles.container}>\n                <Text style={styles.normal}\n                    onPress={this._handleClick}>\n                    确定\n                </Text>\n            </View>\n        );\n    },\n});\nmodule.exports = ListDemo;\n```\nReact.Component\n到了 ES6 的 class 定义中，开发者必须手动进行回调函数的绑定操作，React Native 团队推荐在组件的构造函数中进行，如下所示：\n```javascript\nimport React from 'react';\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    _handleClick() {\n        console.log('onClick');\n    }\n    render() {\n        return (\n            <View style={styles.container}>\n                <Text style={styles.normal}\n                    onPress={this._handleClick.bind(this)}>\n                    确定\n                </Text>\n            </View>\n        );\n    }\n}\nexport default ListDemo;\n```\n> 我们还可以在 constructor 中来改变 this.handleClick 执行的上下文，这应该是相对上面一种来说更好的办法，万一我们需要改变语法结构，这种方式完全不需要去改动 JSX 的部分：\n\n```javascript\nimport React from 'react';\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n        // 手动执行绑定操作\n        this._handleClick = this._handleClick.bind(this);\n    }\n    _handleClick() {\n        console.log('onClick');\n    }\n    render() {\n        return (\n            <View style={styles.container}>\n                <Text style={styles.normal}\n                    onPress={this._handleClick}>\n                    确定\n                </Text>\n            </View>\n        );\n    }\n}\nexport default ListDemo;\n```\n## 五、propType 和 getDefaultProps\nReact.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.\n```javascript\nimport React from 'react';\n\nconst ListDemo = React.createClass({  \n  propTypes: {\n    name: React.PropTypes.string\n  },\n  getDefaultProps() {\n    return {\n\n    };\n  },\n  render() {\n    return (\n      <div></div>\n    );\n  }\n});\n\nexport default ListDemo;\n```\nReact.Component：通过设置两个属性propTypes和defaultProps\n```javascript\nimport React form 'react';\nclass ListDemo extends React.Component{\n    static propTypes = { // as static property\n        name: React.PropTypes.string\n    };\n    static defaultProps = { // as static property\n        name: ''\n    };\n    constructor(props){\n        super(props)\n    }\n    render(){\n        return <div></div>\n    }\n}\nexport default ListDemo;\n```\n\n** 最近使用RN比较多,慢慢填坑路... 慢慢写吧!**\n","slug":"react-native-之-React-createClass和extends-React-Component的区别","published":1,"updated":"2019-09-25T15:10:25.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ox002zla2ezbhc2osu","content":"<blockquote>\n<p>createClass本质上是一个工厂函数，extens的方式更加接近最新的ES6规范的class写法。两种方式在预防上的差别主要体现在方法的定义和静态属性的声明上.createClass方式的方法定义使用逗号隔开，因为createClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必不要使用逗号隔开，这是ES6class 的语法规范。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"React-createClass和extends-Component的区别主要在于：\"><a href=\"#React-createClass和extends-Component的区别主要在于：\" class=\"headerlink\" title=\"React.createClass和extends Component的区别主要在于：\"></a>React.createClass和extends Component的区别主要在于：</h2><ul>\n<li>1.语法区别</li>\n<li>2.模块的导出</li>\n<li>3.状态的区别</li>\n<li>4.实例函数／回调函数的绑定(this)</li>\n<li>5.propType 和 getDefaultProps</li>\n</ul>\n<h2 id=\"一、语法区别\"><a href=\"#一、语法区别\" class=\"headerlink\" title=\"一、语法区别\"></a>一、语法区别</h2><p>React.createClass</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nconst ListDemo = React.create({\n    render(){\n        return (\n            &lt;div&gt;&lt;/div&gt;\n        )\n    }\n})；\nmodule.exports = ListDemo;\n</code></pre>\n<p>React.Component</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    render(){\n        return (\n            &lt;div&gt;&lt;/div&gt;\n        )\n    }\n}\nexport default ListDemo;\n</code></pre>\n<p>后一种方法使用ES6的语法，用constructor构造器来构造默认的属性和状态。类中方法的定义不再需要尾随 function，而且方法之间不需要以 , 分隔.</p>\n<h2 id=\"二、模块的导出\"><a href=\"#二、模块的导出\" class=\"headerlink\" title=\"二、模块的导出\"></a>二、模块的导出</h2><blockquote>\n<p>在 ES6 语法中，模块的导出使用 export default 代替 module.exports，如下所示：</p>\n</blockquote>\n<pre><code class=\"javascript\">// ES5 语法\nvar ListDemo = React.createClass({\n    ...\n});\n\nmodule.exports = ListDemo;\n\n// ES6 语法\nclass ListDemo extends React.Component {\n    ...\n}\nexport default ListDemo\n</code></pre>\n<h2 id=\"三、状态的区别\"><a href=\"#三、状态的区别\" class=\"headerlink\" title=\"三、状态的区别\"></a>三、状态的区别</h2><p>React.createClass<br>使用 ES5 语法时，React Native 组件的状态变量是在 getInitialState 函数中初始化的，如下所示：</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nconst ListDemo = React.create({\n    // return an object\n    getInitialState(){\n            return {\n                isEditing: false\n            }\n        },\n    render: function(){\n        return (\n            &lt;div&gt;&lt;/div&gt;\n        )\n    }\n})；\nmodule.exports = ListDemo;\n</code></pre>\n<p>React.Component<br>到了 ES6 语法中，React Native 团队修改了状态变量的初始化方式，取消了单独的 getInitialState 函数，将初始化放在构造函数中，并提供 this.state 实例变量用来存储状态变量，如下所示：</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n                    scrollTop: new Animated.Value(0),\n            };\n    }\n    render(){\n        return (\n            &lt;div&gt;&lt;/div&gt;\n        )\n    }\n}\nexport default ListDemo;\n</code></pre>\n<h2 id=\"四、实例函数／回调函数的绑定-this\"><a href=\"#四、实例函数／回调函数的绑定-this\" class=\"headerlink\" title=\"四、实例函数／回调函数的绑定(this)\"></a>四、实例函数／回调函数的绑定(this)</h2><p>React.createClass：会正确绑定this<br>ES5 语法中，React Native 的 createClass 函数提供的一个便利的功能是自动绑定类作用域中的函数到组件实例，例如 createClass 里面定义的函数可以通过 this 直接指向本组件的某个成员函数</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nlet ListDemo = React.createClass({\n    _handleClick : function() { // 这个方法将作为回调函数使用\n        console.log(&#39;onClick&#39;);\n    },\n    render : function() {\n        return (\n            &lt;View style={styles.container}&gt;\n                &lt;Text style={styles.normal}\n                    onPress={this._handleClick}&gt;\n                    确定\n                &lt;/Text&gt;\n            &lt;/View&gt;\n        );\n    },\n});\nmodule.exports = ListDemo;\n</code></pre>\n<p>React.Component<br>到了 ES6 的 class 定义中，开发者必须手动进行回调函数的绑定操作，React Native 团队推荐在组件的构造函数中进行，如下所示：</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    _handleClick() {\n        console.log(&#39;onClick&#39;);\n    }\n    render() {\n        return (\n            &lt;View style={styles.container}&gt;\n                &lt;Text style={styles.normal}\n                    onPress={this._handleClick.bind(this)}&gt;\n                    确定\n                &lt;/Text&gt;\n            &lt;/View&gt;\n        );\n    }\n}\nexport default ListDemo;\n</code></pre>\n<blockquote>\n<p>我们还可以在 constructor 中来改变 this.handleClick 执行的上下文，这应该是相对上面一种来说更好的办法，万一我们需要改变语法结构，这种方式完全不需要去改动 JSX 的部分：</p>\n</blockquote>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n        // 手动执行绑定操作\n        this._handleClick = this._handleClick.bind(this);\n    }\n    _handleClick() {\n        console.log(&#39;onClick&#39;);\n    }\n    render() {\n        return (\n            &lt;View style={styles.container}&gt;\n                &lt;Text style={styles.normal}\n                    onPress={this._handleClick}&gt;\n                    确定\n                &lt;/Text&gt;\n            &lt;/View&gt;\n        );\n    }\n}\nexport default ListDemo;\n</code></pre>\n<h2 id=\"五、propType-和-getDefaultProps\"><a href=\"#五、propType-和-getDefaultProps\" class=\"headerlink\" title=\"五、propType 和 getDefaultProps\"></a>五、propType 和 getDefaultProps</h2><p>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\n\nconst ListDemo = React.createClass({  \n  propTypes: {\n    name: React.PropTypes.string\n  },\n  getDefaultProps() {\n    return {\n\n    };\n  },\n  render() {\n    return (\n      &lt;div&gt;&lt;/div&gt;\n    );\n  }\n});\n\nexport default ListDemo;\n</code></pre>\n<p>React.Component：通过设置两个属性propTypes和defaultProps</p>\n<pre><code class=\"javascript\">import React form &#39;react&#39;;\nclass ListDemo extends React.Component{\n    static propTypes = { // as static property\n        name: React.PropTypes.string\n    };\n    static defaultProps = { // as static property\n        name: &#39;&#39;\n    };\n    constructor(props){\n        super(props)\n    }\n    render(){\n        return &lt;div&gt;&lt;/div&gt;\n    }\n}\nexport default ListDemo;\n</code></pre>\n<p><strong> 最近使用RN比较多,慢慢填坑路… 慢慢写吧!</strong></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>createClass本质上是一个工厂函数，extens的方式更加接近最新的ES6规范的class写法。两种方式在预防上的差别主要体现在方法的定义和静态属性的声明上.createClass方式的方法定义使用逗号隔开，因为createClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必不要使用逗号隔开，这是ES6class 的语法规范。</p>\n</blockquote>","more":"<h2 id=\"React-createClass和extends-Component的区别主要在于：\"><a href=\"#React-createClass和extends-Component的区别主要在于：\" class=\"headerlink\" title=\"React.createClass和extends Component的区别主要在于：\"></a>React.createClass和extends Component的区别主要在于：</h2><ul>\n<li>1.语法区别</li>\n<li>2.模块的导出</li>\n<li>3.状态的区别</li>\n<li>4.实例函数／回调函数的绑定(this)</li>\n<li>5.propType 和 getDefaultProps</li>\n</ul>\n<h2 id=\"一、语法区别\"><a href=\"#一、语法区别\" class=\"headerlink\" title=\"一、语法区别\"></a>一、语法区别</h2><p>React.createClass</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nconst ListDemo = React.create({\n    render(){\n        return (\n            &lt;div&gt;&lt;/div&gt;\n        )\n    }\n})；\nmodule.exports = ListDemo;\n</code></pre>\n<p>React.Component</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    render(){\n        return (\n            &lt;div&gt;&lt;/div&gt;\n        )\n    }\n}\nexport default ListDemo;\n</code></pre>\n<p>后一种方法使用ES6的语法，用constructor构造器来构造默认的属性和状态。类中方法的定义不再需要尾随 function，而且方法之间不需要以 , 分隔.</p>\n<h2 id=\"二、模块的导出\"><a href=\"#二、模块的导出\" class=\"headerlink\" title=\"二、模块的导出\"></a>二、模块的导出</h2><blockquote>\n<p>在 ES6 语法中，模块的导出使用 export default 代替 module.exports，如下所示：</p>\n</blockquote>\n<pre><code class=\"javascript\">// ES5 语法\nvar ListDemo = React.createClass({\n    ...\n});\n\nmodule.exports = ListDemo;\n\n// ES6 语法\nclass ListDemo extends React.Component {\n    ...\n}\nexport default ListDemo\n</code></pre>\n<h2 id=\"三、状态的区别\"><a href=\"#三、状态的区别\" class=\"headerlink\" title=\"三、状态的区别\"></a>三、状态的区别</h2><p>React.createClass<br>使用 ES5 语法时，React Native 组件的状态变量是在 getInitialState 函数中初始化的，如下所示：</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nconst ListDemo = React.create({\n    // return an object\n    getInitialState(){\n            return {\n                isEditing: false\n            }\n        },\n    render: function(){\n        return (\n            &lt;div&gt;&lt;/div&gt;\n        )\n    }\n})；\nmodule.exports = ListDemo;\n</code></pre>\n<p>React.Component<br>到了 ES6 语法中，React Native 团队修改了状态变量的初始化方式，取消了单独的 getInitialState 函数，将初始化放在构造函数中，并提供 this.state 实例变量用来存储状态变量，如下所示：</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n                    scrollTop: new Animated.Value(0),\n            };\n    }\n    render(){\n        return (\n            &lt;div&gt;&lt;/div&gt;\n        )\n    }\n}\nexport default ListDemo;\n</code></pre>\n<h2 id=\"四、实例函数／回调函数的绑定-this\"><a href=\"#四、实例函数／回调函数的绑定-this\" class=\"headerlink\" title=\"四、实例函数／回调函数的绑定(this)\"></a>四、实例函数／回调函数的绑定(this)</h2><p>React.createClass：会正确绑定this<br>ES5 语法中，React Native 的 createClass 函数提供的一个便利的功能是自动绑定类作用域中的函数到组件实例，例如 createClass 里面定义的函数可以通过 this 直接指向本组件的某个成员函数</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nlet ListDemo = React.createClass({\n    _handleClick : function() { // 这个方法将作为回调函数使用\n        console.log(&#39;onClick&#39;);\n    },\n    render : function() {\n        return (\n            &lt;View style={styles.container}&gt;\n                &lt;Text style={styles.normal}\n                    onPress={this._handleClick}&gt;\n                    确定\n                &lt;/Text&gt;\n            &lt;/View&gt;\n        );\n    },\n});\nmodule.exports = ListDemo;\n</code></pre>\n<p>React.Component<br>到了 ES6 的 class 定义中，开发者必须手动进行回调函数的绑定操作，React Native 团队推荐在组件的构造函数中进行，如下所示：</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n    _handleClick() {\n        console.log(&#39;onClick&#39;);\n    }\n    render() {\n        return (\n            &lt;View style={styles.container}&gt;\n                &lt;Text style={styles.normal}\n                    onPress={this._handleClick.bind(this)}&gt;\n                    确定\n                &lt;/Text&gt;\n            &lt;/View&gt;\n        );\n    }\n}\nexport default ListDemo;\n</code></pre>\n<blockquote>\n<p>我们还可以在 constructor 中来改变 this.handleClick 执行的上下文，这应该是相对上面一种来说更好的办法，万一我们需要改变语法结构，这种方式完全不需要去改动 JSX 的部分：</p>\n</blockquote>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\nclass ListDemo extends React.Component {\n    constructor(props) {\n        super(props);\n        // 手动执行绑定操作\n        this._handleClick = this._handleClick.bind(this);\n    }\n    _handleClick() {\n        console.log(&#39;onClick&#39;);\n    }\n    render() {\n        return (\n            &lt;View style={styles.container}&gt;\n                &lt;Text style={styles.normal}\n                    onPress={this._handleClick}&gt;\n                    确定\n                &lt;/Text&gt;\n            &lt;/View&gt;\n        );\n    }\n}\nexport default ListDemo;\n</code></pre>\n<h2 id=\"五、propType-和-getDefaultProps\"><a href=\"#五、propType-和-getDefaultProps\" class=\"headerlink\" title=\"五、propType 和 getDefaultProps\"></a>五、propType 和 getDefaultProps</h2><p>React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.</p>\n<pre><code class=\"javascript\">import React from &#39;react&#39;;\n\nconst ListDemo = React.createClass({  \n  propTypes: {\n    name: React.PropTypes.string\n  },\n  getDefaultProps() {\n    return {\n\n    };\n  },\n  render() {\n    return (\n      &lt;div&gt;&lt;/div&gt;\n    );\n  }\n});\n\nexport default ListDemo;\n</code></pre>\n<p>React.Component：通过设置两个属性propTypes和defaultProps</p>\n<pre><code class=\"javascript\">import React form &#39;react&#39;;\nclass ListDemo extends React.Component{\n    static propTypes = { // as static property\n        name: React.PropTypes.string\n    };\n    static defaultProps = { // as static property\n        name: &#39;&#39;\n    };\n    constructor(props){\n        super(props)\n    }\n    render(){\n        return &lt;div&gt;&lt;/div&gt;\n    }\n}\nexport default ListDemo;\n</code></pre>\n<p><strong> 最近使用RN比较多,慢慢填坑路… 慢慢写吧!</strong></p>"},{"title":"shell脚本编程-构建基本脚本令","date":"2019-10-20T05:05:29.000Z","_content":"\n## 创建shell脚本文件\n\n创建shell脚本文件时,需要在第一行指定要使用的shell:\n\n```shell\n#! /bin/bash\n```\n通常井(#)号用作注释行, 第一行是个例外.\n\n**1.改变文件权限**\n\nchmod命令用来改变文件和目录的安全性，格式如下：\n\n\n```shell\nchmod options mode file\n```\nmode 参数可以使用八进制模式或者符号进行安全设置\n\n**2.八进制模式**\n```shell\nchmod 760 somefile\n```\n得到：\n```shell\nls -l somefile\n# -rwxrw----\n```\n\n**3.符号模式**\n`[ugoa][[+-=][rwxXstigo]]`\n\n```shell\nu 代表用户\ng 代表组\no 代表其他\na 代表上述所有\n------\nr read\nw write\nx 执行权限\nX 如果对象是目录或者它已有执行权限，赋予执行权限\ns 运行时重新设置UID or GID\nt 包括文件或者目录\nu 设置属主权限\ng 设置属组权限\no 设置其他用户权限\n```\n\n**4.执行shell文件**\n第一次执行文件可能会告知没有权限\n```shell\npermission denied: ./somefile.sh\n```\n\n这时候可以用到👆的方法进行赋予权限：\n```shell\nchmod u+x somefile.sh\n```\n\n**5.echo输出消息**\n在echo命令后加上字符串，就可以显示该文本\n```shell\necho \"This is a test\"\n# This is a test\n``` \n\n## 使用变量\nset命令可以显示完整的当前环境变量\n\n**1.环境变量**\n```shell\nset\n```\n如果我们想使用环境变量，只需在名称之前加上$美元符号即可\n```shell\necho $HOME\n```\n**2.用户变量**\n用户可以定义自己的变量,比如我们在方才的`somefile.sh`文件中写入：\n```shell\n#! /bin/bash\n\nval1=5\nval2=10\necho ${val1} ${val2}\n\n# 5 10\n```\n\n## 重定向输入输出\n**1.输出重定向**\n基本的重定向是将命令输出发送到一个文件中.\n```shell\ncommand > outputfile\n```\ne.g.\n\n```shell\ndate > test\n```\n创建了一个test文件, 并将日期写入到该文件中.\n如果文件已经存在，会覆盖原有内容，如果不想覆盖原有内容，而是追加内容，可用双大于号(>>)\n\n```shell\ndate >> test\n```\n**2.输入重定向**\n输入重定向和输出刚好是相反的，将内容重定向到命令, 用小于号`<`\n\n```shell\ncommand < inputfile\n```\n\ne.g.\n\n```shell\nwc < inputfile\n```\n\n可以对文件中的数据进行计数，默认3个值， 行数,词数,字节数\n\n还有一种输入重定向: 内联输入重定向. 内联重定向是远小于号(`<<`),该方法无需使用文件进行查询，只需要在命令行中指定用于输入重定向的数据, 除了该符号，还需要指定一个文本标记来划分输入数据的开始结尾.\n\n## 数学运算\n\n**1.方括号**\n`$[ operation]`\n\n```shell\nval1=5\nval2=10\nval3=$[$val1 - $val2]\necho $val3\n\n# -5\n```\n\n**2.浮点运算**\n```shell\nvariable=$(echo \"options; expression\" | bc)\n```\n\n第一部分options允许你设置变量, 多个变量用分号隔开; expression参数定义了通过`bc`执行数学表达式\n\n```shell\n#! /bin/bash\nval1=100\nval2=45\nval3=$(echo \"scale=4; $val1 / $val2\"| bc)\n\necho The answer for this is $val3\n\n# The answer for this is 2.2222\n```\nscale变量设置成了四位小数，并在expression中指定了特定和运算\n\n## 退出脚本\n\n**查看退出状态码**\n```shell\n$?\n```\ne.g.\n```shell\necho $?\n# 0\n```\nlinux退出状态码\n\n状态码 | 描述 |\n----- | ----- |\n0 | 命令成功结束\n1 | 一般性未知错误\n2 | 不适合的shell命令\n126 | 命令不可执行\n127 | 没找到命令\n128 | 无效的退出参数\n128+x | 与linux信号相关的严重错误\n130 | 通过 Ctrl + C 终止\n255 | 正常范围之外的状态码\n\n**exit命令**\nexit命令允许在脚本结束时指定一个退出状态码","source":"_posts/shell脚本编程-构建基本脚本令.md","raw":"---\ntitle: shell脚本编程-构建基本脚本令\ndate: 2019-10-20 13:05:29\ntags: [linux, shell]\ncategories: Linux\n---\n\n## 创建shell脚本文件\n\n创建shell脚本文件时,需要在第一行指定要使用的shell:\n\n```shell\n#! /bin/bash\n```\n通常井(#)号用作注释行, 第一行是个例外.\n\n**1.改变文件权限**\n\nchmod命令用来改变文件和目录的安全性，格式如下：\n\n\n```shell\nchmod options mode file\n```\nmode 参数可以使用八进制模式或者符号进行安全设置\n\n**2.八进制模式**\n```shell\nchmod 760 somefile\n```\n得到：\n```shell\nls -l somefile\n# -rwxrw----\n```\n\n**3.符号模式**\n`[ugoa][[+-=][rwxXstigo]]`\n\n```shell\nu 代表用户\ng 代表组\no 代表其他\na 代表上述所有\n------\nr read\nw write\nx 执行权限\nX 如果对象是目录或者它已有执行权限，赋予执行权限\ns 运行时重新设置UID or GID\nt 包括文件或者目录\nu 设置属主权限\ng 设置属组权限\no 设置其他用户权限\n```\n\n**4.执行shell文件**\n第一次执行文件可能会告知没有权限\n```shell\npermission denied: ./somefile.sh\n```\n\n这时候可以用到👆的方法进行赋予权限：\n```shell\nchmod u+x somefile.sh\n```\n\n**5.echo输出消息**\n在echo命令后加上字符串，就可以显示该文本\n```shell\necho \"This is a test\"\n# This is a test\n``` \n\n## 使用变量\nset命令可以显示完整的当前环境变量\n\n**1.环境变量**\n```shell\nset\n```\n如果我们想使用环境变量，只需在名称之前加上$美元符号即可\n```shell\necho $HOME\n```\n**2.用户变量**\n用户可以定义自己的变量,比如我们在方才的`somefile.sh`文件中写入：\n```shell\n#! /bin/bash\n\nval1=5\nval2=10\necho ${val1} ${val2}\n\n# 5 10\n```\n\n## 重定向输入输出\n**1.输出重定向**\n基本的重定向是将命令输出发送到一个文件中.\n```shell\ncommand > outputfile\n```\ne.g.\n\n```shell\ndate > test\n```\n创建了一个test文件, 并将日期写入到该文件中.\n如果文件已经存在，会覆盖原有内容，如果不想覆盖原有内容，而是追加内容，可用双大于号(>>)\n\n```shell\ndate >> test\n```\n**2.输入重定向**\n输入重定向和输出刚好是相反的，将内容重定向到命令, 用小于号`<`\n\n```shell\ncommand < inputfile\n```\n\ne.g.\n\n```shell\nwc < inputfile\n```\n\n可以对文件中的数据进行计数，默认3个值， 行数,词数,字节数\n\n还有一种输入重定向: 内联输入重定向. 内联重定向是远小于号(`<<`),该方法无需使用文件进行查询，只需要在命令行中指定用于输入重定向的数据, 除了该符号，还需要指定一个文本标记来划分输入数据的开始结尾.\n\n## 数学运算\n\n**1.方括号**\n`$[ operation]`\n\n```shell\nval1=5\nval2=10\nval3=$[$val1 - $val2]\necho $val3\n\n# -5\n```\n\n**2.浮点运算**\n```shell\nvariable=$(echo \"options; expression\" | bc)\n```\n\n第一部分options允许你设置变量, 多个变量用分号隔开; expression参数定义了通过`bc`执行数学表达式\n\n```shell\n#! /bin/bash\nval1=100\nval2=45\nval3=$(echo \"scale=4; $val1 / $val2\"| bc)\n\necho The answer for this is $val3\n\n# The answer for this is 2.2222\n```\nscale变量设置成了四位小数，并在expression中指定了特定和运算\n\n## 退出脚本\n\n**查看退出状态码**\n```shell\n$?\n```\ne.g.\n```shell\necho $?\n# 0\n```\nlinux退出状态码\n\n状态码 | 描述 |\n----- | ----- |\n0 | 命令成功结束\n1 | 一般性未知错误\n2 | 不适合的shell命令\n126 | 命令不可执行\n127 | 没找到命令\n128 | 无效的退出参数\n128+x | 与linux信号相关的严重错误\n130 | 通过 Ctrl + C 终止\n255 | 正常范围之外的状态码\n\n**exit命令**\nexit命令允许在脚本结束时指定一个退出状态码","slug":"shell脚本编程-构建基本脚本令","published":1,"updated":"2019-10-20T07:42:29.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91oy0032la2eoasj1tgn","content":"<h2 id=\"创建shell脚本文件\"><a href=\"#创建shell脚本文件\" class=\"headerlink\" title=\"创建shell脚本文件\"></a>创建shell脚本文件</h2><p>创建shell脚本文件时,需要在第一行指定要使用的shell:</p>\n<pre><code class=\"shell\">#! /bin/bash\n</code></pre>\n<p>通常井(#)号用作注释行, 第一行是个例外.</p>\n<p><strong>1.改变文件权限</strong></p>\n<p>chmod命令用来改变文件和目录的安全性，格式如下：</p>\n<pre><code class=\"shell\">chmod options mode file\n</code></pre>\n<p>mode 参数可以使用八进制模式或者符号进行安全设置</p>\n<p><strong>2.八进制模式</strong></p>\n<pre><code class=\"shell\">chmod 760 somefile\n</code></pre>\n<p>得到：</p>\n<pre><code class=\"shell\">ls -l somefile\n# -rwxrw----\n</code></pre>\n<p><strong>3.符号模式</strong><br><code>[ugoa][[+-=][rwxXstigo]]</code></p>\n<pre><code class=\"shell\">u 代表用户\ng 代表组\no 代表其他\na 代表上述所有\n------\nr read\nw write\nx 执行权限\nX 如果对象是目录或者它已有执行权限，赋予执行权限\ns 运行时重新设置UID or GID\nt 包括文件或者目录\nu 设置属主权限\ng 设置属组权限\no 设置其他用户权限\n</code></pre>\n<p><strong>4.执行shell文件</strong><br>第一次执行文件可能会告知没有权限</p>\n<pre><code class=\"shell\">permission denied: ./somefile.sh\n</code></pre>\n<p>这时候可以用到👆的方法进行赋予权限：</p>\n<pre><code class=\"shell\">chmod u+x somefile.sh\n</code></pre>\n<p><strong>5.echo输出消息</strong><br>在echo命令后加上字符串，就可以显示该文本</p>\n<pre><code class=\"shell\">echo &quot;This is a test&quot;\n# This is a test\n</code></pre>\n<h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><p>set命令可以显示完整的当前环境变量</p>\n<p><strong>1.环境变量</strong></p>\n<pre><code class=\"shell\">set\n</code></pre>\n<p>如果我们想使用环境变量，只需在名称之前加上$美元符号即可</p>\n<pre><code class=\"shell\">echo $HOME\n</code></pre>\n<p><strong>2.用户变量</strong><br>用户可以定义自己的变量,比如我们在方才的<code>somefile.sh</code>文件中写入：</p>\n<pre><code class=\"shell\">#! /bin/bash\n\nval1=5\nval2=10\necho ${val1} ${val2}\n\n# 5 10\n</code></pre>\n<h2 id=\"重定向输入输出\"><a href=\"#重定向输入输出\" class=\"headerlink\" title=\"重定向输入输出\"></a>重定向输入输出</h2><p><strong>1.输出重定向</strong><br>基本的重定向是将命令输出发送到一个文件中.</p>\n<pre><code class=\"shell\">command &gt; outputfile\n</code></pre>\n<p>e.g.</p>\n<pre><code class=\"shell\">date &gt; test\n</code></pre>\n<p>创建了一个test文件, 并将日期写入到该文件中.<br>如果文件已经存在，会覆盖原有内容，如果不想覆盖原有内容，而是追加内容，可用双大于号(&gt;&gt;)</p>\n<pre><code class=\"shell\">date &gt;&gt; test\n</code></pre>\n<p><strong>2.输入重定向</strong><br>输入重定向和输出刚好是相反的，将内容重定向到命令, 用小于号<code>&lt;</code></p>\n<pre><code class=\"shell\">command &lt; inputfile\n</code></pre>\n<p>e.g.</p>\n<pre><code class=\"shell\">wc &lt; inputfile\n</code></pre>\n<p>可以对文件中的数据进行计数，默认3个值， 行数,词数,字节数</p>\n<p>还有一种输入重定向: 内联输入重定向. 内联重定向是远小于号(<code>&lt;&lt;</code>),该方法无需使用文件进行查询，只需要在命令行中指定用于输入重定向的数据, 除了该符号，还需要指定一个文本标记来划分输入数据的开始结尾.</p>\n<h2 id=\"数学运算\"><a href=\"#数学运算\" class=\"headerlink\" title=\"数学运算\"></a>数学运算</h2><p><strong>1.方括号</strong><br><code>$[ operation]</code></p>\n<pre><code class=\"shell\">val1=5\nval2=10\nval3=$[$val1 - $val2]\necho $val3\n\n# -5\n</code></pre>\n<p><strong>2.浮点运算</strong></p>\n<pre><code class=\"shell\">variable=$(echo &quot;options; expression&quot; | bc)\n</code></pre>\n<p>第一部分options允许你设置变量, 多个变量用分号隔开; expression参数定义了通过<code>bc</code>执行数学表达式</p>\n<pre><code class=\"shell\">#! /bin/bash\nval1=100\nval2=45\nval3=$(echo &quot;scale=4; $val1 / $val2&quot;| bc)\n\necho The answer for this is $val3\n\n# The answer for this is 2.2222\n</code></pre>\n<p>scale变量设置成了四位小数，并在expression中指定了特定和运算</p>\n<h2 id=\"退出脚本\"><a href=\"#退出脚本\" class=\"headerlink\" title=\"退出脚本\"></a>退出脚本</h2><p><strong>查看退出状态码</strong></p>\n<pre><code class=\"shell\">$?\n</code></pre>\n<p>e.g.</p>\n<pre><code class=\"shell\">echo $?\n# 0\n</code></pre>\n<p>linux退出状态码</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>命令成功结束</td>\n</tr>\n<tr>\n<td>1</td>\n<td>一般性未知错误</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不适合的shell命令</td>\n</tr>\n<tr>\n<td>126</td>\n<td>命令不可执行</td>\n</tr>\n<tr>\n<td>127</td>\n<td>没找到命令</td>\n</tr>\n<tr>\n<td>128</td>\n<td>无效的退出参数</td>\n</tr>\n<tr>\n<td>128+x</td>\n<td>与linux信号相关的严重错误</td>\n</tr>\n<tr>\n<td>130</td>\n<td>通过 Ctrl + C 终止</td>\n</tr>\n<tr>\n<td>255</td>\n<td>正常范围之外的状态码</td>\n</tr>\n</tbody>\n</table>\n<p><strong>exit命令</strong><br>exit命令允许在脚本结束时指定一个退出状态码</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建shell脚本文件\"><a href=\"#创建shell脚本文件\" class=\"headerlink\" title=\"创建shell脚本文件\"></a>创建shell脚本文件</h2><p>创建shell脚本文件时,需要在第一行指定要使用的shell:</p>\n<pre><code class=\"shell\">#! /bin/bash\n</code></pre>\n<p>通常井(#)号用作注释行, 第一行是个例外.</p>\n<p><strong>1.改变文件权限</strong></p>\n<p>chmod命令用来改变文件和目录的安全性，格式如下：</p>\n<pre><code class=\"shell\">chmod options mode file\n</code></pre>\n<p>mode 参数可以使用八进制模式或者符号进行安全设置</p>\n<p><strong>2.八进制模式</strong></p>\n<pre><code class=\"shell\">chmod 760 somefile\n</code></pre>\n<p>得到：</p>\n<pre><code class=\"shell\">ls -l somefile\n# -rwxrw----\n</code></pre>\n<p><strong>3.符号模式</strong><br><code>[ugoa][[+-=][rwxXstigo]]</code></p>\n<pre><code class=\"shell\">u 代表用户\ng 代表组\no 代表其他\na 代表上述所有\n------\nr read\nw write\nx 执行权限\nX 如果对象是目录或者它已有执行权限，赋予执行权限\ns 运行时重新设置UID or GID\nt 包括文件或者目录\nu 设置属主权限\ng 设置属组权限\no 设置其他用户权限\n</code></pre>\n<p><strong>4.执行shell文件</strong><br>第一次执行文件可能会告知没有权限</p>\n<pre><code class=\"shell\">permission denied: ./somefile.sh\n</code></pre>\n<p>这时候可以用到👆的方法进行赋予权限：</p>\n<pre><code class=\"shell\">chmod u+x somefile.sh\n</code></pre>\n<p><strong>5.echo输出消息</strong><br>在echo命令后加上字符串，就可以显示该文本</p>\n<pre><code class=\"shell\">echo &quot;This is a test&quot;\n# This is a test\n</code></pre>\n<h2 id=\"使用变量\"><a href=\"#使用变量\" class=\"headerlink\" title=\"使用变量\"></a>使用变量</h2><p>set命令可以显示完整的当前环境变量</p>\n<p><strong>1.环境变量</strong></p>\n<pre><code class=\"shell\">set\n</code></pre>\n<p>如果我们想使用环境变量，只需在名称之前加上$美元符号即可</p>\n<pre><code class=\"shell\">echo $HOME\n</code></pre>\n<p><strong>2.用户变量</strong><br>用户可以定义自己的变量,比如我们在方才的<code>somefile.sh</code>文件中写入：</p>\n<pre><code class=\"shell\">#! /bin/bash\n\nval1=5\nval2=10\necho ${val1} ${val2}\n\n# 5 10\n</code></pre>\n<h2 id=\"重定向输入输出\"><a href=\"#重定向输入输出\" class=\"headerlink\" title=\"重定向输入输出\"></a>重定向输入输出</h2><p><strong>1.输出重定向</strong><br>基本的重定向是将命令输出发送到一个文件中.</p>\n<pre><code class=\"shell\">command &gt; outputfile\n</code></pre>\n<p>e.g.</p>\n<pre><code class=\"shell\">date &gt; test\n</code></pre>\n<p>创建了一个test文件, 并将日期写入到该文件中.<br>如果文件已经存在，会覆盖原有内容，如果不想覆盖原有内容，而是追加内容，可用双大于号(&gt;&gt;)</p>\n<pre><code class=\"shell\">date &gt;&gt; test\n</code></pre>\n<p><strong>2.输入重定向</strong><br>输入重定向和输出刚好是相反的，将内容重定向到命令, 用小于号<code>&lt;</code></p>\n<pre><code class=\"shell\">command &lt; inputfile\n</code></pre>\n<p>e.g.</p>\n<pre><code class=\"shell\">wc &lt; inputfile\n</code></pre>\n<p>可以对文件中的数据进行计数，默认3个值， 行数,词数,字节数</p>\n<p>还有一种输入重定向: 内联输入重定向. 内联重定向是远小于号(<code>&lt;&lt;</code>),该方法无需使用文件进行查询，只需要在命令行中指定用于输入重定向的数据, 除了该符号，还需要指定一个文本标记来划分输入数据的开始结尾.</p>\n<h2 id=\"数学运算\"><a href=\"#数学运算\" class=\"headerlink\" title=\"数学运算\"></a>数学运算</h2><p><strong>1.方括号</strong><br><code>$[ operation]</code></p>\n<pre><code class=\"shell\">val1=5\nval2=10\nval3=$[$val1 - $val2]\necho $val3\n\n# -5\n</code></pre>\n<p><strong>2.浮点运算</strong></p>\n<pre><code class=\"shell\">variable=$(echo &quot;options; expression&quot; | bc)\n</code></pre>\n<p>第一部分options允许你设置变量, 多个变量用分号隔开; expression参数定义了通过<code>bc</code>执行数学表达式</p>\n<pre><code class=\"shell\">#! /bin/bash\nval1=100\nval2=45\nval3=$(echo &quot;scale=4; $val1 / $val2&quot;| bc)\n\necho The answer for this is $val3\n\n# The answer for this is 2.2222\n</code></pre>\n<p>scale变量设置成了四位小数，并在expression中指定了特定和运算</p>\n<h2 id=\"退出脚本\"><a href=\"#退出脚本\" class=\"headerlink\" title=\"退出脚本\"></a>退出脚本</h2><p><strong>查看退出状态码</strong></p>\n<pre><code class=\"shell\">$?\n</code></pre>\n<p>e.g.</p>\n<pre><code class=\"shell\">echo $?\n# 0\n</code></pre>\n<p>linux退出状态码</p>\n<table>\n<thead>\n<tr>\n<th>状态码</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>命令成功结束</td>\n</tr>\n<tr>\n<td>1</td>\n<td>一般性未知错误</td>\n</tr>\n<tr>\n<td>2</td>\n<td>不适合的shell命令</td>\n</tr>\n<tr>\n<td>126</td>\n<td>命令不可执行</td>\n</tr>\n<tr>\n<td>127</td>\n<td>没找到命令</td>\n</tr>\n<tr>\n<td>128</td>\n<td>无效的退出参数</td>\n</tr>\n<tr>\n<td>128+x</td>\n<td>与linux信号相关的严重错误</td>\n</tr>\n<tr>\n<td>130</td>\n<td>通过 Ctrl + C 终止</td>\n</tr>\n<tr>\n<td>255</td>\n<td>正常范围之外的状态码</td>\n</tr>\n</tbody>\n</table>\n<p><strong>exit命令</strong><br>exit命令允许在脚本结束时指定一个退出状态码</p>\n"},{"title":"写Vue回到顶部组件遇到的一些问题","date":"2017-10-15T04:13:12.000Z","_content":"\n<!-- more -->\n> 人的懒惰是有惯性的，写博客也是一旦停下来就会一直懒下去，相反一旦坚持下来，也会有惯性，所以我要开始更文啦...\n\n## 效果\n![](http://oq4hkch8e.bkt.clouddn.com/backTop.gif)\n[组件地址](https://github.com/BiYuqi/daily-practice/blob/master/Vue/todo-app/src/components/BackTop/BackTop.vue)\n## 问题\n\n### 1.谷歌浏览器下document.body.scrollTop失效\n经查阅此版本(版本为61)后的均需要使用document.documentElement.scrollTop来替代\n### 2.vue怎么监听滚动事件\n```html\n<div class=\"back-top\" @click=\"goTop\" name=\"button\" v-show=\"visible\" :style=\"customStyle\">\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 17 17\" xmlns=\"http://www.w3.org/2000/svg\" class=\"back-icon\" aria-hidden=\"true\" style=\"height: 16px; width: 16px;\">\n        <g>\n          <path d=\"M12.036 15.59c0 .55-.453.995-.997.995H5.032c-.55 0-.997-.445-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29c.39-.39 1.026-.385 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z\" fill-rule=\"evenodd\"></path>\n        </g>\n      </svg>\n</div>\n```\n```js\nexport default {\n    props:{\n        visibleHeight: { // 按钮出现条件\n            type: Number,\n            default: 400\n        },\n        rate: {\n            type: Number, // 滚动速率\n            default: 4\n        },\n        customStyle: { // 默认样式\n            type: Object,\n            default() {  // 此处由于是Object 所以要返回一个函数\n                return {\n                    right: '50px',\n                    bottom: '50px',\n                    width: '40px',\n                    height: '40px',\n                    'border-radius': '4px',\n                    'line-height': '45px',\n                    background: '#e7eaf1'\n                }\n            }\n        }\n    },\n    data() {\n        return {\n            scrollTop: '',\n            visible: false, // 是否显示\n            interval: null  // 定时器\n\n        }\n    },\n    mounted() {\n        // Dom加载完毕时监听scroll事件\n        window.addEventListener('scroll', this.handleScroll)\n    },\n    beforeDestroy() {\n        window.removeEventListener('scroll', this.handleScroll)\n            if (this.interval) {\n                clearInterval(this.interval)\n            }\n    },\n    methods:{\n        handleScroll() {\n            // 判断条件\n            this.visible = window.pageYOffset > this.visibleHeight\n            this.scrollTop = window.pageYOffset\n        },\n        goTop(e) {\n            this.interval = setInterval(()=>{\n                this.scrollTop = this.scrollTop + (-this.scrollTop)/this.rate\n                window.scrollTo(0,this.scrollTop)\n                if(this.scrollTop <= 0){\n                    window.scrollTo(0,0)\n                    clearInterval(this.interval)\n                }\n            },13)\n        }\n    }\n}\n```\n\n### 3.window.scrollTo(x,y)是什么鬼\n此方法为滚动到文档中的某个坐标，x 是文档中的横轴坐标。y 是文档中的纵轴坐标。\n该函数实际上和 window.scroll是一样的\n[具体请看MDM介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollTo)\n### 4.组件使用方法\n```js\n//1. 先引入\nimport BackTop from '@/components/BackTop/BackTop.vue'\n\n```\n```html\n<!-- 2. 页面使用方法 -->\n<back-top :visibleHeight=\"50\" :rate=\"6\"></back-top>\n```\n## 缓动动画算法\n之前看过张鑫旭大神写过这个方法，所以本文就直接拿来用了，具体算法是\n![](http://oq4hkch8e.bkt.clouddn.com/js-animate.png)\n```js\nA = A + (B - A) / 2\n\n我下一秒的位置 = 现在位置 + 现在和初始之间距离的一半\n```\n\n\n## 参考算法：\n[张鑫旭-分享一个即插即用的私藏缓动动画JS小算法](http://www.zhangxinxu.com/wordpress/2017/01/share-a-animation-algorithm-js/)\n","source":"_posts/vue写回到顶部组件遇到的一些问题.md","raw":"---\ntitle: 写Vue回到顶部组件遇到的一些问题\ndate: 2017-10-15 12:13:12\ntags: [Vue,Javascript]\ncategories: Javascript\n---\n\n<!-- more -->\n> 人的懒惰是有惯性的，写博客也是一旦停下来就会一直懒下去，相反一旦坚持下来，也会有惯性，所以我要开始更文啦...\n\n## 效果\n![](http://oq4hkch8e.bkt.clouddn.com/backTop.gif)\n[组件地址](https://github.com/BiYuqi/daily-practice/blob/master/Vue/todo-app/src/components/BackTop/BackTop.vue)\n## 问题\n\n### 1.谷歌浏览器下document.body.scrollTop失效\n经查阅此版本(版本为61)后的均需要使用document.documentElement.scrollTop来替代\n### 2.vue怎么监听滚动事件\n```html\n<div class=\"back-top\" @click=\"goTop\" name=\"button\" v-show=\"visible\" :style=\"customStyle\">\n    <svg width=\"16\" height=\"16\" viewBox=\"0 0 17 17\" xmlns=\"http://www.w3.org/2000/svg\" class=\"back-icon\" aria-hidden=\"true\" style=\"height: 16px; width: 16px;\">\n        <g>\n          <path d=\"M12.036 15.59c0 .55-.453.995-.997.995H5.032c-.55 0-.997-.445-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29c.39-.39 1.026-.385 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z\" fill-rule=\"evenodd\"></path>\n        </g>\n      </svg>\n</div>\n```\n```js\nexport default {\n    props:{\n        visibleHeight: { // 按钮出现条件\n            type: Number,\n            default: 400\n        },\n        rate: {\n            type: Number, // 滚动速率\n            default: 4\n        },\n        customStyle: { // 默认样式\n            type: Object,\n            default() {  // 此处由于是Object 所以要返回一个函数\n                return {\n                    right: '50px',\n                    bottom: '50px',\n                    width: '40px',\n                    height: '40px',\n                    'border-radius': '4px',\n                    'line-height': '45px',\n                    background: '#e7eaf1'\n                }\n            }\n        }\n    },\n    data() {\n        return {\n            scrollTop: '',\n            visible: false, // 是否显示\n            interval: null  // 定时器\n\n        }\n    },\n    mounted() {\n        // Dom加载完毕时监听scroll事件\n        window.addEventListener('scroll', this.handleScroll)\n    },\n    beforeDestroy() {\n        window.removeEventListener('scroll', this.handleScroll)\n            if (this.interval) {\n                clearInterval(this.interval)\n            }\n    },\n    methods:{\n        handleScroll() {\n            // 判断条件\n            this.visible = window.pageYOffset > this.visibleHeight\n            this.scrollTop = window.pageYOffset\n        },\n        goTop(e) {\n            this.interval = setInterval(()=>{\n                this.scrollTop = this.scrollTop + (-this.scrollTop)/this.rate\n                window.scrollTo(0,this.scrollTop)\n                if(this.scrollTop <= 0){\n                    window.scrollTo(0,0)\n                    clearInterval(this.interval)\n                }\n            },13)\n        }\n    }\n}\n```\n\n### 3.window.scrollTo(x,y)是什么鬼\n此方法为滚动到文档中的某个坐标，x 是文档中的横轴坐标。y 是文档中的纵轴坐标。\n该函数实际上和 window.scroll是一样的\n[具体请看MDM介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollTo)\n### 4.组件使用方法\n```js\n//1. 先引入\nimport BackTop from '@/components/BackTop/BackTop.vue'\n\n```\n```html\n<!-- 2. 页面使用方法 -->\n<back-top :visibleHeight=\"50\" :rate=\"6\"></back-top>\n```\n## 缓动动画算法\n之前看过张鑫旭大神写过这个方法，所以本文就直接拿来用了，具体算法是\n![](http://oq4hkch8e.bkt.clouddn.com/js-animate.png)\n```js\nA = A + (B - A) / 2\n\n我下一秒的位置 = 现在位置 + 现在和初始之间距离的一半\n```\n\n\n## 参考算法：\n[张鑫旭-分享一个即插即用的私藏缓动动画JS小算法](http://www.zhangxinxu.com/wordpress/2017/01/share-a-animation-algorithm-js/)\n","slug":"vue写回到顶部组件遇到的一些问题","published":1,"updated":"2019-09-25T15:10:25.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91p00034la2ecyj3bto6","content":"<a id=\"more\"></a>\n<blockquote>\n<p>人的懒惰是有惯性的，写博客也是一旦停下来就会一直懒下去，相反一旦坚持下来，也会有惯性，所以我要开始更文啦…</p>\n</blockquote>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><img src=\"http://oq4hkch8e.bkt.clouddn.com/backTop.gif\" alt=\"\"><br><a href=\"https://github.com/BiYuqi/daily-practice/blob/master/Vue/todo-app/src/components/BackTop/BackTop.vue\" target=\"_blank\" rel=\"external\">组件地址</a></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"1-谷歌浏览器下document-body-scrollTop失效\"><a href=\"#1-谷歌浏览器下document-body-scrollTop失效\" class=\"headerlink\" title=\"1.谷歌浏览器下document.body.scrollTop失效\"></a>1.谷歌浏览器下document.body.scrollTop失效</h3><p>经查阅此版本(版本为61)后的均需要使用document.documentElement.scrollTop来替代</p>\n<h3 id=\"2-vue怎么监听滚动事件\"><a href=\"#2-vue怎么监听滚动事件\" class=\"headerlink\" title=\"2.vue怎么监听滚动事件\"></a>2.vue怎么监听滚动事件</h3><pre><code class=\"html\">&lt;div class=&quot;back-top&quot; @click=&quot;goTop&quot; name=&quot;button&quot; v-show=&quot;visible&quot; :style=&quot;customStyle&quot;&gt;\n    &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 17 17&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;back-icon&quot; aria-hidden=&quot;true&quot; style=&quot;height: 16px; width: 16px;&quot;&gt;\n        &lt;g&gt;\n          &lt;path d=&quot;M12.036 15.59c0 .55-.453.995-.997.995H5.032c-.55 0-.997-.445-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29c.39-.39 1.026-.385 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z&quot; fill-rule=&quot;evenodd&quot;&gt;&lt;/path&gt;\n        &lt;/g&gt;\n      &lt;/svg&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"js\">export default {\n    props:{\n        visibleHeight: { // 按钮出现条件\n            type: Number,\n            default: 400\n        },\n        rate: {\n            type: Number, // 滚动速率\n            default: 4\n        },\n        customStyle: { // 默认样式\n            type: Object,\n            default() {  // 此处由于是Object 所以要返回一个函数\n                return {\n                    right: &#39;50px&#39;,\n                    bottom: &#39;50px&#39;,\n                    width: &#39;40px&#39;,\n                    height: &#39;40px&#39;,\n                    &#39;border-radius&#39;: &#39;4px&#39;,\n                    &#39;line-height&#39;: &#39;45px&#39;,\n                    background: &#39;#e7eaf1&#39;\n                }\n            }\n        }\n    },\n    data() {\n        return {\n            scrollTop: &#39;&#39;,\n            visible: false, // 是否显示\n            interval: null  // 定时器\n\n        }\n    },\n    mounted() {\n        // Dom加载完毕时监听scroll事件\n        window.addEventListener(&#39;scroll&#39;, this.handleScroll)\n    },\n    beforeDestroy() {\n        window.removeEventListener(&#39;scroll&#39;, this.handleScroll)\n            if (this.interval) {\n                clearInterval(this.interval)\n            }\n    },\n    methods:{\n        handleScroll() {\n            // 判断条件\n            this.visible = window.pageYOffset &gt; this.visibleHeight\n            this.scrollTop = window.pageYOffset\n        },\n        goTop(e) {\n            this.interval = setInterval(()=&gt;{\n                this.scrollTop = this.scrollTop + (-this.scrollTop)/this.rate\n                window.scrollTo(0,this.scrollTop)\n                if(this.scrollTop &lt;= 0){\n                    window.scrollTo(0,0)\n                    clearInterval(this.interval)\n                }\n            },13)\n        }\n    }\n}\n</code></pre>\n<h3 id=\"3-window-scrollTo-x-y-是什么鬼\"><a href=\"#3-window-scrollTo-x-y-是什么鬼\" class=\"headerlink\" title=\"3.window.scrollTo(x,y)是什么鬼\"></a>3.window.scrollTo(x,y)是什么鬼</h3><p>此方法为滚动到文档中的某个坐标，x 是文档中的横轴坐标。y 是文档中的纵轴坐标。<br>该函数实际上和 window.scroll是一样的<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollTo\" target=\"_blank\" rel=\"external\">具体请看MDM介绍</a></p>\n<h3 id=\"4-组件使用方法\"><a href=\"#4-组件使用方法\" class=\"headerlink\" title=\"4.组件使用方法\"></a>4.组件使用方法</h3><pre><code class=\"js\">//1. 先引入\nimport BackTop from &#39;@/components/BackTop/BackTop.vue&#39;\n</code></pre>\n<pre><code class=\"html\">&lt;!-- 2. 页面使用方法 --&gt;\n&lt;back-top :visibleHeight=&quot;50&quot; :rate=&quot;6&quot;&gt;&lt;/back-top&gt;\n</code></pre>\n<h2 id=\"缓动动画算法\"><a href=\"#缓动动画算法\" class=\"headerlink\" title=\"缓动动画算法\"></a>缓动动画算法</h2><p>之前看过张鑫旭大神写过这个方法，所以本文就直接拿来用了，具体算法是<br><img src=\"http://oq4hkch8e.bkt.clouddn.com/js-animate.png\" alt=\"\"></p>\n<pre><code class=\"js\">A = A + (B - A) / 2\n\n我下一秒的位置 = 现在位置 + 现在和初始之间距离的一半\n</code></pre>\n<h2 id=\"参考算法：\"><a href=\"#参考算法：\" class=\"headerlink\" title=\"参考算法：\"></a>参考算法：</h2><p><a href=\"http://www.zhangxinxu.com/wordpress/2017/01/share-a-animation-algorithm-js/\" target=\"_blank\" rel=\"external\">张鑫旭-分享一个即插即用的私藏缓动动画JS小算法</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>人的懒惰是有惯性的，写博客也是一旦停下来就会一直懒下去，相反一旦坚持下来，也会有惯性，所以我要开始更文啦…</p>\n</blockquote>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><img src=\"http://oq4hkch8e.bkt.clouddn.com/backTop.gif\" alt=\"\"><br><a href=\"https://github.com/BiYuqi/daily-practice/blob/master/Vue/todo-app/src/components/BackTop/BackTop.vue\" target=\"_blank\" rel=\"external\">组件地址</a></p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"1-谷歌浏览器下document-body-scrollTop失效\"><a href=\"#1-谷歌浏览器下document-body-scrollTop失效\" class=\"headerlink\" title=\"1.谷歌浏览器下document.body.scrollTop失效\"></a>1.谷歌浏览器下document.body.scrollTop失效</h3><p>经查阅此版本(版本为61)后的均需要使用document.documentElement.scrollTop来替代</p>\n<h3 id=\"2-vue怎么监听滚动事件\"><a href=\"#2-vue怎么监听滚动事件\" class=\"headerlink\" title=\"2.vue怎么监听滚动事件\"></a>2.vue怎么监听滚动事件</h3><pre><code class=\"html\">&lt;div class=&quot;back-top&quot; @click=&quot;goTop&quot; name=&quot;button&quot; v-show=&quot;visible&quot; :style=&quot;customStyle&quot;&gt;\n    &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 17 17&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;back-icon&quot; aria-hidden=&quot;true&quot; style=&quot;height: 16px; width: 16px;&quot;&gt;\n        &lt;g&gt;\n          &lt;path d=&quot;M12.036 15.59c0 .55-.453.995-.997.995H5.032c-.55 0-.997-.445-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29c.39-.39 1.026-.385 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z&quot; fill-rule=&quot;evenodd&quot;&gt;&lt;/path&gt;\n        &lt;/g&gt;\n      &lt;/svg&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"js\">export default {\n    props:{\n        visibleHeight: { // 按钮出现条件\n            type: Number,\n            default: 400\n        },\n        rate: {\n            type: Number, // 滚动速率\n            default: 4\n        },\n        customStyle: { // 默认样式\n            type: Object,\n            default() {  // 此处由于是Object 所以要返回一个函数\n                return {\n                    right: &#39;50px&#39;,\n                    bottom: &#39;50px&#39;,\n                    width: &#39;40px&#39;,\n                    height: &#39;40px&#39;,\n                    &#39;border-radius&#39;: &#39;4px&#39;,\n                    &#39;line-height&#39;: &#39;45px&#39;,\n                    background: &#39;#e7eaf1&#39;\n                }\n            }\n        }\n    },\n    data() {\n        return {\n            scrollTop: &#39;&#39;,\n            visible: false, // 是否显示\n            interval: null  // 定时器\n\n        }\n    },\n    mounted() {\n        // Dom加载完毕时监听scroll事件\n        window.addEventListener(&#39;scroll&#39;, this.handleScroll)\n    },\n    beforeDestroy() {\n        window.removeEventListener(&#39;scroll&#39;, this.handleScroll)\n            if (this.interval) {\n                clearInterval(this.interval)\n            }\n    },\n    methods:{\n        handleScroll() {\n            // 判断条件\n            this.visible = window.pageYOffset &gt; this.visibleHeight\n            this.scrollTop = window.pageYOffset\n        },\n        goTop(e) {\n            this.interval = setInterval(()=&gt;{\n                this.scrollTop = this.scrollTop + (-this.scrollTop)/this.rate\n                window.scrollTo(0,this.scrollTop)\n                if(this.scrollTop &lt;= 0){\n                    window.scrollTo(0,0)\n                    clearInterval(this.interval)\n                }\n            },13)\n        }\n    }\n}\n</code></pre>\n<h3 id=\"3-window-scrollTo-x-y-是什么鬼\"><a href=\"#3-window-scrollTo-x-y-是什么鬼\" class=\"headerlink\" title=\"3.window.scrollTo(x,y)是什么鬼\"></a>3.window.scrollTo(x,y)是什么鬼</h3><p>此方法为滚动到文档中的某个坐标，x 是文档中的横轴坐标。y 是文档中的纵轴坐标。<br>该函数实际上和 window.scroll是一样的<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollTo\" target=\"_blank\" rel=\"external\">具体请看MDM介绍</a></p>\n<h3 id=\"4-组件使用方法\"><a href=\"#4-组件使用方法\" class=\"headerlink\" title=\"4.组件使用方法\"></a>4.组件使用方法</h3><pre><code class=\"js\">//1. 先引入\nimport BackTop from &#39;@/components/BackTop/BackTop.vue&#39;\n</code></pre>\n<pre><code class=\"html\">&lt;!-- 2. 页面使用方法 --&gt;\n&lt;back-top :visibleHeight=&quot;50&quot; :rate=&quot;6&quot;&gt;&lt;/back-top&gt;\n</code></pre>\n<h2 id=\"缓动动画算法\"><a href=\"#缓动动画算法\" class=\"headerlink\" title=\"缓动动画算法\"></a>缓动动画算法</h2><p>之前看过张鑫旭大神写过这个方法，所以本文就直接拿来用了，具体算法是<br><img src=\"http://oq4hkch8e.bkt.clouddn.com/js-animate.png\" alt=\"\"></p>\n<pre><code class=\"js\">A = A + (B - A) / 2\n\n我下一秒的位置 = 现在位置 + 现在和初始之间距离的一半\n</code></pre>\n<h2 id=\"参考算法：\"><a href=\"#参考算法：\" class=\"headerlink\" title=\"参考算法：\"></a>参考算法：</h2><p><a href=\"http://www.zhangxinxu.com/wordpress/2017/01/share-a-animation-algorithm-js/\" target=\"_blank\" rel=\"external\">张鑫旭-分享一个即插即用的私藏缓动动画JS小算法</a></p>"},{"title":"window命令行下输入javac提示不是内部或外部命令解决方法","date":"2017-02-20T12:53:28.000Z","_content":"> ** 下午用Cordova打包app时，提示未安装jdk，可是我明明安装jdk了，java -version也有版本提示;这就奇了怪，于是网上各种搜罗，于是有了这篇文章 **\n\n<!-- more -->\n### 前言\n** 本文的前提是电脑中已经安装好java，配置好环境变量后出现的问题(某些情况下);没有安装的请自行安装 ** [JAVA-jdk][1]**\n### 正文\n找到 ** 高级系统设置>环境变量>系统变量>Path **\npath路径里面添加jdk和jre的路径下面bin文件夹路径,格式：\n![][2]\n** 我的安装路径可能与大家不一样,可自行选择路径追加到Path后面记得有分号;**\n;C:\\Program Files (x86)\\Java\\jdk1.8.0_101\\bin;C:\\Program Files (x86)\\Java\\jre1.8.0_101\\bin\n### 原理\n** 加入绝对路径可以无视JAVA_HOME,win会把Path路径下面所有可执行的文件都枚举出来 **\n\n[1]: http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n[2]: http://oiukswkar.bkt.clouddn.com/javac.png\n","source":"_posts/window下输入javac提示不是内部或外部命令解决方法.md","raw":"---\ntitle: window命令行下输入javac提示不是内部或外部命令解决方法\ndate: 2017-02-20 20:53:28\ntags: [window,java]\ncategories: 经验\n---\n> ** 下午用Cordova打包app时，提示未安装jdk，可是我明明安装jdk了，java -version也有版本提示;这就奇了怪，于是网上各种搜罗，于是有了这篇文章 **\n\n<!-- more -->\n### 前言\n** 本文的前提是电脑中已经安装好java，配置好环境变量后出现的问题(某些情况下);没有安装的请自行安装 ** [JAVA-jdk][1]**\n### 正文\n找到 ** 高级系统设置>环境变量>系统变量>Path **\npath路径里面添加jdk和jre的路径下面bin文件夹路径,格式：\n![][2]\n** 我的安装路径可能与大家不一样,可自行选择路径追加到Path后面记得有分号;**\n;C:\\Program Files (x86)\\Java\\jdk1.8.0_101\\bin;C:\\Program Files (x86)\\Java\\jre1.8.0_101\\bin\n### 原理\n** 加入绝对路径可以无视JAVA_HOME,win会把Path路径下面所有可执行的文件都枚举出来 **\n\n[1]: http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\n[2]: http://oiukswkar.bkt.clouddn.com/javac.png\n","slug":"window下输入javac提示不是内部或外部命令解决方法","published":1,"updated":"2019-09-25T15:10:25.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91p10037la2eqv5dzwq3","content":"<blockquote>\n<p><strong> 下午用Cordova打包app时，提示未安装jdk，可是我明明安装jdk了，java -version也有版本提示;这就奇了怪，于是网上各种搜罗，于是有了这篇文章 </strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><strong> 本文的前提是电脑中已经安装好java，配置好环境变量后出现的问题(某些情况下);没有安装的请自行安装 </strong> <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"external\">JAVA-jdk</a>**</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>找到 <strong> 高级系统设置&gt;环境变量&gt;系统变量&gt;Path </strong><br>path路径里面添加jdk和jre的路径下面bin文件夹路径,格式：<br><img src=\"http://oiukswkar.bkt.clouddn.com/javac.png\" alt=\"\"><br><strong> 我的安装路径可能与大家不一样,可自行选择路径追加到Path后面记得有分号;</strong><br>;C:\\Program Files (x86)\\Java\\jdk1.8.0_101\\bin;C:\\Program Files (x86)\\Java\\jre1.8.0_101\\bin</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><strong> 加入绝对路径可以无视JAVA_HOME,win会把Path路径下面所有可执行的文件都枚举出来 </strong></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong> 下午用Cordova打包app时，提示未安装jdk，可是我明明安装jdk了，java -version也有版本提示;这就奇了怪，于是网上各种搜罗，于是有了这篇文章 </strong></p>\n</blockquote>","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><strong> 本文的前提是电脑中已经安装好java，配置好环境变量后出现的问题(某些情况下);没有安装的请自行安装 </strong> <a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"external\">JAVA-jdk</a>**</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>找到 <strong> 高级系统设置&gt;环境变量&gt;系统变量&gt;Path </strong><br>path路径里面添加jdk和jre的路径下面bin文件夹路径,格式：<br><img src=\"http://oiukswkar.bkt.clouddn.com/javac.png\" alt=\"\"><br><strong> 我的安装路径可能与大家不一样,可自行选择路径追加到Path后面记得有分号;</strong><br>;C:\\Program Files (x86)\\Java\\jdk1.8.0_101\\bin;C:\\Program Files (x86)\\Java\\jre1.8.0_101\\bin</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p><strong> 加入绝对路径可以无视JAVA_HOME,win会把Path路径下面所有可执行的文件都枚举出来 </strong></p>"},{"title":"《你不知道的javascript中》JS宽松相等和严格相等","date":"2017-06-21T12:43:07.000Z","author":"Yuqi Bi","header-img":"form-opts.png","cdn":"header-on","_content":"> 温故而知新，最近在看《你不知道的javascript》系列的书记，看到深处，总有新的发现，好记性不如烂笔头，遂写下这篇读书笔记\n\n## 前言\n宽松相等==和严格相等===都用来判断两个值是否\"相等\",但是他们也有一个很重要的区别，尤其是判断条件上\n常见的误区是\"==检查值是否相等，===检查值和类型是否相等\"。这样理解似乎有点道理，但是还不够准确，正确的解释是：\n> \"==允许在相等比较中进行强制类型转换，而===不允许\"\n\n# 抽象值操作\n(名词解释，后面用到再来看也可以)\n## ToNumber\nES5 规范在 9.3 节定义了\n抽象操作 ToNumber。\n其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。\n## ToString\n定义了抽象操作 ToString，它负责处理非字符串到字符串的强制类型转换。\n基本类型值的字符串化规则为：null 转换为 \"null\"，undefined 转换为 \"undefined\"，true\n转换为 \"true\"。数字的字符串化则遵循通用规则\n## ToPrimitive\n为了将值转换为相应的基本类型值，抽象操作 ToPrimitive（参见 ES5 规范 9.1 节）会首先\n（通过内部操作 DefaultValue，参见 ES5 规范 8.12.8 节）检查该值是否有 valueOf() 方法。\n如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString()\n的返回值（如果存在）来进行强制类型转换。\n如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误\n# 抽象相等\n\n## 1.字符串和数字之间的相等比较\n```js\nvar a = 42；\nvar b = \"42\";\n\na === b //false\na == b //true\n```\n因为没有强制类型的转换，所以a===b为false,42不等于\"42\"\na == b 是宽松相等,如果值得类型不同，则对其中之一或者两者进行强制类型转换。\n具体怎么转环？还要看规范：\nES5规范汇这样定义：\n\n**(1) 如果Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y)的结果。**\n\n**(2) 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果**\n\n## 2.其他类型和布尔类型之间的相等比较\n== 最容易出错的一个地方时true和false与其他类型之间的相等比较。\n```js\nvar a = \"42\";\nvar b = true;\n\na == b // false\n```\n根据以往的经验，\"42\"是一个真值，为什么==的结果不是true呢？原因及简单又复杂，很容易掉坑里，看看规范怎么说：\n\n**(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果 **\n\n**(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果**\n看个例子\n```js\nvar x = true\nvar y = \"42\"\n\nx == y //false\n```\nType(x)是布尔值，所以准换后为1，变为1 == \"42\",两者类型仍然不通，进而\"42\"继续转换为42，最后变为1 == 42，结果是false，\n反过来也一样\n```js\nvar x = '42'\nvar y = false\n\nx == y //false\n```\n一个值既不等于true,也不等于false.太奇怪了吧？\n\n这个问题本身就是错误的，我们被自己的大脑欺骗了。\n\n\"42\" 是一个真值没错，但 \"42\" == true 中并没有发生布尔值的比较和强制类型转换。\n\n这里不是 \"42\" 转换为布尔值（true） ，而是 true 转换为 1，\"42\" 转换为 42。\n\n这里并不涉及 ToBoolean，所以 \"42\" 是真值还是假值与 == 本身没有关系！\n重点是我们要搞清楚 == 对不同的类型组合怎样处理。== 两边的布尔值会被强制类型转换为数字。\n\n很奇怪吧？建议无论什么情况下都不要使用 == true 和 == false。\n请注意，这里说的只是 ==，=== true 和 === false 不允许强制类型转换，所以并不涉及ToNumber。\n```js\nvar a = '42'\n\n// 不要这样用，条件不成立\nif(a == true){\n    //\n}\n\n// 也不要这样\nif(a === true){\n    //\n}\n\n//这样显式用法没有问题\nif(a){\n    //\n}\n\n// 这样的显式更好\nif(!!a){\n    //\n}\n\n```\n避免了 == true 和 == false(也叫作布尔值的宽松相等)之后就不用担心这些坑了\n## 3.null和undefined之间的相等比较\nnull 和 unfined之间的== 也涉及隐式强制类型的转换：\n\n**(1)如果x为null,y为unfined,这结果为true**\n\n**(2)如果x为unfined，y为null,则结果为true**\n\n在==中null和unfined相等(他们也与其自身相等),除此之外其他值不存在这种情况\n```js\nvar a = nul;\nvar b;\n\na == b //true\na == null // true\nb == null //true\n\na == false  //false\nb == false //false\na == ''  //false\nb == ''  //fasle\na == 0  //false\nb == 0 //false\n```\nnull 和 undefined 之间的强制类型转换是安全可靠的，上例中除 null 和 undefined 以外的\n\n其他值均无法得到假阳（false positive）结果。个人认为通过这种方式将 null 和 undefined\n作为等价值来处理比较好。\nex:\n```js\nvar a = doSomething()\n\nif(a == null){\n    //...\n}\n```\n条件判断a ==null仅仅在函数返回null和undefined时才成立，除此之外都不成立\n\n## 4.对象和非对象之间的相等比较\nES5 规范 11.9.3.8-9 做如下规定：\n\n**(1)如果Type(x)是字符串或者数字，Type(y)是对象，则返回x == ToPromitive(y)的结果**\n\n**(2)如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果**\n\n```js\nvar a = 42\nvar b = [42]\na == b //true\n```\n[ 42 ] 首先调用 ToPromitive 抽象操作 ，返回 \"42\"，变成 \"42\" == 42，然后\n又变成 42 == 42，最后二者相等\n\n# 资料\n[JavaScript 中的相等性判断|MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)\n","source":"_posts/《你不知道的javascript中》JS宽松相等和严格相等.md","raw":"---\ntitle: 《你不知道的javascript中》JS宽松相等和严格相等\ndate: 2017-06-21 20:43:07\ntags: [Javascript]\nauthor: \"Yuqi Bi\"\nheader-img: \"form-opts.png\"\ncdn: 'header-on'\n---\n> 温故而知新，最近在看《你不知道的javascript》系列的书记，看到深处，总有新的发现，好记性不如烂笔头，遂写下这篇读书笔记\n\n## 前言\n宽松相等==和严格相等===都用来判断两个值是否\"相等\",但是他们也有一个很重要的区别，尤其是判断条件上\n常见的误区是\"==检查值是否相等，===检查值和类型是否相等\"。这样理解似乎有点道理，但是还不够准确，正确的解释是：\n> \"==允许在相等比较中进行强制类型转换，而===不允许\"\n\n# 抽象值操作\n(名词解释，后面用到再来看也可以)\n## ToNumber\nES5 规范在 9.3 节定义了\n抽象操作 ToNumber。\n其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。\n## ToString\n定义了抽象操作 ToString，它负责处理非字符串到字符串的强制类型转换。\n基本类型值的字符串化规则为：null 转换为 \"null\"，undefined 转换为 \"undefined\"，true\n转换为 \"true\"。数字的字符串化则遵循通用规则\n## ToPrimitive\n为了将值转换为相应的基本类型值，抽象操作 ToPrimitive（参见 ES5 规范 9.1 节）会首先\n（通过内部操作 DefaultValue，参见 ES5 规范 8.12.8 节）检查该值是否有 valueOf() 方法。\n如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString()\n的返回值（如果存在）来进行强制类型转换。\n如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误\n# 抽象相等\n\n## 1.字符串和数字之间的相等比较\n```js\nvar a = 42；\nvar b = \"42\";\n\na === b //false\na == b //true\n```\n因为没有强制类型的转换，所以a===b为false,42不等于\"42\"\na == b 是宽松相等,如果值得类型不同，则对其中之一或者两者进行强制类型转换。\n具体怎么转环？还要看规范：\nES5规范汇这样定义：\n\n**(1) 如果Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y)的结果。**\n\n**(2) 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果**\n\n## 2.其他类型和布尔类型之间的相等比较\n== 最容易出错的一个地方时true和false与其他类型之间的相等比较。\n```js\nvar a = \"42\";\nvar b = true;\n\na == b // false\n```\n根据以往的经验，\"42\"是一个真值，为什么==的结果不是true呢？原因及简单又复杂，很容易掉坑里，看看规范怎么说：\n\n**(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果 **\n\n**(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果**\n看个例子\n```js\nvar x = true\nvar y = \"42\"\n\nx == y //false\n```\nType(x)是布尔值，所以准换后为1，变为1 == \"42\",两者类型仍然不通，进而\"42\"继续转换为42，最后变为1 == 42，结果是false，\n反过来也一样\n```js\nvar x = '42'\nvar y = false\n\nx == y //false\n```\n一个值既不等于true,也不等于false.太奇怪了吧？\n\n这个问题本身就是错误的，我们被自己的大脑欺骗了。\n\n\"42\" 是一个真值没错，但 \"42\" == true 中并没有发生布尔值的比较和强制类型转换。\n\n这里不是 \"42\" 转换为布尔值（true） ，而是 true 转换为 1，\"42\" 转换为 42。\n\n这里并不涉及 ToBoolean，所以 \"42\" 是真值还是假值与 == 本身没有关系！\n重点是我们要搞清楚 == 对不同的类型组合怎样处理。== 两边的布尔值会被强制类型转换为数字。\n\n很奇怪吧？建议无论什么情况下都不要使用 == true 和 == false。\n请注意，这里说的只是 ==，=== true 和 === false 不允许强制类型转换，所以并不涉及ToNumber。\n```js\nvar a = '42'\n\n// 不要这样用，条件不成立\nif(a == true){\n    //\n}\n\n// 也不要这样\nif(a === true){\n    //\n}\n\n//这样显式用法没有问题\nif(a){\n    //\n}\n\n// 这样的显式更好\nif(!!a){\n    //\n}\n\n```\n避免了 == true 和 == false(也叫作布尔值的宽松相等)之后就不用担心这些坑了\n## 3.null和undefined之间的相等比较\nnull 和 unfined之间的== 也涉及隐式强制类型的转换：\n\n**(1)如果x为null,y为unfined,这结果为true**\n\n**(2)如果x为unfined，y为null,则结果为true**\n\n在==中null和unfined相等(他们也与其自身相等),除此之外其他值不存在这种情况\n```js\nvar a = nul;\nvar b;\n\na == b //true\na == null // true\nb == null //true\n\na == false  //false\nb == false //false\na == ''  //false\nb == ''  //fasle\na == 0  //false\nb == 0 //false\n```\nnull 和 undefined 之间的强制类型转换是安全可靠的，上例中除 null 和 undefined 以外的\n\n其他值均无法得到假阳（false positive）结果。个人认为通过这种方式将 null 和 undefined\n作为等价值来处理比较好。\nex:\n```js\nvar a = doSomething()\n\nif(a == null){\n    //...\n}\n```\n条件判断a ==null仅仅在函数返回null和undefined时才成立，除此之外都不成立\n\n## 4.对象和非对象之间的相等比较\nES5 规范 11.9.3.8-9 做如下规定：\n\n**(1)如果Type(x)是字符串或者数字，Type(y)是对象，则返回x == ToPromitive(y)的结果**\n\n**(2)如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果**\n\n```js\nvar a = 42\nvar b = [42]\na == b //true\n```\n[ 42 ] 首先调用 ToPromitive 抽象操作 ，返回 \"42\"，变成 \"42\" == 42，然后\n又变成 42 == 42，最后二者相等\n\n# 资料\n[JavaScript 中的相等性判断|MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness)\n","slug":"《你不知道的javascript中》JS宽松相等和严格相等","published":1,"updated":"2019-09-25T15:10:25.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91p2003cla2ee2ddres4","content":"<blockquote>\n<p>温故而知新，最近在看《你不知道的javascript》系列的书记，看到深处，总有新的发现，好记性不如烂笔头，遂写下这篇读书笔记</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>宽松相等==和严格相等===都用来判断两个值是否”相等”,但是他们也有一个很重要的区别，尤其是判断条件上<br>常见的误区是”==检查值是否相等，===检查值和类型是否相等”。这样理解似乎有点道理，但是还不够准确，正确的解释是：</p>\n<blockquote>\n<p>“==允许在相等比较中进行强制类型转换，而===不允许”</p>\n</blockquote>\n<h1 id=\"抽象值操作\"><a href=\"#抽象值操作\" class=\"headerlink\" title=\"抽象值操作\"></a>抽象值操作</h1><p>(名词解释，后面用到再来看也可以)</p>\n<h2 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h2><p>ES5 规范在 9.3 节定义了<br>抽象操作 ToNumber。<br>其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p>\n<h2 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString\"></a>ToString</h2><p>定义了抽象操作 ToString，它负责处理非字符串到字符串的强制类型转换。<br>基本类型值的字符串化规则为：null 转换为 “null”，undefined 转换为 “undefined”，true<br>转换为 “true”。数字的字符串化则遵循通用规则</p>\n<h2 id=\"ToPrimitive\"><a href=\"#ToPrimitive\" class=\"headerlink\" title=\"ToPrimitive\"></a>ToPrimitive</h2><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive（参见 ES5 规范 9.1 节）会首先<br>（通过内部操作 DefaultValue，参见 ES5 规范 8.12.8 节）检查该值是否有 valueOf() 方法。<br>如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString()<br>的返回值（如果存在）来进行强制类型转换。<br>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误</p>\n<h1 id=\"抽象相等\"><a href=\"#抽象相等\" class=\"headerlink\" title=\"抽象相等\"></a>抽象相等</h1><h2 id=\"1-字符串和数字之间的相等比较\"><a href=\"#1-字符串和数字之间的相等比较\" class=\"headerlink\" title=\"1.字符串和数字之间的相等比较\"></a>1.字符串和数字之间的相等比较</h2><pre><code class=\"js\">var a = 42；\nvar b = &quot;42&quot;;\n\na === b //false\na == b //true\n</code></pre>\n<p>因为没有强制类型的转换，所以a===b为false,42不等于”42”<br>a == b 是宽松相等,如果值得类型不同，则对其中之一或者两者进行强制类型转换。<br>具体怎么转环？还要看规范：<br>ES5规范汇这样定义：</p>\n<p><strong>(1) 如果Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y)的结果。</strong></p>\n<p><strong>(2) 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果</strong></p>\n<h2 id=\"2-其他类型和布尔类型之间的相等比较\"><a href=\"#2-其他类型和布尔类型之间的相等比较\" class=\"headerlink\" title=\"2.其他类型和布尔类型之间的相等比较\"></a>2.其他类型和布尔类型之间的相等比较</h2><p>== 最容易出错的一个地方时true和false与其他类型之间的相等比较。</p>\n<pre><code class=\"js\">var a = &quot;42&quot;;\nvar b = true;\n\na == b // false\n</code></pre>\n<p>根据以往的经验，”42”是一个真值，为什么==的结果不是true呢？原因及简单又复杂，很容易掉坑里，看看规范怎么说：</p>\n<p><strong>(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果 </strong></p>\n<p><strong>(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果</strong><br>看个例子</p>\n<pre><code class=\"js\">var x = true\nvar y = &quot;42&quot;\n\nx == y //false\n</code></pre>\n<p>Type(x)是布尔值，所以准换后为1，变为1 == “42”,两者类型仍然不通，进而”42”继续转换为42，最后变为1 == 42，结果是false，<br>反过来也一样</p>\n<pre><code class=\"js\">var x = &#39;42&#39;\nvar y = false\n\nx == y //false\n</code></pre>\n<p>一个值既不等于true,也不等于false.太奇怪了吧？</p>\n<p>这个问题本身就是错误的，我们被自己的大脑欺骗了。</p>\n<p>“42” 是一个真值没错，但 “42” == true 中并没有发生布尔值的比较和强制类型转换。</p>\n<p>这里不是 “42” 转换为布尔值（true） ，而是 true 转换为 1，”42” 转换为 42。</p>\n<p>这里并不涉及 ToBoolean，所以 “42” 是真值还是假值与 == 本身没有关系！<br>重点是我们要搞清楚 == 对不同的类型组合怎样处理。== 两边的布尔值会被强制类型转换为数字。</p>\n<p>很奇怪吧？建议无论什么情况下都不要使用 == true 和 == false。<br>请注意，这里说的只是 ==，=== true 和 === false 不允许强制类型转换，所以并不涉及ToNumber。</p>\n<pre><code class=\"js\">var a = &#39;42&#39;\n\n// 不要这样用，条件不成立\nif(a == true){\n    //\n}\n\n// 也不要这样\nif(a === true){\n    //\n}\n\n//这样显式用法没有问题\nif(a){\n    //\n}\n\n// 这样的显式更好\nif(!!a){\n    //\n}\n</code></pre>\n<p>避免了 == true 和 == false(也叫作布尔值的宽松相等)之后就不用担心这些坑了</p>\n<h2 id=\"3-null和undefined之间的相等比较\"><a href=\"#3-null和undefined之间的相等比较\" class=\"headerlink\" title=\"3.null和undefined之间的相等比较\"></a>3.null和undefined之间的相等比较</h2><p>null 和 unfined之间的== 也涉及隐式强制类型的转换：</p>\n<p><strong>(1)如果x为null,y为unfined,这结果为true</strong></p>\n<p><strong>(2)如果x为unfined，y为null,则结果为true</strong></p>\n<p>在==中null和unfined相等(他们也与其自身相等),除此之外其他值不存在这种情况</p>\n<pre><code class=\"js\">var a = nul;\nvar b;\n\na == b //true\na == null // true\nb == null //true\n\na == false  //false\nb == false //false\na == &#39;&#39;  //false\nb == &#39;&#39;  //fasle\na == 0  //false\nb == 0 //false\n</code></pre>\n<p>null 和 undefined 之间的强制类型转换是安全可靠的，上例中除 null 和 undefined 以外的</p>\n<p>其他值均无法得到假阳（false positive）结果。个人认为通过这种方式将 null 和 undefined<br>作为等价值来处理比较好。<br>ex:</p>\n<pre><code class=\"js\">var a = doSomething()\n\nif(a == null){\n    //...\n}\n</code></pre>\n<p>条件判断a ==null仅仅在函数返回null和undefined时才成立，除此之外都不成立</p>\n<h2 id=\"4-对象和非对象之间的相等比较\"><a href=\"#4-对象和非对象之间的相等比较\" class=\"headerlink\" title=\"4.对象和非对象之间的相等比较\"></a>4.对象和非对象之间的相等比较</h2><p>ES5 规范 11.9.3.8-9 做如下规定：</p>\n<p><strong>(1)如果Type(x)是字符串或者数字，Type(y)是对象，则返回x == ToPromitive(y)的结果</strong></p>\n<p><strong>(2)如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果</strong></p>\n<pre><code class=\"js\">var a = 42\nvar b = [42]\na == b //true\n</code></pre>\n<p>[ 42 ] 首先调用 ToPromitive 抽象操作 ，返回 “42”，变成 “42” == 42，然后<br>又变成 42 == 42，最后二者相等</p>\n<h1 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h1><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness\" target=\"_blank\" rel=\"external\">JavaScript 中的相等性判断|MDN</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>温故而知新，最近在看《你不知道的javascript》系列的书记，看到深处，总有新的发现，好记性不如烂笔头，遂写下这篇读书笔记</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>宽松相等==和严格相等===都用来判断两个值是否”相等”,但是他们也有一个很重要的区别，尤其是判断条件上<br>常见的误区是”==检查值是否相等，===检查值和类型是否相等”。这样理解似乎有点道理，但是还不够准确，正确的解释是：</p>\n<blockquote>\n<p>“==允许在相等比较中进行强制类型转换，而===不允许”</p>\n</blockquote>\n<h1 id=\"抽象值操作\"><a href=\"#抽象值操作\" class=\"headerlink\" title=\"抽象值操作\"></a>抽象值操作</h1><p>(名词解释，后面用到再来看也可以)</p>\n<h2 id=\"ToNumber\"><a href=\"#ToNumber\" class=\"headerlink\" title=\"ToNumber\"></a>ToNumber</h2><p>ES5 规范在 9.3 节定义了<br>抽象操作 ToNumber。<br>其中 true 转换为 1，false 转换为 0。undefined 转换为 NaN，null 转换为 0。</p>\n<h2 id=\"ToString\"><a href=\"#ToString\" class=\"headerlink\" title=\"ToString\"></a>ToString</h2><p>定义了抽象操作 ToString，它负责处理非字符串到字符串的强制类型转换。<br>基本类型值的字符串化规则为：null 转换为 “null”，undefined 转换为 “undefined”，true<br>转换为 “true”。数字的字符串化则遵循通用规则</p>\n<h2 id=\"ToPrimitive\"><a href=\"#ToPrimitive\" class=\"headerlink\" title=\"ToPrimitive\"></a>ToPrimitive</h2><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive（参见 ES5 规范 9.1 节）会首先<br>（通过内部操作 DefaultValue，参见 ES5 规范 8.12.8 节）检查该值是否有 valueOf() 方法。<br>如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString()<br>的返回值（如果存在）来进行强制类型转换。<br>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误</p>\n<h1 id=\"抽象相等\"><a href=\"#抽象相等\" class=\"headerlink\" title=\"抽象相等\"></a>抽象相等</h1><h2 id=\"1-字符串和数字之间的相等比较\"><a href=\"#1-字符串和数字之间的相等比较\" class=\"headerlink\" title=\"1.字符串和数字之间的相等比较\"></a>1.字符串和数字之间的相等比较</h2><pre><code class=\"js\">var a = 42；\nvar b = &quot;42&quot;;\n\na === b //false\na == b //true\n</code></pre>\n<p>因为没有强制类型的转换，所以a===b为false,42不等于”42”<br>a == b 是宽松相等,如果值得类型不同，则对其中之一或者两者进行强制类型转换。<br>具体怎么转环？还要看规范：<br>ES5规范汇这样定义：</p>\n<p><strong>(1) 如果Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y)的结果。</strong></p>\n<p><strong>(2) 如果Type(x)是字符串，Type(y)是数字，则返回ToNumber(x) == y的结果</strong></p>\n<h2 id=\"2-其他类型和布尔类型之间的相等比较\"><a href=\"#2-其他类型和布尔类型之间的相等比较\" class=\"headerlink\" title=\"2.其他类型和布尔类型之间的相等比较\"></a>2.其他类型和布尔类型之间的相等比较</h2><p>== 最容易出错的一个地方时true和false与其他类型之间的相等比较。</p>\n<pre><code class=\"js\">var a = &quot;42&quot;;\nvar b = true;\n\na == b // false\n</code></pre>\n<p>根据以往的经验，”42”是一个真值，为什么==的结果不是true呢？原因及简单又复杂，很容易掉坑里，看看规范怎么说：</p>\n<p><strong>(1) 如果Type(x)是布尔类型，则返回ToNumber(x) == y的结果 </strong></p>\n<p><strong>(2) 如果Type(y)是布尔类型，则返回x == ToNumber(y)的结果</strong><br>看个例子</p>\n<pre><code class=\"js\">var x = true\nvar y = &quot;42&quot;\n\nx == y //false\n</code></pre>\n<p>Type(x)是布尔值，所以准换后为1，变为1 == “42”,两者类型仍然不通，进而”42”继续转换为42，最后变为1 == 42，结果是false，<br>反过来也一样</p>\n<pre><code class=\"js\">var x = &#39;42&#39;\nvar y = false\n\nx == y //false\n</code></pre>\n<p>一个值既不等于true,也不等于false.太奇怪了吧？</p>\n<p>这个问题本身就是错误的，我们被自己的大脑欺骗了。</p>\n<p>“42” 是一个真值没错，但 “42” == true 中并没有发生布尔值的比较和强制类型转换。</p>\n<p>这里不是 “42” 转换为布尔值（true） ，而是 true 转换为 1，”42” 转换为 42。</p>\n<p>这里并不涉及 ToBoolean，所以 “42” 是真值还是假值与 == 本身没有关系！<br>重点是我们要搞清楚 == 对不同的类型组合怎样处理。== 两边的布尔值会被强制类型转换为数字。</p>\n<p>很奇怪吧？建议无论什么情况下都不要使用 == true 和 == false。<br>请注意，这里说的只是 ==，=== true 和 === false 不允许强制类型转换，所以并不涉及ToNumber。</p>\n<pre><code class=\"js\">var a = &#39;42&#39;\n\n// 不要这样用，条件不成立\nif(a == true){\n    //\n}\n\n// 也不要这样\nif(a === true){\n    //\n}\n\n//这样显式用法没有问题\nif(a){\n    //\n}\n\n// 这样的显式更好\nif(!!a){\n    //\n}\n</code></pre>\n<p>避免了 == true 和 == false(也叫作布尔值的宽松相等)之后就不用担心这些坑了</p>\n<h2 id=\"3-null和undefined之间的相等比较\"><a href=\"#3-null和undefined之间的相等比较\" class=\"headerlink\" title=\"3.null和undefined之间的相等比较\"></a>3.null和undefined之间的相等比较</h2><p>null 和 unfined之间的== 也涉及隐式强制类型的转换：</p>\n<p><strong>(1)如果x为null,y为unfined,这结果为true</strong></p>\n<p><strong>(2)如果x为unfined，y为null,则结果为true</strong></p>\n<p>在==中null和unfined相等(他们也与其自身相等),除此之外其他值不存在这种情况</p>\n<pre><code class=\"js\">var a = nul;\nvar b;\n\na == b //true\na == null // true\nb == null //true\n\na == false  //false\nb == false //false\na == &#39;&#39;  //false\nb == &#39;&#39;  //fasle\na == 0  //false\nb == 0 //false\n</code></pre>\n<p>null 和 undefined 之间的强制类型转换是安全可靠的，上例中除 null 和 undefined 以外的</p>\n<p>其他值均无法得到假阳（false positive）结果。个人认为通过这种方式将 null 和 undefined<br>作为等价值来处理比较好。<br>ex:</p>\n<pre><code class=\"js\">var a = doSomething()\n\nif(a == null){\n    //...\n}\n</code></pre>\n<p>条件判断a ==null仅仅在函数返回null和undefined时才成立，除此之外都不成立</p>\n<h2 id=\"4-对象和非对象之间的相等比较\"><a href=\"#4-对象和非对象之间的相等比较\" class=\"headerlink\" title=\"4.对象和非对象之间的相等比较\"></a>4.对象和非对象之间的相等比较</h2><p>ES5 规范 11.9.3.8-9 做如下规定：</p>\n<p><strong>(1)如果Type(x)是字符串或者数字，Type(y)是对象，则返回x == ToPromitive(y)的结果</strong></p>\n<p><strong>(2)如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果</strong></p>\n<pre><code class=\"js\">var a = 42\nvar b = [42]\na == b //true\n</code></pre>\n<p>[ 42 ] 首先调用 ToPromitive 抽象操作 ，返回 “42”，变成 “42” == 42，然后<br>又变成 42 == 42，最后二者相等</p>\n<h1 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h1><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness\" target=\"_blank\" rel=\"external\">JavaScript 中的相等性判断|MDN</a></p>\n"},{"title":"编写一个Vue clipboard指令-快速复制文本到剪贴板","date":"2018-06-03T11:20:07.000Z","_content":"> 记录下用vue指令来写一个快速复制内容到剪贴板的插件, 主要是使用了chrome66+提供的新的剪贴方法，clipboard方法\n\n## 项目地址\n[Vue-element-admin, 欢迎start](https://github.com/BiYuqi/vue-element-admin)\n[directive/index.js](https://github.com/BiYuqi/vue-element-admin/blob/master/src/directive/clipboard/index.js)\n[项目预览,图标模块使用](http://loadingmore.com/vue-element-admin-preview/)\n## directive部分\n由于项目使用的element-ui库，所以提示信息组件，我就直接应用了，如有需要或者去除，请自行修改\n```js\nimport { Message } from 'element-ui'\n\nconst Clipboard = {}\n\n// 创建一个全局文本框 针对非chrome浏览器，以及chrome浏览器版本小于66的兼容方法\nconst input = document.createElement('input')\ninput.id = 'byq-clipboard'\ninput.type = 'text'\ninput.style.position = 'absolute'\ninput.style.left = '-9999px'\ndocument.body.appendChild(input)\n\nconst copyTarget = document.querySelector('#byq-clipboard')\n// 浏览器以及相关验证\nconst UA = window.navigator.userAgent.toLowerCase()\nconst isEdge = UA && UA.indexOf('edge/') > 0\nconst isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge\n// 确认是chrome浏览器，且版本符合要求\nconst isSupportChromeVersion = (v) => {\n  return isChrome && ~~UA.match(/chrome\\/(\\d+)/)[1] >= v\n}\nClipboard.install = (Vue, options) => {\n  Vue.directive('clipboard', {\n    bind (el, binding) {\n      // 注册事件\n      el.addEventListener('click', () => {\n        const value = binding.value\n        // 必须传值\n        if (!value) {\n          Message.error('请输入要复制问的文本')\n        }\n        // chrome version 66+ support\n        if (isSupportChromeVersion(66) && window.navigator.clipboard) {\n          window.navigator.clipboard.writeText(value).then(() => {\n            Message.success('复制成功啦, 赶快使用吧')\n          }).catch((error) => {\n            Message.error(error)\n          })\n        } else {\n          copyTarget.value = value\n          copyTarget.select()\n          document.execCommand('Copy')\n          Message.success('复制成功啦, 赶快使用吧')\n        }\n      })\n    }\n  })\n}\n\nexport default Clipboard\n\n```\n\n## 全局注册使用\n** 引入注册组件 **\n```js\n// main.js 项目入口文件\nimport Clipboard from '@/directive/clipboard/index'\nVue.use(Clipboard)\n```\n** 页面使用 **\n```html\n<!-- 只需要传入v-clipboard  带上参数就可以了-->\n<div class=\"test\" v-clipboard=\"我是一个前端开发者\">\n  我是一个前端开发者\n</div>\n```\n\n## navigator.clipboard 是个什么鬼？\n这是一个实验中的功能，Clipboard接口提供了一种读写操作系统剪贴板的方式。\n* read()\n从剪贴板读取数据（比如图片）。\n* readText()\n从操作系统读取文本。\n* write()\n写入数据（比如图片）至操作系统剪贴板。\n* writeText()\n写入文本至操作系统剪贴板。\n\n## 资料\n[Clipboard|MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard)\n","source":"_posts/【Vue版】实用js快速复制文本内容.md","raw":"---\ntitle: 编写一个Vue clipboard指令-快速复制文本到剪贴板\ndate: 2018-06-03 19:20:07\ntags: [Vue, '组件', '指令', 'directive']\ncategories: Javascript\n---\n> 记录下用vue指令来写一个快速复制内容到剪贴板的插件, 主要是使用了chrome66+提供的新的剪贴方法，clipboard方法\n\n## 项目地址\n[Vue-element-admin, 欢迎start](https://github.com/BiYuqi/vue-element-admin)\n[directive/index.js](https://github.com/BiYuqi/vue-element-admin/blob/master/src/directive/clipboard/index.js)\n[项目预览,图标模块使用](http://loadingmore.com/vue-element-admin-preview/)\n## directive部分\n由于项目使用的element-ui库，所以提示信息组件，我就直接应用了，如有需要或者去除，请自行修改\n```js\nimport { Message } from 'element-ui'\n\nconst Clipboard = {}\n\n// 创建一个全局文本框 针对非chrome浏览器，以及chrome浏览器版本小于66的兼容方法\nconst input = document.createElement('input')\ninput.id = 'byq-clipboard'\ninput.type = 'text'\ninput.style.position = 'absolute'\ninput.style.left = '-9999px'\ndocument.body.appendChild(input)\n\nconst copyTarget = document.querySelector('#byq-clipboard')\n// 浏览器以及相关验证\nconst UA = window.navigator.userAgent.toLowerCase()\nconst isEdge = UA && UA.indexOf('edge/') > 0\nconst isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge\n// 确认是chrome浏览器，且版本符合要求\nconst isSupportChromeVersion = (v) => {\n  return isChrome && ~~UA.match(/chrome\\/(\\d+)/)[1] >= v\n}\nClipboard.install = (Vue, options) => {\n  Vue.directive('clipboard', {\n    bind (el, binding) {\n      // 注册事件\n      el.addEventListener('click', () => {\n        const value = binding.value\n        // 必须传值\n        if (!value) {\n          Message.error('请输入要复制问的文本')\n        }\n        // chrome version 66+ support\n        if (isSupportChromeVersion(66) && window.navigator.clipboard) {\n          window.navigator.clipboard.writeText(value).then(() => {\n            Message.success('复制成功啦, 赶快使用吧')\n          }).catch((error) => {\n            Message.error(error)\n          })\n        } else {\n          copyTarget.value = value\n          copyTarget.select()\n          document.execCommand('Copy')\n          Message.success('复制成功啦, 赶快使用吧')\n        }\n      })\n    }\n  })\n}\n\nexport default Clipboard\n\n```\n\n## 全局注册使用\n** 引入注册组件 **\n```js\n// main.js 项目入口文件\nimport Clipboard from '@/directive/clipboard/index'\nVue.use(Clipboard)\n```\n** 页面使用 **\n```html\n<!-- 只需要传入v-clipboard  带上参数就可以了-->\n<div class=\"test\" v-clipboard=\"我是一个前端开发者\">\n  我是一个前端开发者\n</div>\n```\n\n## navigator.clipboard 是个什么鬼？\n这是一个实验中的功能，Clipboard接口提供了一种读写操作系统剪贴板的方式。\n* read()\n从剪贴板读取数据（比如图片）。\n* readText()\n从操作系统读取文本。\n* write()\n写入数据（比如图片）至操作系统剪贴板。\n* writeText()\n写入文本至操作系统剪贴板。\n\n## 资料\n[Clipboard|MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard)\n","slug":"【Vue版】实用js快速复制文本内容","published":1,"updated":"2019-09-25T15:10:25.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91p3003ela2e8bceqx3h","content":"<blockquote>\n<p>记录下用vue指令来写一个快速复制内容到剪贴板的插件, 主要是使用了chrome66+提供的新的剪贴方法，clipboard方法</p>\n</blockquote>\n<h2 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h2><p><a href=\"https://github.com/BiYuqi/vue-element-admin\" target=\"_blank\" rel=\"external\">Vue-element-admin, 欢迎start</a><br><a href=\"https://github.com/BiYuqi/vue-element-admin/blob/master/src/directive/clipboard/index.js\" target=\"_blank\" rel=\"external\">directive/index.js</a><br><a href=\"http://loadingmore.com/vue-element-admin-preview/\">项目预览,图标模块使用</a></p>\n<h2 id=\"directive部分\"><a href=\"#directive部分\" class=\"headerlink\" title=\"directive部分\"></a>directive部分</h2><p>由于项目使用的element-ui库，所以提示信息组件，我就直接应用了，如有需要或者去除，请自行修改</p>\n<pre><code class=\"js\">import { Message } from &#39;element-ui&#39;\n\nconst Clipboard = {}\n\n// 创建一个全局文本框 针对非chrome浏览器，以及chrome浏览器版本小于66的兼容方法\nconst input = document.createElement(&#39;input&#39;)\ninput.id = &#39;byq-clipboard&#39;\ninput.type = &#39;text&#39;\ninput.style.position = &#39;absolute&#39;\ninput.style.left = &#39;-9999px&#39;\ndocument.body.appendChild(input)\n\nconst copyTarget = document.querySelector(&#39;#byq-clipboard&#39;)\n// 浏览器以及相关验证\nconst UA = window.navigator.userAgent.toLowerCase()\nconst isEdge = UA &amp;&amp; UA.indexOf(&#39;edge/&#39;) &gt; 0\nconst isChrome = UA &amp;&amp; /chrome\\/\\d+/.test(UA) &amp;&amp; !isEdge\n// 确认是chrome浏览器，且版本符合要求\nconst isSupportChromeVersion = (v) =&gt; {\n  return isChrome &amp;&amp; ~~UA.match(/chrome\\/(\\d+)/)[1] &gt;= v\n}\nClipboard.install = (Vue, options) =&gt; {\n  Vue.directive(&#39;clipboard&#39;, {\n    bind (el, binding) {\n      // 注册事件\n      el.addEventListener(&#39;click&#39;, () =&gt; {\n        const value = binding.value\n        // 必须传值\n        if (!value) {\n          Message.error(&#39;请输入要复制问的文本&#39;)\n        }\n        // chrome version 66+ support\n        if (isSupportChromeVersion(66) &amp;&amp; window.navigator.clipboard) {\n          window.navigator.clipboard.writeText(value).then(() =&gt; {\n            Message.success(&#39;复制成功啦, 赶快使用吧&#39;)\n          }).catch((error) =&gt; {\n            Message.error(error)\n          })\n        } else {\n          copyTarget.value = value\n          copyTarget.select()\n          document.execCommand(&#39;Copy&#39;)\n          Message.success(&#39;复制成功啦, 赶快使用吧&#39;)\n        }\n      })\n    }\n  })\n}\n\nexport default Clipboard\n</code></pre>\n<h2 id=\"全局注册使用\"><a href=\"#全局注册使用\" class=\"headerlink\" title=\"全局注册使用\"></a>全局注册使用</h2><p><strong> 引入注册组件 </strong></p>\n<pre><code class=\"js\">// main.js 项目入口文件\nimport Clipboard from &#39;@/directive/clipboard/index&#39;\nVue.use(Clipboard)\n</code></pre>\n<p><strong> 页面使用 </strong></p>\n<pre><code class=\"html\">&lt;!-- 只需要传入v-clipboard  带上参数就可以了--&gt;\n&lt;div class=&quot;test&quot; v-clipboard=&quot;我是一个前端开发者&quot;&gt;\n  我是一个前端开发者\n&lt;/div&gt;\n</code></pre>\n<h2 id=\"navigator-clipboard-是个什么鬼？\"><a href=\"#navigator-clipboard-是个什么鬼？\" class=\"headerlink\" title=\"navigator.clipboard 是个什么鬼？\"></a>navigator.clipboard 是个什么鬼？</h2><p>这是一个实验中的功能，Clipboard接口提供了一种读写操作系统剪贴板的方式。</p>\n<ul>\n<li>read()<br>从剪贴板读取数据（比如图片）。</li>\n<li>readText()<br>从操作系统读取文本。</li>\n<li>write()<br>写入数据（比如图片）至操作系统剪贴板。</li>\n<li>writeText()<br>写入文本至操作系统剪贴板。</li>\n</ul>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard\" target=\"_blank\" rel=\"external\">Clipboard|MDN</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录下用vue指令来写一个快速复制内容到剪贴板的插件, 主要是使用了chrome66+提供的新的剪贴方法，clipboard方法</p>\n</blockquote>\n<h2 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h2><p><a href=\"https://github.com/BiYuqi/vue-element-admin\" target=\"_blank\" rel=\"external\">Vue-element-admin, 欢迎start</a><br><a href=\"https://github.com/BiYuqi/vue-element-admin/blob/master/src/directive/clipboard/index.js\" target=\"_blank\" rel=\"external\">directive/index.js</a><br><a href=\"http://loadingmore.com/vue-element-admin-preview/\">项目预览,图标模块使用</a></p>\n<h2 id=\"directive部分\"><a href=\"#directive部分\" class=\"headerlink\" title=\"directive部分\"></a>directive部分</h2><p>由于项目使用的element-ui库，所以提示信息组件，我就直接应用了，如有需要或者去除，请自行修改</p>\n<pre><code class=\"js\">import { Message } from &#39;element-ui&#39;\n\nconst Clipboard = {}\n\n// 创建一个全局文本框 针对非chrome浏览器，以及chrome浏览器版本小于66的兼容方法\nconst input = document.createElement(&#39;input&#39;)\ninput.id = &#39;byq-clipboard&#39;\ninput.type = &#39;text&#39;\ninput.style.position = &#39;absolute&#39;\ninput.style.left = &#39;-9999px&#39;\ndocument.body.appendChild(input)\n\nconst copyTarget = document.querySelector(&#39;#byq-clipboard&#39;)\n// 浏览器以及相关验证\nconst UA = window.navigator.userAgent.toLowerCase()\nconst isEdge = UA &amp;&amp; UA.indexOf(&#39;edge/&#39;) &gt; 0\nconst isChrome = UA &amp;&amp; /chrome\\/\\d+/.test(UA) &amp;&amp; !isEdge\n// 确认是chrome浏览器，且版本符合要求\nconst isSupportChromeVersion = (v) =&gt; {\n  return isChrome &amp;&amp; ~~UA.match(/chrome\\/(\\d+)/)[1] &gt;= v\n}\nClipboard.install = (Vue, options) =&gt; {\n  Vue.directive(&#39;clipboard&#39;, {\n    bind (el, binding) {\n      // 注册事件\n      el.addEventListener(&#39;click&#39;, () =&gt; {\n        const value = binding.value\n        // 必须传值\n        if (!value) {\n          Message.error(&#39;请输入要复制问的文本&#39;)\n        }\n        // chrome version 66+ support\n        if (isSupportChromeVersion(66) &amp;&amp; window.navigator.clipboard) {\n          window.navigator.clipboard.writeText(value).then(() =&gt; {\n            Message.success(&#39;复制成功啦, 赶快使用吧&#39;)\n          }).catch((error) =&gt; {\n            Message.error(error)\n          })\n        } else {\n          copyTarget.value = value\n          copyTarget.select()\n          document.execCommand(&#39;Copy&#39;)\n          Message.success(&#39;复制成功啦, 赶快使用吧&#39;)\n        }\n      })\n    }\n  })\n}\n\nexport default Clipboard\n</code></pre>\n<h2 id=\"全局注册使用\"><a href=\"#全局注册使用\" class=\"headerlink\" title=\"全局注册使用\"></a>全局注册使用</h2><p><strong> 引入注册组件 </strong></p>\n<pre><code class=\"js\">// main.js 项目入口文件\nimport Clipboard from &#39;@/directive/clipboard/index&#39;\nVue.use(Clipboard)\n</code></pre>\n<p><strong> 页面使用 </strong></p>\n<pre><code class=\"html\">&lt;!-- 只需要传入v-clipboard  带上参数就可以了--&gt;\n&lt;div class=&quot;test&quot; v-clipboard=&quot;我是一个前端开发者&quot;&gt;\n  我是一个前端开发者\n&lt;/div&gt;\n</code></pre>\n<h2 id=\"navigator-clipboard-是个什么鬼？\"><a href=\"#navigator-clipboard-是个什么鬼？\" class=\"headerlink\" title=\"navigator.clipboard 是个什么鬼？\"></a>navigator.clipboard 是个什么鬼？</h2><p>这是一个实验中的功能，Clipboard接口提供了一种读写操作系统剪贴板的方式。</p>\n<ul>\n<li>read()<br>从剪贴板读取数据（比如图片）。</li>\n<li>readText()<br>从操作系统读取文本。</li>\n<li>write()<br>写入数据（比如图片）至操作系统剪贴板。</li>\n<li>writeText()<br>写入文本至操作系统剪贴板。</li>\n</ul>\n<h2 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard\" target=\"_blank\" rel=\"external\">Clipboard|MDN</a></p>\n"},{"title":"【正则表达式系列】入门篇","date":"2017-11-26T07:50:30.000Z","_content":"> 开始之前，我希望你能放下心中的恐惧感！\n\n## 前言\n\n对于一个刚接触正则的人来说，会让人觉得那么神秘，闻而生畏。\n\n正则想要精通更是不易，需要大量反复的练习，接触正则也不少时间了，不知怎么的，我就自己走过了那段畏惧正则的时期，日常的中遇到的问题基本上都能解决\n\n由于笔者是从事于前端开发的，所以本文中的正则都是基于Javascript的语法规则也讲述，不过不同语言之间的正则基本是相通的，只是语法表示上有点区别，我计划总结下我的一下学习的经历和心得：\n\n** [【正则表达式系列】入门篇]() **\n\n** [【正则表达式系列】贪婪与非贪婪模式](http://loadingmore.com/2017/12/28/【正则表达式系列】贪婪与非贪婪模式/) **\n\n** 【正则表达式系列】零宽断言篇(待写) **\n\n## 正文\n正则字符，很多文章都会讲到，篇幅原因我就不多说，我只列举常用的：\n## 元字符\n\n元字符 | 描述\n--------|--------\n<code>.</code>|匹配除换行符以外的任意字符\n<code>\\d</code>|匹配数字, 等价于字符组[0-9]\n<code>\\w</code>|匹配字母, 数字, 下划线\n<code>\\s</code>|匹配任意的空白符(包括制表符,空格,换行等)\n<code>\\b</code>|匹配单词开始或结束的位置\n<code>^</code>|匹配行首\n<code>$</code>|匹配行尾\n\n## 反义元字符\n元字符 | 描述\n--------|--------\n<code>\\D</code>|匹配非数字的任意字符, 等价于[^0-9]\n<code>\\W</code>|匹配除字母,数字,下划线之外的任意字符\n<code>\\S</code>|匹配非空白的任意字符\n<code>\\B</code>|匹配非单词开始或结束的位置\n<code>[^x]</code>|匹配除x以外的任意字符\n## 重复限定符\n限定符 | 描述\n--------|--------\n<code>\\*</code>|x>=0\n<code>+</code>|x>=1\n<code>?</code>|x=0 or x=1\n<code>{n}</code>|x=n\n<code>{n,}</code>|x>=n\n<code>{n,m}</code>|n<=x<=m\n## 修饰符\njavaScript中正则表达式默认有如下五种修饰符:\n* g (全文查找), 如上述截图, 实际上就开启了全文查找模式.\n* i (忽略大小写查找)\n* m (多行查找)\n* y (ES6新增的粘连修饰符)\n* u (ES6新增)\n\n## 常用几个字符解释\n### 1. <code>.</code>匹配不包括换行的任意字符\n\n如果需要匹配包括换行的任意字符，可以使用<code>[\\s\\S]</code>来代替.\n\n### 2. <code>\\s</code>空格、tab、换行\n<code>[\\s\\S]</code>表示匹配任意字符，<code>\\S</code>是<code>\\s</code>的反义。注意区分<code>[\\s\\S]</code>与<code>.</code>的区别。\n\n### 3. <code>\\*</code>匹配零个或更多个，即0~n\n\n### 4. <code>+</code>匹配一个或更多个，即至少一个，1~n\n\n### 5. <code>\\</code> 转义\n一个特殊字符前加<code>\\</code>就表示转义，说明把它当普通字符用\n\n### 6. <code>[]</code>单字符取一个，比如<code>[abc]</code>会匹配a或b或c\n如果<code>[]</code>里面加上<code>^</code>则会变成排除这个字符,比如<code>[^abc]</code>就是既不包含a,也不包含b,也不包含c\n在<code>[]</code>里可以使用-来表示一个范围，<code>[0-9]</code>表示从0到9，<code>[a-zA-Z]</code>包含26个字母，如果要包含-则要加上转义字符<code>[\\\\-]</code>\n<code>[]</code>常见的错误用法是：<code>[ab|bc]</code>用来表示ab或bc，实际上，它得到的结果是[abc|]，即匹配的是a或b或c或|这4个字符（单字符）的任意一个。这里可以改成<code>(ab|bc)</code>。\n** 总结：[]里面的特殊符有五个：<code>[]-\\^</code>，其他字符都是普通字符，包括*.?等。**\n* <code>^</code>在<code>[^</code> 的首位时候才有特殊意义\n* <code>[0-9</code> <code>-</code>在不是首尾的时候有特殊意义\n* <code>\\\\</code>本身是转义符，有特殊意义\n\n### 7. <code>^</code> 字符串开始\n注意区分，不在[]里面的是开始符，在里面的是排除\neg: <code>^http</code> vs <code>[^abs]</code>\n\n### 8. <code>?</code> 有两个用法\n* 匹配一个或零个\neg: <code>https?</code>匹配https（一个s）或者http（零个s）\n* 非贪婪模式\n所谓非贪婪模式，就是匹配尽可能少的内容，比如，对于源字符串\n\n\n```html\n<div>a</div><div>b</div>\n```\n使用<code>&lt;div&gt;(.\\*?)&lt;/div&gt;</code>会得到2个结果（注意：如果源字符串有换行，使用[\\s\\S]替换 .\n\n```html\n<div>a</div>\n```\n和\n```html\n<div>a</div>\n```\n因为，当遇到第一个&lt;/div&gt;，非贪婪模式就不会再往后找了。\n而使用<code>&lt;div&gt;(.\\*)&lt;/div&gt;</code>（贪婪模式）则会得到整个字符串,因为它会匹配所有字符直到后面再找不到</div>\n```html\n<div>a</div><div>b</div>\n```\n### 9. <code>a{1,}</code> 字符a出现1次或者更多次\n### 10. <code>a?</code> 字符a出现0次或者1次，等价于{0,1}\n### 11. <code>(ab){0,1}</code> 字符ab出现0次或者1次，也就是说ab一起匹配\n### 12. <code>(a│bc|d)e</code> 可以是ae或者是bce或者是de\n### 13. <code>|</code> 多个数据选一（常用于多字符）\n前面提到[]里面的字符有选一个字符功能，但是假如不是一个字符，比如：http|git|svn 就需要用|分开，|的作用域是一直往后直到遇到括号，比如，对于源字符串\n匹配：\n* http abc  \n* git abc  \n* svn abc\n\n就可以直接使用<code>(http|git|svn)abc</code>来进行匹配\n### 14. <code>()</code> 数据分界和取数据\n<code>(http|git|svn)abc</code>就是一个分界的例子，匹配结果会得到一个数组集合,其中[1]也就是数组的下标1得到的是一个数组集合，这就是模式匹配，也叫分组，子模式计数是从左至右\n<code>(https?):\\/\\/([^\\/]+)</code> 就是一个匹配网址的正则，其中分组2得到的是网址主地址;\n```js\n/(https?):\\/\\/([^\\/]+)/.exec('http://loadingmore.com')[2] // loadingmore.com\n```\n[点击这里查看匹配情况](https://regex101.com/r/LT6iPK/1)\n### 15. <code>(?:)</code>非捕获组\n上面提到的()作为子模式可以得到里面的数据，但是有些时候我们只是把它作为分界，不需要取数据，这个时候就需要用到非捕获概念了。比如上面匹配网址需要在分组2才能得到loadingmore.com，分组1是http；这个时候我们只需要后面的网址，就可以用非捕获来实现<code>(?:https?):\\/\\/([^\\/]+)</code>\n\n```js\n/(?:https?):\\/\\/([^\\/]+)/.exec('http://loadingmore.com')[1] //loadingmore.com\n```\n[点击这里查看匹配情况](https://regex101.com/r/LT6iPK/2)\n\n### 16. 模式修饰符\n模式修饰符很多语言都支持，js中常用的比如i不区分大小写，g全部匹配，m是多行匹配\n```js\nconst reg = /a-z/i // 可以匹配26字母 不区分大小写\nconst reg2 = /http/g // httphttphttp可以匹配三个http，没有g修饰，只能匹配第一个\n```\n# 简单操作练习\n\n## 定位\n下面就一段html进行剖析\n目标：得到 target1中inner内容 哈哈1\n```html\n<div class=\"target1\">\n    <div class=\"inner\">\n        哈哈1\n    </div>\n</div>\n<div class=\"target2\">\n    <div class=\"inner\">\n        哈哈2\n    </div>\n</div>\n```\n写正则之前，首先要观察要匹配的数据结构，找出异同点，精准定位到你想要数据的位置，必须你需要一个页面的title的内容，那么title就是你的正则的关键字，所要取的数据确实无法定位一个唯一的锚点，那就可以采用分段取数据，缩小范围后，再对这个数据进行二次分解\n比如上面的html片段，加入直接采用:\n```js\n// 很明显会得到两个inner数据段\nconst reg = /<div\\s+class=\"inner\">([\\s\\S]+?)<\\/div>/\n```\n[点击查看详情](https://regex101.com/r/LT6iPK/3)\n这个时候我们就可以考虑以class=\"target1\"作为定位点进行匹配\n```js\nconst reg2 = /<div class=\"target1\">\\s+<div class=\"inner\">([\\S\\s]+?)<\\/div>\\s+<\\/div>/\n```\n[点击查看详情](https://regex101.com/r/LT6iPK/5)\n\ntips：采用<code>[\\s\\S]+</code>原因是html结构有换行；<code>.</code>不符合要求，<code>.</code>匹配不包括换行的任意字符，<code>[\\s\\S]+?</code>加？号的原因是非贪婪模式，否则会一致直匹配到不能匹配为止，本文只需要第一个，所以采用非贪婪模式匹配。下文会讲到贪婪与非贪婪模式\n\n** 总结：所谓匹配数据，就是找到能唯一定位你数据的标识的锚点 **\n\n## 去噪音\n所谓去掉噪音，就是把哪些无关紧要的，迷惑你的数据果断抛弃掉，一眼抓住你想要的那个字符即可，比如：\n```html\n<a data-v-1b4073f4=\"\" href=\"https://github.com/icepy/Front-End-Develop-Guide#fed_point_recommend\" target=\"_blank\">前端开发指南</a>\n```\n找出上个连接中的href链接，当然了，这用js的dom元素获取轻而易举，本文只是为了做示范，阐述一种正则思维\n```js\n// 首先要定位 <a href= 还有链接后面的 ” 其他的都不用关注\ncosnt str = `<a data-v-1b4073f4=\"\" href=\"http://loadingmore.com\" target=\"_blank\"></a>`\nconst reg = /<a[^>]*?href=\"([^\"]+)\"/\nconst result = reg.exec(str)[1]\n\n// console.log(result)\n```\n[点击查看详情](https://regex101.com/r/LT6iPK/6)\n** 总结：关心的留下，不关心的都是浮云 **\n\n## 取数据\n关于取数据一般都用到分组捕获上文有提及\n\n## 最后的话\n学习正则，一定要多练习，狠下心来，过一遍正则基础，收获绝对满满，一边下来，不知不觉就掌握了大部分，当然了想要精通，爱需要深入的学习和大量练习，持之以恒方得成效\n\n## 附录\n[正则表达式30分钟入门教程](http://help.locoy.com/Document/Learn_Regex_For_30_Minutes.htm)\n[1小时教你学会正则表达式](http://www.cnblogs.com/beyoung/archive/2007/08/02/840139.html)\n","source":"_posts/【正则表达式系列】入门篇.md","raw":"---\ntitle: 【正则表达式系列】入门篇\ndate: 2017-11-26 15:50:30\ntags: [javascript,RegExp,\"正则\"]\ncategories: Javascript\n---\n> 开始之前，我希望你能放下心中的恐惧感！\n\n## 前言\n\n对于一个刚接触正则的人来说，会让人觉得那么神秘，闻而生畏。\n\n正则想要精通更是不易，需要大量反复的练习，接触正则也不少时间了，不知怎么的，我就自己走过了那段畏惧正则的时期，日常的中遇到的问题基本上都能解决\n\n由于笔者是从事于前端开发的，所以本文中的正则都是基于Javascript的语法规则也讲述，不过不同语言之间的正则基本是相通的，只是语法表示上有点区别，我计划总结下我的一下学习的经历和心得：\n\n** [【正则表达式系列】入门篇]() **\n\n** [【正则表达式系列】贪婪与非贪婪模式](http://loadingmore.com/2017/12/28/【正则表达式系列】贪婪与非贪婪模式/) **\n\n** 【正则表达式系列】零宽断言篇(待写) **\n\n## 正文\n正则字符，很多文章都会讲到，篇幅原因我就不多说，我只列举常用的：\n## 元字符\n\n元字符 | 描述\n--------|--------\n<code>.</code>|匹配除换行符以外的任意字符\n<code>\\d</code>|匹配数字, 等价于字符组[0-9]\n<code>\\w</code>|匹配字母, 数字, 下划线\n<code>\\s</code>|匹配任意的空白符(包括制表符,空格,换行等)\n<code>\\b</code>|匹配单词开始或结束的位置\n<code>^</code>|匹配行首\n<code>$</code>|匹配行尾\n\n## 反义元字符\n元字符 | 描述\n--------|--------\n<code>\\D</code>|匹配非数字的任意字符, 等价于[^0-9]\n<code>\\W</code>|匹配除字母,数字,下划线之外的任意字符\n<code>\\S</code>|匹配非空白的任意字符\n<code>\\B</code>|匹配非单词开始或结束的位置\n<code>[^x]</code>|匹配除x以外的任意字符\n## 重复限定符\n限定符 | 描述\n--------|--------\n<code>\\*</code>|x>=0\n<code>+</code>|x>=1\n<code>?</code>|x=0 or x=1\n<code>{n}</code>|x=n\n<code>{n,}</code>|x>=n\n<code>{n,m}</code>|n<=x<=m\n## 修饰符\njavaScript中正则表达式默认有如下五种修饰符:\n* g (全文查找), 如上述截图, 实际上就开启了全文查找模式.\n* i (忽略大小写查找)\n* m (多行查找)\n* y (ES6新增的粘连修饰符)\n* u (ES6新增)\n\n## 常用几个字符解释\n### 1. <code>.</code>匹配不包括换行的任意字符\n\n如果需要匹配包括换行的任意字符，可以使用<code>[\\s\\S]</code>来代替.\n\n### 2. <code>\\s</code>空格、tab、换行\n<code>[\\s\\S]</code>表示匹配任意字符，<code>\\S</code>是<code>\\s</code>的反义。注意区分<code>[\\s\\S]</code>与<code>.</code>的区别。\n\n### 3. <code>\\*</code>匹配零个或更多个，即0~n\n\n### 4. <code>+</code>匹配一个或更多个，即至少一个，1~n\n\n### 5. <code>\\</code> 转义\n一个特殊字符前加<code>\\</code>就表示转义，说明把它当普通字符用\n\n### 6. <code>[]</code>单字符取一个，比如<code>[abc]</code>会匹配a或b或c\n如果<code>[]</code>里面加上<code>^</code>则会变成排除这个字符,比如<code>[^abc]</code>就是既不包含a,也不包含b,也不包含c\n在<code>[]</code>里可以使用-来表示一个范围，<code>[0-9]</code>表示从0到9，<code>[a-zA-Z]</code>包含26个字母，如果要包含-则要加上转义字符<code>[\\\\-]</code>\n<code>[]</code>常见的错误用法是：<code>[ab|bc]</code>用来表示ab或bc，实际上，它得到的结果是[abc|]，即匹配的是a或b或c或|这4个字符（单字符）的任意一个。这里可以改成<code>(ab|bc)</code>。\n** 总结：[]里面的特殊符有五个：<code>[]-\\^</code>，其他字符都是普通字符，包括*.?等。**\n* <code>^</code>在<code>[^</code> 的首位时候才有特殊意义\n* <code>[0-9</code> <code>-</code>在不是首尾的时候有特殊意义\n* <code>\\\\</code>本身是转义符，有特殊意义\n\n### 7. <code>^</code> 字符串开始\n注意区分，不在[]里面的是开始符，在里面的是排除\neg: <code>^http</code> vs <code>[^abs]</code>\n\n### 8. <code>?</code> 有两个用法\n* 匹配一个或零个\neg: <code>https?</code>匹配https（一个s）或者http（零个s）\n* 非贪婪模式\n所谓非贪婪模式，就是匹配尽可能少的内容，比如，对于源字符串\n\n\n```html\n<div>a</div><div>b</div>\n```\n使用<code>&lt;div&gt;(.\\*?)&lt;/div&gt;</code>会得到2个结果（注意：如果源字符串有换行，使用[\\s\\S]替换 .\n\n```html\n<div>a</div>\n```\n和\n```html\n<div>a</div>\n```\n因为，当遇到第一个&lt;/div&gt;，非贪婪模式就不会再往后找了。\n而使用<code>&lt;div&gt;(.\\*)&lt;/div&gt;</code>（贪婪模式）则会得到整个字符串,因为它会匹配所有字符直到后面再找不到</div>\n```html\n<div>a</div><div>b</div>\n```\n### 9. <code>a{1,}</code> 字符a出现1次或者更多次\n### 10. <code>a?</code> 字符a出现0次或者1次，等价于{0,1}\n### 11. <code>(ab){0,1}</code> 字符ab出现0次或者1次，也就是说ab一起匹配\n### 12. <code>(a│bc|d)e</code> 可以是ae或者是bce或者是de\n### 13. <code>|</code> 多个数据选一（常用于多字符）\n前面提到[]里面的字符有选一个字符功能，但是假如不是一个字符，比如：http|git|svn 就需要用|分开，|的作用域是一直往后直到遇到括号，比如，对于源字符串\n匹配：\n* http abc  \n* git abc  \n* svn abc\n\n就可以直接使用<code>(http|git|svn)abc</code>来进行匹配\n### 14. <code>()</code> 数据分界和取数据\n<code>(http|git|svn)abc</code>就是一个分界的例子，匹配结果会得到一个数组集合,其中[1]也就是数组的下标1得到的是一个数组集合，这就是模式匹配，也叫分组，子模式计数是从左至右\n<code>(https?):\\/\\/([^\\/]+)</code> 就是一个匹配网址的正则，其中分组2得到的是网址主地址;\n```js\n/(https?):\\/\\/([^\\/]+)/.exec('http://loadingmore.com')[2] // loadingmore.com\n```\n[点击这里查看匹配情况](https://regex101.com/r/LT6iPK/1)\n### 15. <code>(?:)</code>非捕获组\n上面提到的()作为子模式可以得到里面的数据，但是有些时候我们只是把它作为分界，不需要取数据，这个时候就需要用到非捕获概念了。比如上面匹配网址需要在分组2才能得到loadingmore.com，分组1是http；这个时候我们只需要后面的网址，就可以用非捕获来实现<code>(?:https?):\\/\\/([^\\/]+)</code>\n\n```js\n/(?:https?):\\/\\/([^\\/]+)/.exec('http://loadingmore.com')[1] //loadingmore.com\n```\n[点击这里查看匹配情况](https://regex101.com/r/LT6iPK/2)\n\n### 16. 模式修饰符\n模式修饰符很多语言都支持，js中常用的比如i不区分大小写，g全部匹配，m是多行匹配\n```js\nconst reg = /a-z/i // 可以匹配26字母 不区分大小写\nconst reg2 = /http/g // httphttphttp可以匹配三个http，没有g修饰，只能匹配第一个\n```\n# 简单操作练习\n\n## 定位\n下面就一段html进行剖析\n目标：得到 target1中inner内容 哈哈1\n```html\n<div class=\"target1\">\n    <div class=\"inner\">\n        哈哈1\n    </div>\n</div>\n<div class=\"target2\">\n    <div class=\"inner\">\n        哈哈2\n    </div>\n</div>\n```\n写正则之前，首先要观察要匹配的数据结构，找出异同点，精准定位到你想要数据的位置，必须你需要一个页面的title的内容，那么title就是你的正则的关键字，所要取的数据确实无法定位一个唯一的锚点，那就可以采用分段取数据，缩小范围后，再对这个数据进行二次分解\n比如上面的html片段，加入直接采用:\n```js\n// 很明显会得到两个inner数据段\nconst reg = /<div\\s+class=\"inner\">([\\s\\S]+?)<\\/div>/\n```\n[点击查看详情](https://regex101.com/r/LT6iPK/3)\n这个时候我们就可以考虑以class=\"target1\"作为定位点进行匹配\n```js\nconst reg2 = /<div class=\"target1\">\\s+<div class=\"inner\">([\\S\\s]+?)<\\/div>\\s+<\\/div>/\n```\n[点击查看详情](https://regex101.com/r/LT6iPK/5)\n\ntips：采用<code>[\\s\\S]+</code>原因是html结构有换行；<code>.</code>不符合要求，<code>.</code>匹配不包括换行的任意字符，<code>[\\s\\S]+?</code>加？号的原因是非贪婪模式，否则会一致直匹配到不能匹配为止，本文只需要第一个，所以采用非贪婪模式匹配。下文会讲到贪婪与非贪婪模式\n\n** 总结：所谓匹配数据，就是找到能唯一定位你数据的标识的锚点 **\n\n## 去噪音\n所谓去掉噪音，就是把哪些无关紧要的，迷惑你的数据果断抛弃掉，一眼抓住你想要的那个字符即可，比如：\n```html\n<a data-v-1b4073f4=\"\" href=\"https://github.com/icepy/Front-End-Develop-Guide#fed_point_recommend\" target=\"_blank\">前端开发指南</a>\n```\n找出上个连接中的href链接，当然了，这用js的dom元素获取轻而易举，本文只是为了做示范，阐述一种正则思维\n```js\n// 首先要定位 <a href= 还有链接后面的 ” 其他的都不用关注\ncosnt str = `<a data-v-1b4073f4=\"\" href=\"http://loadingmore.com\" target=\"_blank\"></a>`\nconst reg = /<a[^>]*?href=\"([^\"]+)\"/\nconst result = reg.exec(str)[1]\n\n// console.log(result)\n```\n[点击查看详情](https://regex101.com/r/LT6iPK/6)\n** 总结：关心的留下，不关心的都是浮云 **\n\n## 取数据\n关于取数据一般都用到分组捕获上文有提及\n\n## 最后的话\n学习正则，一定要多练习，狠下心来，过一遍正则基础，收获绝对满满，一边下来，不知不觉就掌握了大部分，当然了想要精通，爱需要深入的学习和大量练习，持之以恒方得成效\n\n## 附录\n[正则表达式30分钟入门教程](http://help.locoy.com/Document/Learn_Regex_For_30_Minutes.htm)\n[1小时教你学会正则表达式](http://www.cnblogs.com/beyoung/archive/2007/08/02/840139.html)\n","slug":"【正则表达式系列】入门篇","published":1,"updated":"2019-09-25T15:10:25.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91p4003ila2enz6tdmhk","content":"<blockquote>\n<p>开始之前，我希望你能放下心中的恐惧感！</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于一个刚接触正则的人来说，会让人觉得那么神秘，闻而生畏。</p>\n<p>正则想要精通更是不易，需要大量反复的练习，接触正则也不少时间了，不知怎么的，我就自己走过了那段畏惧正则的时期，日常的中遇到的问题基本上都能解决</p>\n<p>由于笔者是从事于前端开发的，所以本文中的正则都是基于Javascript的语法规则也讲述，不过不同语言之间的正则基本是相通的，只是语法表示上有点区别，我计划总结下我的一下学习的经历和心得：</p>\n<p><strong> <a href=\"\">【正则表达式系列】入门篇</a> </strong></p>\n<p><strong> <a href=\"http://loadingmore.com/2017/12/28/【正则表达式系列】贪婪与非贪婪模式/\">【正则表达式系列】贪婪与非贪婪模式</a> </strong></p>\n<p><strong> 【正则表达式系列】零宽断言篇(待写) </strong></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>正则字符，很多文章都会讲到，篇幅原因我就不多说，我只列举常用的：</p>\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.</code></td>\n<td>匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td><code>\\d</code></td>\n<td>匹配数字, 等价于字符组[0-9]</td>\n</tr>\n<tr>\n<td><code>\\w</code></td>\n<td>匹配字母, 数字, 下划线</td>\n</tr>\n<tr>\n<td><code>\\s</code></td>\n<td>匹配任意的空白符(包括制表符,空格,换行等)</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>匹配单词开始或结束的位置</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>匹配行首</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>匹配行尾</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"反义元字符\"><a href=\"#反义元字符\" class=\"headerlink\" title=\"反义元字符\"></a>反义元字符</h2><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\D</code></td>\n<td>匹配非数字的任意字符, 等价于[^0-9]</td>\n</tr>\n<tr>\n<td><code>\\W</code></td>\n<td>匹配除字母,数字,下划线之外的任意字符</td>\n</tr>\n<tr>\n<td><code>\\S</code></td>\n<td>匹配非空白的任意字符</td>\n</tr>\n<tr>\n<td><code>\\B</code></td>\n<td>匹配非单词开始或结束的位置</td>\n</tr>\n<tr>\n<td><code>[^x]</code></td>\n<td>匹配除x以外的任意字符</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"重复限定符\"><a href=\"#重复限定符\" class=\"headerlink\" title=\"重复限定符\"></a>重复限定符</h2><table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>*</code></td>\n<td>x&gt;=0</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>x&gt;=1</td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td>x=0 or x=1</td>\n</tr>\n<tr>\n<td><code>{n}</code></td>\n<td>x=n</td>\n</tr>\n<tr>\n<td><code>{n,}</code></td>\n<td>x&gt;=n</td>\n</tr>\n<tr>\n<td><code>{n,m}</code></td>\n<td>n&lt;=x&lt;=m</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>javaScript中正则表达式默认有如下五种修饰符:</p>\n<ul>\n<li>g (全文查找), 如上述截图, 实际上就开启了全文查找模式.</li>\n<li>i (忽略大小写查找)</li>\n<li>m (多行查找)</li>\n<li>y (ES6新增的粘连修饰符)</li>\n<li>u (ES6新增)</li>\n</ul>\n<h2 id=\"常用几个字符解释\"><a href=\"#常用几个字符解释\" class=\"headerlink\" title=\"常用几个字符解释\"></a>常用几个字符解释</h2><h3 id=\"1-匹配不包括换行的任意字符\"><a href=\"#1-匹配不包括换行的任意字符\" class=\"headerlink\" title=\"1. .匹配不包括换行的任意字符\"></a>1. <code>.</code>匹配不包括换行的任意字符</h3><p>如果需要匹配包括换行的任意字符，可以使用<code>[\\s\\S]</code>来代替.</p>\n<h3 id=\"2-s空格、tab、换行\"><a href=\"#2-s空格、tab、换行\" class=\"headerlink\" title=\"2. \\s空格、tab、换行\"></a>2. <code>\\s</code>空格、tab、换行</h3><p><code>[\\s\\S]</code>表示匹配任意字符，<code>\\S</code>是<code>\\s</code>的反义。注意区分<code>[\\s\\S]</code>与<code>.</code>的区别。</p>\n<h3 id=\"3-匹配零个或更多个，即0-n\"><a href=\"#3-匹配零个或更多个，即0-n\" class=\"headerlink\" title=\"3. *匹配零个或更多个，即0~n\"></a>3. <code>*</code>匹配零个或更多个，即0~n</h3><h3 id=\"4-匹配一个或更多个，即至少一个，1-n\"><a href=\"#4-匹配一个或更多个，即至少一个，1-n\" class=\"headerlink\" title=\"4. +匹配一个或更多个，即至少一个，1~n\"></a>4. <code>+</code>匹配一个或更多个，即至少一个，1~n</h3><h3 id=\"5-转义\"><a href=\"#5-转义\" class=\"headerlink\" title=\"5. \\ 转义\"></a>5. <code>\\</code> 转义</h3><p>一个特殊字符前加<code>\\</code>就表示转义，说明把它当普通字符用</p>\n<h3 id=\"6-单字符取一个，比如-abc-会匹配a或b或c\"><a href=\"#6-单字符取一个，比如-abc-会匹配a或b或c\" class=\"headerlink\" title=\"6. []单字符取一个，比如[abc]会匹配a或b或c\"></a>6. <code>[]</code>单字符取一个，比如<code>[abc]</code>会匹配a或b或c</h3><p>如果<code>[]</code>里面加上<code>^</code>则会变成排除这个字符,比如<code>[^abc]</code>就是既不包含a,也不包含b,也不包含c<br>在<code>[]</code>里可以使用-来表示一个范围，<code>[0-9]</code>表示从0到9，<code>[a-zA-Z]</code>包含26个字母，如果要包含-则要加上转义字符<code>[\\-]</code><br><code>[]</code>常见的错误用法是：<code>[ab|bc]</code>用来表示ab或bc，实际上，它得到的结果是[abc|]，即匹配的是a或b或c或|这4个字符（单字符）的任意一个。这里可以改成<code>(ab|bc)</code>。<br><strong> 总结：[]里面的特殊符有五个：<code>[]-\\^</code>，其他字符都是普通字符，包括*.?等。</strong></p>\n<ul>\n<li><code>^</code>在<code>[^</code> 的首位时候才有特殊意义</li>\n<li><code>[0-9</code> <code>-</code>在不是首尾的时候有特殊意义</li>\n<li><code>\\</code>本身是转义符，有特殊意义</li>\n</ul>\n<h3 id=\"7-字符串开始\"><a href=\"#7-字符串开始\" class=\"headerlink\" title=\"7. ^ 字符串开始\"></a>7. <code>^</code> 字符串开始</h3><p>注意区分，不在[]里面的是开始符，在里面的是排除<br>eg: <code>^http</code> vs <code>[^abs]</code></p>\n<h3 id=\"8-有两个用法\"><a href=\"#8-有两个用法\" class=\"headerlink\" title=\"8. ? 有两个用法\"></a>8. <code>?</code> 有两个用法</h3><ul>\n<li>匹配一个或零个<br>eg: <code>https?</code>匹配https（一个s）或者http（零个s）</li>\n<li>非贪婪模式<br>所谓非贪婪模式，就是匹配尽可能少的内容，比如，对于源字符串</li>\n</ul>\n<pre><code class=\"html\">&lt;div&gt;a&lt;/div&gt;&lt;div&gt;b&lt;/div&gt;\n</code></pre>\n<p>使用<code>&lt;div&gt;(.*?)&lt;/div&gt;</code>会得到2个结果（注意：如果源字符串有换行，使用[\\s\\S]替换 .</p>\n<pre><code class=\"html\">&lt;div&gt;a&lt;/div&gt;\n</code></pre>\n<p>和</p>\n<pre><code class=\"html\">&lt;div&gt;a&lt;/div&gt;\n</code></pre>\n<p>因为，当遇到第一个&lt;/div&gt;，非贪婪模式就不会再往后找了。<br>而使用<code>&lt;div&gt;(.*)&lt;/div&gt;</code>（贪婪模式）则会得到整个字符串,因为它会匹配所有字符直到后面再找不到</p>\n<pre><code class=\"html\">&lt;div&gt;a&lt;/div&gt;&lt;div&gt;b&lt;/div&gt;\n</code></pre>\n<h3 id=\"9-a-1-字符a出现1次或者更多次\"><a href=\"#9-a-1-字符a出现1次或者更多次\" class=\"headerlink\" title=\"9. a{1,} 字符a出现1次或者更多次\"></a>9. <code>a{1,}</code> 字符a出现1次或者更多次</h3><h3 id=\"10-a-字符a出现0次或者1次，等价于-0-1\"><a href=\"#10-a-字符a出现0次或者1次，等价于-0-1\" class=\"headerlink\" title=\"10. a? 字符a出现0次或者1次，等价于{0,1}\"></a>10. <code>a?</code> 字符a出现0次或者1次，等价于{0,1}</h3><h3 id=\"11-ab-0-1-字符ab出现0次或者1次，也就是说ab一起匹配\"><a href=\"#11-ab-0-1-字符ab出现0次或者1次，也就是说ab一起匹配\" class=\"headerlink\" title=\"11. (ab){0,1} 字符ab出现0次或者1次，也就是说ab一起匹配\"></a>11. <code>(ab){0,1}</code> 字符ab出现0次或者1次，也就是说ab一起匹配</h3><h3 id=\"12-a│bc-d-e-可以是ae或者是bce或者是de\"><a href=\"#12-a│bc-d-e-可以是ae或者是bce或者是de\" class=\"headerlink\" title=\"12. (a│bc|d)e 可以是ae或者是bce或者是de\"></a>12. <code>(a│bc|d)e</code> 可以是ae或者是bce或者是de</h3><h3 id=\"13-多个数据选一（常用于多字符）\"><a href=\"#13-多个数据选一（常用于多字符）\" class=\"headerlink\" title=\"13. | 多个数据选一（常用于多字符）\"></a>13. <code>|</code> 多个数据选一（常用于多字符）</h3><p>前面提到[]里面的字符有选一个字符功能，但是假如不是一个字符，比如：http|git|svn 就需要用|分开，|的作用域是一直往后直到遇到括号，比如，对于源字符串<br>匹配：</p>\n<ul>\n<li>http abc  </li>\n<li>git abc  </li>\n<li>svn abc</li>\n</ul>\n<p>就可以直接使用<code>(http|git|svn)abc</code>来进行匹配</p>\n<h3 id=\"14-数据分界和取数据\"><a href=\"#14-数据分界和取数据\" class=\"headerlink\" title=\"14. () 数据分界和取数据\"></a>14. <code>()</code> 数据分界和取数据</h3><p><code>(http|git|svn)abc</code>就是一个分界的例子，匹配结果会得到一个数组集合,其中[1]也就是数组的下标1得到的是一个数组集合，这就是模式匹配，也叫分组，子模式计数是从左至右<br><code>(https?):\\/\\/([^\\/]+)</code> 就是一个匹配网址的正则，其中分组2得到的是网址主地址;</p>\n<pre><code class=\"js\">/(https?):\\/\\/([^\\/]+)/.exec(&#39;http://loadingmore.com&#39;)[2] // loadingmore.com\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/1\" target=\"_blank\" rel=\"external\">点击这里查看匹配情况</a></p>\n<h3 id=\"15-非捕获组\"><a href=\"#15-非捕获组\" class=\"headerlink\" title=\"15. (?:)非捕获组\"></a>15. <code>(?:)</code>非捕获组</h3><p>上面提到的()作为子模式可以得到里面的数据，但是有些时候我们只是把它作为分界，不需要取数据，这个时候就需要用到非捕获概念了。比如上面匹配网址需要在分组2才能得到loadingmore.com，分组1是http；这个时候我们只需要后面的网址，就可以用非捕获来实现<code>(?:https?):\\/\\/([^\\/]+)</code></p>\n<pre><code class=\"js\">/(?:https?):\\/\\/([^\\/]+)/.exec(&#39;http://loadingmore.com&#39;)[1] //loadingmore.com\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/2\" target=\"_blank\" rel=\"external\">点击这里查看匹配情况</a></p>\n<h3 id=\"16-模式修饰符\"><a href=\"#16-模式修饰符\" class=\"headerlink\" title=\"16. 模式修饰符\"></a>16. 模式修饰符</h3><p>模式修饰符很多语言都支持，js中常用的比如i不区分大小写，g全部匹配，m是多行匹配</p>\n<pre><code class=\"js\">const reg = /a-z/i // 可以匹配26字母 不区分大小写\nconst reg2 = /http/g // httphttphttp可以匹配三个http，没有g修饰，只能匹配第一个\n</code></pre>\n<h1 id=\"简单操作练习\"><a href=\"#简单操作练习\" class=\"headerlink\" title=\"简单操作练习\"></a>简单操作练习</h1><h2 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h2><p>下面就一段html进行剖析<br>目标：得到 target1中inner内容 哈哈1</p>\n<pre><code class=\"html\">&lt;div class=&quot;target1&quot;&gt;\n    &lt;div class=&quot;inner&quot;&gt;\n        哈哈1\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=&quot;target2&quot;&gt;\n    &lt;div class=&quot;inner&quot;&gt;\n        哈哈2\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>写正则之前，首先要观察要匹配的数据结构，找出异同点，精准定位到你想要数据的位置，必须你需要一个页面的title的内容，那么title就是你的正则的关键字，所要取的数据确实无法定位一个唯一的锚点，那就可以采用分段取数据，缩小范围后，再对这个数据进行二次分解<br>比如上面的html片段，加入直接采用:</p>\n<pre><code class=\"js\">// 很明显会得到两个inner数据段\nconst reg = /&lt;div\\s+class=&quot;inner&quot;&gt;([\\s\\S]+?)&lt;\\/div&gt;/\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/3\" target=\"_blank\" rel=\"external\">点击查看详情</a><br>这个时候我们就可以考虑以class=”target1”作为定位点进行匹配</p>\n<pre><code class=\"js\">const reg2 = /&lt;div class=&quot;target1&quot;&gt;\\s+&lt;div class=&quot;inner&quot;&gt;([\\S\\s]+?)&lt;\\/div&gt;\\s+&lt;\\/div&gt;/\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/5\" target=\"_blank\" rel=\"external\">点击查看详情</a></p>\n<p>tips：采用<code>[\\s\\S]+</code>原因是html结构有换行；<code>.</code>不符合要求，<code>.</code>匹配不包括换行的任意字符，<code>[\\s\\S]+?</code>加？号的原因是非贪婪模式，否则会一致直匹配到不能匹配为止，本文只需要第一个，所以采用非贪婪模式匹配。下文会讲到贪婪与非贪婪模式</p>\n<p><strong> 总结：所谓匹配数据，就是找到能唯一定位你数据的标识的锚点 </strong></p>\n<h2 id=\"去噪音\"><a href=\"#去噪音\" class=\"headerlink\" title=\"去噪音\"></a>去噪音</h2><p>所谓去掉噪音，就是把哪些无关紧要的，迷惑你的数据果断抛弃掉，一眼抓住你想要的那个字符即可，比如：</p>\n<pre><code class=\"html\">&lt;a data-v-1b4073f4=&quot;&quot; href=&quot;https://github.com/icepy/Front-End-Develop-Guide#fed_point_recommend&quot; target=&quot;_blank&quot;&gt;前端开发指南&lt;/a&gt;\n</code></pre>\n<p>找出上个连接中的href链接，当然了，这用js的dom元素获取轻而易举，本文只是为了做示范，阐述一种正则思维</p>\n<pre><code class=\"js\">// 首先要定位 &lt;a href= 还有链接后面的 ” 其他的都不用关注\ncosnt str = `&lt;a data-v-1b4073f4=&quot;&quot; href=&quot;http://loadingmore.com&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;`\nconst reg = /&lt;a[^&gt;]*?href=&quot;([^&quot;]+)&quot;/\nconst result = reg.exec(str)[1]\n\n// console.log(result)\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/6\" target=\"_blank\" rel=\"external\">点击查看详情</a><br><strong> 总结：关心的留下，不关心的都是浮云 </strong></p>\n<h2 id=\"取数据\"><a href=\"#取数据\" class=\"headerlink\" title=\"取数据\"></a>取数据</h2><p>关于取数据一般都用到分组捕获上文有提及</p>\n<h2 id=\"最后的话\"><a href=\"#最后的话\" class=\"headerlink\" title=\"最后的话\"></a>最后的话</h2><p>学习正则，一定要多练习，狠下心来，过一遍正则基础，收获绝对满满，一边下来，不知不觉就掌握了大部分，当然了想要精通，爱需要深入的学习和大量练习，持之以恒方得成效</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><a href=\"http://help.locoy.com/Document/Learn_Regex_For_30_Minutes.htm\" target=\"_blank\" rel=\"external\">正则表达式30分钟入门教程</a><br><a href=\"http://www.cnblogs.com/beyoung/archive/2007/08/02/840139.html\" target=\"_blank\" rel=\"external\">1小时教你学会正则表达式</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>开始之前，我希望你能放下心中的恐惧感！</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于一个刚接触正则的人来说，会让人觉得那么神秘，闻而生畏。</p>\n<p>正则想要精通更是不易，需要大量反复的练习，接触正则也不少时间了，不知怎么的，我就自己走过了那段畏惧正则的时期，日常的中遇到的问题基本上都能解决</p>\n<p>由于笔者是从事于前端开发的，所以本文中的正则都是基于Javascript的语法规则也讲述，不过不同语言之间的正则基本是相通的，只是语法表示上有点区别，我计划总结下我的一下学习的经历和心得：</p>\n<p><strong> <a href=\"\">【正则表达式系列】入门篇</a> </strong></p>\n<p><strong> <a href=\"http://loadingmore.com/2017/12/28/【正则表达式系列】贪婪与非贪婪模式/\">【正则表达式系列】贪婪与非贪婪模式</a> </strong></p>\n<p><strong> 【正则表达式系列】零宽断言篇(待写) </strong></p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>正则字符，很多文章都会讲到，篇幅原因我就不多说，我只列举常用的：</p>\n<h2 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h2><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.</code></td>\n<td>匹配除换行符以外的任意字符</td>\n</tr>\n<tr>\n<td><code>\\d</code></td>\n<td>匹配数字, 等价于字符组[0-9]</td>\n</tr>\n<tr>\n<td><code>\\w</code></td>\n<td>匹配字母, 数字, 下划线</td>\n</tr>\n<tr>\n<td><code>\\s</code></td>\n<td>匹配任意的空白符(包括制表符,空格,换行等)</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>匹配单词开始或结束的位置</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>匹配行首</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>匹配行尾</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"反义元字符\"><a href=\"#反义元字符\" class=\"headerlink\" title=\"反义元字符\"></a>反义元字符</h2><table>\n<thead>\n<tr>\n<th>元字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\D</code></td>\n<td>匹配非数字的任意字符, 等价于[^0-9]</td>\n</tr>\n<tr>\n<td><code>\\W</code></td>\n<td>匹配除字母,数字,下划线之外的任意字符</td>\n</tr>\n<tr>\n<td><code>\\S</code></td>\n<td>匹配非空白的任意字符</td>\n</tr>\n<tr>\n<td><code>\\B</code></td>\n<td>匹配非单词开始或结束的位置</td>\n</tr>\n<tr>\n<td><code>[^x]</code></td>\n<td>匹配除x以外的任意字符</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"重复限定符\"><a href=\"#重复限定符\" class=\"headerlink\" title=\"重复限定符\"></a>重复限定符</h2><table>\n<thead>\n<tr>\n<th>限定符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>*</code></td>\n<td>x&gt;=0</td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td>x&gt;=1</td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td>x=0 or x=1</td>\n</tr>\n<tr>\n<td><code>{n}</code></td>\n<td>x=n</td>\n</tr>\n<tr>\n<td><code>{n,}</code></td>\n<td>x&gt;=n</td>\n</tr>\n<tr>\n<td><code>{n,m}</code></td>\n<td>n&lt;=x&lt;=m</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h2><p>javaScript中正则表达式默认有如下五种修饰符:</p>\n<ul>\n<li>g (全文查找), 如上述截图, 实际上就开启了全文查找模式.</li>\n<li>i (忽略大小写查找)</li>\n<li>m (多行查找)</li>\n<li>y (ES6新增的粘连修饰符)</li>\n<li>u (ES6新增)</li>\n</ul>\n<h2 id=\"常用几个字符解释\"><a href=\"#常用几个字符解释\" class=\"headerlink\" title=\"常用几个字符解释\"></a>常用几个字符解释</h2><h3 id=\"1-匹配不包括换行的任意字符\"><a href=\"#1-匹配不包括换行的任意字符\" class=\"headerlink\" title=\"1. .匹配不包括换行的任意字符\"></a>1. <code>.</code>匹配不包括换行的任意字符</h3><p>如果需要匹配包括换行的任意字符，可以使用<code>[\\s\\S]</code>来代替.</p>\n<h3 id=\"2-s空格、tab、换行\"><a href=\"#2-s空格、tab、换行\" class=\"headerlink\" title=\"2. \\s空格、tab、换行\"></a>2. <code>\\s</code>空格、tab、换行</h3><p><code>[\\s\\S]</code>表示匹配任意字符，<code>\\S</code>是<code>\\s</code>的反义。注意区分<code>[\\s\\S]</code>与<code>.</code>的区别。</p>\n<h3 id=\"3-匹配零个或更多个，即0-n\"><a href=\"#3-匹配零个或更多个，即0-n\" class=\"headerlink\" title=\"3. *匹配零个或更多个，即0~n\"></a>3. <code>*</code>匹配零个或更多个，即0~n</h3><h3 id=\"4-匹配一个或更多个，即至少一个，1-n\"><a href=\"#4-匹配一个或更多个，即至少一个，1-n\" class=\"headerlink\" title=\"4. +匹配一个或更多个，即至少一个，1~n\"></a>4. <code>+</code>匹配一个或更多个，即至少一个，1~n</h3><h3 id=\"5-转义\"><a href=\"#5-转义\" class=\"headerlink\" title=\"5. \\ 转义\"></a>5. <code>\\</code> 转义</h3><p>一个特殊字符前加<code>\\</code>就表示转义，说明把它当普通字符用</p>\n<h3 id=\"6-单字符取一个，比如-abc-会匹配a或b或c\"><a href=\"#6-单字符取一个，比如-abc-会匹配a或b或c\" class=\"headerlink\" title=\"6. []单字符取一个，比如[abc]会匹配a或b或c\"></a>6. <code>[]</code>单字符取一个，比如<code>[abc]</code>会匹配a或b或c</h3><p>如果<code>[]</code>里面加上<code>^</code>则会变成排除这个字符,比如<code>[^abc]</code>就是既不包含a,也不包含b,也不包含c<br>在<code>[]</code>里可以使用-来表示一个范围，<code>[0-9]</code>表示从0到9，<code>[a-zA-Z]</code>包含26个字母，如果要包含-则要加上转义字符<code>[\\-]</code><br><code>[]</code>常见的错误用法是：<code>[ab|bc]</code>用来表示ab或bc，实际上，它得到的结果是[abc|]，即匹配的是a或b或c或|这4个字符（单字符）的任意一个。这里可以改成<code>(ab|bc)</code>。<br><strong> 总结：[]里面的特殊符有五个：<code>[]-\\^</code>，其他字符都是普通字符，包括*.?等。</strong></p>\n<ul>\n<li><code>^</code>在<code>[^</code> 的首位时候才有特殊意义</li>\n<li><code>[0-9</code> <code>-</code>在不是首尾的时候有特殊意义</li>\n<li><code>\\</code>本身是转义符，有特殊意义</li>\n</ul>\n<h3 id=\"7-字符串开始\"><a href=\"#7-字符串开始\" class=\"headerlink\" title=\"7. ^ 字符串开始\"></a>7. <code>^</code> 字符串开始</h3><p>注意区分，不在[]里面的是开始符，在里面的是排除<br>eg: <code>^http</code> vs <code>[^abs]</code></p>\n<h3 id=\"8-有两个用法\"><a href=\"#8-有两个用法\" class=\"headerlink\" title=\"8. ? 有两个用法\"></a>8. <code>?</code> 有两个用法</h3><ul>\n<li>匹配一个或零个<br>eg: <code>https?</code>匹配https（一个s）或者http（零个s）</li>\n<li>非贪婪模式<br>所谓非贪婪模式，就是匹配尽可能少的内容，比如，对于源字符串</li>\n</ul>\n<pre><code class=\"html\">&lt;div&gt;a&lt;/div&gt;&lt;div&gt;b&lt;/div&gt;\n</code></pre>\n<p>使用<code>&lt;div&gt;(.*?)&lt;/div&gt;</code>会得到2个结果（注意：如果源字符串有换行，使用[\\s\\S]替换 .</p>\n<pre><code class=\"html\">&lt;div&gt;a&lt;/div&gt;\n</code></pre>\n<p>和</p>\n<pre><code class=\"html\">&lt;div&gt;a&lt;/div&gt;\n</code></pre>\n<p>因为，当遇到第一个&lt;/div&gt;，非贪婪模式就不会再往后找了。<br>而使用<code>&lt;div&gt;(.*)&lt;/div&gt;</code>（贪婪模式）则会得到整个字符串,因为它会匹配所有字符直到后面再找不到</p>\n<pre><code class=\"html\">&lt;div&gt;a&lt;/div&gt;&lt;div&gt;b&lt;/div&gt;\n</code></pre>\n<h3 id=\"9-a-1-字符a出现1次或者更多次\"><a href=\"#9-a-1-字符a出现1次或者更多次\" class=\"headerlink\" title=\"9. a{1,} 字符a出现1次或者更多次\"></a>9. <code>a{1,}</code> 字符a出现1次或者更多次</h3><h3 id=\"10-a-字符a出现0次或者1次，等价于-0-1\"><a href=\"#10-a-字符a出现0次或者1次，等价于-0-1\" class=\"headerlink\" title=\"10. a? 字符a出现0次或者1次，等价于{0,1}\"></a>10. <code>a?</code> 字符a出现0次或者1次，等价于{0,1}</h3><h3 id=\"11-ab-0-1-字符ab出现0次或者1次，也就是说ab一起匹配\"><a href=\"#11-ab-0-1-字符ab出现0次或者1次，也就是说ab一起匹配\" class=\"headerlink\" title=\"11. (ab){0,1} 字符ab出现0次或者1次，也就是说ab一起匹配\"></a>11. <code>(ab){0,1}</code> 字符ab出现0次或者1次，也就是说ab一起匹配</h3><h3 id=\"12-a│bc-d-e-可以是ae或者是bce或者是de\"><a href=\"#12-a│bc-d-e-可以是ae或者是bce或者是de\" class=\"headerlink\" title=\"12. (a│bc|d)e 可以是ae或者是bce或者是de\"></a>12. <code>(a│bc|d)e</code> 可以是ae或者是bce或者是de</h3><h3 id=\"13-多个数据选一（常用于多字符）\"><a href=\"#13-多个数据选一（常用于多字符）\" class=\"headerlink\" title=\"13. | 多个数据选一（常用于多字符）\"></a>13. <code>|</code> 多个数据选一（常用于多字符）</h3><p>前面提到[]里面的字符有选一个字符功能，但是假如不是一个字符，比如：http|git|svn 就需要用|分开，|的作用域是一直往后直到遇到括号，比如，对于源字符串<br>匹配：</p>\n<ul>\n<li>http abc  </li>\n<li>git abc  </li>\n<li>svn abc</li>\n</ul>\n<p>就可以直接使用<code>(http|git|svn)abc</code>来进行匹配</p>\n<h3 id=\"14-数据分界和取数据\"><a href=\"#14-数据分界和取数据\" class=\"headerlink\" title=\"14. () 数据分界和取数据\"></a>14. <code>()</code> 数据分界和取数据</h3><p><code>(http|git|svn)abc</code>就是一个分界的例子，匹配结果会得到一个数组集合,其中[1]也就是数组的下标1得到的是一个数组集合，这就是模式匹配，也叫分组，子模式计数是从左至右<br><code>(https?):\\/\\/([^\\/]+)</code> 就是一个匹配网址的正则，其中分组2得到的是网址主地址;</p>\n<pre><code class=\"js\">/(https?):\\/\\/([^\\/]+)/.exec(&#39;http://loadingmore.com&#39;)[2] // loadingmore.com\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/1\" target=\"_blank\" rel=\"external\">点击这里查看匹配情况</a></p>\n<h3 id=\"15-非捕获组\"><a href=\"#15-非捕获组\" class=\"headerlink\" title=\"15. (?:)非捕获组\"></a>15. <code>(?:)</code>非捕获组</h3><p>上面提到的()作为子模式可以得到里面的数据，但是有些时候我们只是把它作为分界，不需要取数据，这个时候就需要用到非捕获概念了。比如上面匹配网址需要在分组2才能得到loadingmore.com，分组1是http；这个时候我们只需要后面的网址，就可以用非捕获来实现<code>(?:https?):\\/\\/([^\\/]+)</code></p>\n<pre><code class=\"js\">/(?:https?):\\/\\/([^\\/]+)/.exec(&#39;http://loadingmore.com&#39;)[1] //loadingmore.com\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/2\" target=\"_blank\" rel=\"external\">点击这里查看匹配情况</a></p>\n<h3 id=\"16-模式修饰符\"><a href=\"#16-模式修饰符\" class=\"headerlink\" title=\"16. 模式修饰符\"></a>16. 模式修饰符</h3><p>模式修饰符很多语言都支持，js中常用的比如i不区分大小写，g全部匹配，m是多行匹配</p>\n<pre><code class=\"js\">const reg = /a-z/i // 可以匹配26字母 不区分大小写\nconst reg2 = /http/g // httphttphttp可以匹配三个http，没有g修饰，只能匹配第一个\n</code></pre>\n<h1 id=\"简单操作练习\"><a href=\"#简单操作练习\" class=\"headerlink\" title=\"简单操作练习\"></a>简单操作练习</h1><h2 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h2><p>下面就一段html进行剖析<br>目标：得到 target1中inner内容 哈哈1</p>\n<pre><code class=\"html\">&lt;div class=&quot;target1&quot;&gt;\n    &lt;div class=&quot;inner&quot;&gt;\n        哈哈1\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=&quot;target2&quot;&gt;\n    &lt;div class=&quot;inner&quot;&gt;\n        哈哈2\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>写正则之前，首先要观察要匹配的数据结构，找出异同点，精准定位到你想要数据的位置，必须你需要一个页面的title的内容，那么title就是你的正则的关键字，所要取的数据确实无法定位一个唯一的锚点，那就可以采用分段取数据，缩小范围后，再对这个数据进行二次分解<br>比如上面的html片段，加入直接采用:</p>\n<pre><code class=\"js\">// 很明显会得到两个inner数据段\nconst reg = /&lt;div\\s+class=&quot;inner&quot;&gt;([\\s\\S]+?)&lt;\\/div&gt;/\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/3\" target=\"_blank\" rel=\"external\">点击查看详情</a><br>这个时候我们就可以考虑以class=”target1”作为定位点进行匹配</p>\n<pre><code class=\"js\">const reg2 = /&lt;div class=&quot;target1&quot;&gt;\\s+&lt;div class=&quot;inner&quot;&gt;([\\S\\s]+?)&lt;\\/div&gt;\\s+&lt;\\/div&gt;/\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/5\" target=\"_blank\" rel=\"external\">点击查看详情</a></p>\n<p>tips：采用<code>[\\s\\S]+</code>原因是html结构有换行；<code>.</code>不符合要求，<code>.</code>匹配不包括换行的任意字符，<code>[\\s\\S]+?</code>加？号的原因是非贪婪模式，否则会一致直匹配到不能匹配为止，本文只需要第一个，所以采用非贪婪模式匹配。下文会讲到贪婪与非贪婪模式</p>\n<p><strong> 总结：所谓匹配数据，就是找到能唯一定位你数据的标识的锚点 </strong></p>\n<h2 id=\"去噪音\"><a href=\"#去噪音\" class=\"headerlink\" title=\"去噪音\"></a>去噪音</h2><p>所谓去掉噪音，就是把哪些无关紧要的，迷惑你的数据果断抛弃掉，一眼抓住你想要的那个字符即可，比如：</p>\n<pre><code class=\"html\">&lt;a data-v-1b4073f4=&quot;&quot; href=&quot;https://github.com/icepy/Front-End-Develop-Guide#fed_point_recommend&quot; target=&quot;_blank&quot;&gt;前端开发指南&lt;/a&gt;\n</code></pre>\n<p>找出上个连接中的href链接，当然了，这用js的dom元素获取轻而易举，本文只是为了做示范，阐述一种正则思维</p>\n<pre><code class=\"js\">// 首先要定位 &lt;a href= 还有链接后面的 ” 其他的都不用关注\ncosnt str = `&lt;a data-v-1b4073f4=&quot;&quot; href=&quot;http://loadingmore.com&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;`\nconst reg = /&lt;a[^&gt;]*?href=&quot;([^&quot;]+)&quot;/\nconst result = reg.exec(str)[1]\n\n// console.log(result)\n</code></pre>\n<p><a href=\"https://regex101.com/r/LT6iPK/6\" target=\"_blank\" rel=\"external\">点击查看详情</a><br><strong> 总结：关心的留下，不关心的都是浮云 </strong></p>\n<h2 id=\"取数据\"><a href=\"#取数据\" class=\"headerlink\" title=\"取数据\"></a>取数据</h2><p>关于取数据一般都用到分组捕获上文有提及</p>\n<h2 id=\"最后的话\"><a href=\"#最后的话\" class=\"headerlink\" title=\"最后的话\"></a>最后的话</h2><p>学习正则，一定要多练习，狠下心来，过一遍正则基础，收获绝对满满，一边下来，不知不觉就掌握了大部分，当然了想要精通，爱需要深入的学习和大量练习，持之以恒方得成效</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><a href=\"http://help.locoy.com/Document/Learn_Regex_For_30_Minutes.htm\" target=\"_blank\" rel=\"external\">正则表达式30分钟入门教程</a><br><a href=\"http://www.cnblogs.com/beyoung/archive/2007/08/02/840139.html\" target=\"_blank\" rel=\"external\">1小时教你学会正则表达式</a></p>\n"},{"title":"【正则表达式系列】贪婪与非贪婪模式","date":"2017-12-28T14:50:30.000Z","_content":"## 前言\n本文属于 正则表达式系列文章之一，将近一个多月了停更了，这个系列的坑得赶紧填了~~~\n## 目录\n** [【正则表达式系列】入门篇](http://loadingmore.com/2017/11/26/【正则表达式系列】入门篇/) **\n\n** [【正则表达式系列】贪婪与非贪婪模式]() **\n\n** 【正则表达式系列】零宽断言篇(待写) **\n\n## 贪婪模式与非贪婪模式快速理解\n\n所谓贪婪模式表达式本身会尽可能的匹配更多内容,非贪婪则反之；我们可以这么理解，一个人很贪婪，所以他会能拿多少拿多少，换过来，那就是贪婪模式下的正则表达式，能匹配多少就匹配多少，尽可能最多。而非贪婪模式，则是能不匹配就不匹配，尽可能最少\n\n## 贪婪模式非贪婪实战\n\n** 贪婪模式标识符 **\n<font style=\"color:#c33;padding:2px;\">+</font>、<font style=\"color:#c33;padding:2px;\">?</font>、<font style=\"color:#c33;padding:2px;\">\\*</font>、<font style=\"color:#c33;padding:2px;\">{n}</font>、<font style=\"color:#c33;padding:2px;\">{n,}</font>、<font style=\"color:#c33;padding:2px;\">{n,m}</font>\n<br>\n上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容\n\n** 非贪婪模式标识符 **\n<font style=\"color:#c33;padding:2px;\">+?</font>、<font style=\"color:#c33;padding:2px;\">??</font>、<font style=\"color:#c33;padding:2px;\">\\*?</font>、<font style=\"color:#c33;padding:2px;\">{n}?</font>、<font style=\"color:#c33;padding:2px;\">{n,}?</font>、<font style=\"color:#c33;padding:2px;\">{n,m}?</font>\n<br>\n非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个<font style=\"color:#c33;padding:2px;\">?</font>\n\n** 示例 **\n\n需求：匹配1后面跟任意个0\n目标源：10001\n```js\n使用贪婪模式：10*       结果：1000\n使用非贪婪模式：10*?    结果：1\n\nconst reg = /10*/\nconst reg2 = /10*?/\nconsole.log(reg.match('10001'))\nconsole.log(reg2.match('10001'))\n```\n\n[贪婪示例](https://regex101.com/r/XUpYgg/2)\n[非贪婪示例](https://regex101.com/r/XUpYgg/3)\n\n1.<font style=\"color:#c33;padding:2px;\">*</font>代表匹配0个或多个的意思：\n贪婪模式下，他首先匹配一个1然后匹配1后面的0，最多匹配到3个，因此是1000，假如我们的正则加上g模式匹配,会得到1000 和 1 两个结果\n\n2.非贪婪模式下，表示首先匹配一个1，然后以后面的0能不匹配就不匹配了，所以每次只匹配一个，然而，假如我们的正则加上g模式匹配,1 和 1 两个结果\n\n```js\n// 使用贪婪模式：10*       结果：1000 和 1\n// 使用非贪婪模式：10*?    结果：1 和 1\nconst reg = /10*/g\nconst reg2 = /10*?/g\nconsole.log(reg.match('10001'))\nconsole.log(reg2.match('10001'))\n```\n[贪婪示例](https://regex101.com/r/XUpYgg/5)\n[非贪婪示例](https://regex101.com/r/XUpYgg/4)\n\n** 看懂了？ **\n我们在来个例子：\n需求：匹配1后面跟任意个0，再跟一个1\n源串：10001\n\n```js\n// 使用贪婪模式：10*1      结果：10001\n// 使用非贪婪模式：10*?1    结果：10001\n\nconst reg = /10*/\nconst reg2 = /10*?/\nconsole.log(reg.match('10001'))\nconsole.log(reg2.match('10001'))\n```\n** 什么鬼？为什么两个结果一样**\n因为，正则表达式要判断完这整个正则才算成功：\n\n1.贪婪模式，首先匹配到一个1，然后后面尽可能的多匹配0，发现3个，最后一个匹配上1，至此，正则表达式完成匹配得到10001\n\n2.非贪婪模式，首先匹配到一个1，然后0*？是非贪婪模式，后面他不想匹配了，于是就瞅瞅后面看到1没？一看，我去，还是0，这下不能偷懒了，只能匹配0了，于是同样的故事上演了三次后，终于看到了希望，看到同胞兄弟1，完成正则匹配，得到10001\n[贪婪示例](https://regex101.com/r/XUpYgg/7)\n[非贪婪示例](https://regex101.com/r/XUpYgg/6/)\n\n** 那究竟哪个好呢？ **\n什么时候使用贪婪模式，什么时候使用非贪婪模式，哪个性能好，哪个性能不好，不能一概而论，要根据情况分析。\n下面我举个例子：\n源码：\n```html\n<a href=\"http://loadingmore.com/2017/11/18/Js上传图片本地预览几种姿势/\" target=\"_blank\" >Js上传图片本地预览几种姿势</a>\n```\n提取链接和文本：\n\n```js\nconst reg1 = /<a [^>]*?href=\"([^\"]*?)\"[^>]*?>([^<]*?)<\\/a>/\nconst reg2 = /<a [^>]*?href=\"([^\"]*)\"[^>]*>([^<]*)<\\/a>/\nconst reg3 = /<a [^>]*href=\"([^\"]*)\"[^>]*>([^<]*)<\\/a>/\n```\n\n[reg1运行次数](https://regex101.com/r/XUpYgg/8) (150次)\n[reg2运行次数](https://regex101.com/r/XUpYgg/9) (24次)\n[reg3运行次数](https://regex101.com/r/XUpYgg/10) (98次)\n\n正则1是通用写法，正则2是在确定字符不会溢出的情况下消除非贪婪模式，正则3是证明并不是全部消除非贪婪模式就是最优。\n关于贪婪模式好还是非贪婪模式好的讨论，只能说根据需求而定，不过，在平时的时候用，一般使用非贪婪模式较多，因为贪婪模式经常会由于元字符范围限制不严谨而导致匹配越界，得到非预期结果。\n\n## 提取数据示例\n\n### 提取两个\"\"中的子串，其中不能再包含\"\"\n需求: 提取两个引号之间的子串，其中不能再包括引号，例如上述的提取结果应该是: \"regular expression\" 与 \"Regex\"(每一个结束的\"后面都接空格)\n```js\nconst str = `\"The phrase \\\"regular expression\\\" is called \\\"Regex\\\" for short\"`\nconst reg = /\"[^\"]*\" /g // 注意正则最后面一个空格\nconsole.log(str.match(reg)) // [\"\"regular expression\" \", \"\"Regex\" \"]\n```\n[案例demo](https://regex101.com/r/XUpYgg/11)\n分析：\n1.从第一个\"开始匹配，接下来到12位时(\"r的\")，不满足[^\"]，也不满足之后的\"+空格，因此匹配失败了，index挪到下一个，开始下一次匹配\n2.第二个匹配从\"r的\"开始，一直匹配到n\"空格的空格，这一组刚刚好匹配成功(因为最后符合了正则的\"空格)，匹配好了\"regular expression\"空格\n3.第三个匹配匹配到了\"Regex\"空格(过程不再复述)\n4.到最后时，仅剩一个\"直接匹配失败(因为首先得符合\"才能开始正则匹配)\n5.至此，正则匹配结束，匹配成功，并且符合预期\n\n## 最后\n\n本文也只是做一些浅显的分析与引导，更多是起到抛砖引玉的作用，要深入理解还请去了解正则的原理\n\n[正则表达式之 贪婪与非贪婪模式详解](http://www.jb51.net/article/31491.htm)\n","source":"_posts/【正则表达式系列】贪婪与非贪婪模式.md","raw":"---\ntitle: 【正则表达式系列】贪婪与非贪婪模式\ndate: 2017-12-28 22:50:30\ntags: [javascript,RegExp,\"正则\"]\ncategories: Javascript\n---\n## 前言\n本文属于 正则表达式系列文章之一，将近一个多月了停更了，这个系列的坑得赶紧填了~~~\n## 目录\n** [【正则表达式系列】入门篇](http://loadingmore.com/2017/11/26/【正则表达式系列】入门篇/) **\n\n** [【正则表达式系列】贪婪与非贪婪模式]() **\n\n** 【正则表达式系列】零宽断言篇(待写) **\n\n## 贪婪模式与非贪婪模式快速理解\n\n所谓贪婪模式表达式本身会尽可能的匹配更多内容,非贪婪则反之；我们可以这么理解，一个人很贪婪，所以他会能拿多少拿多少，换过来，那就是贪婪模式下的正则表达式，能匹配多少就匹配多少，尽可能最多。而非贪婪模式，则是能不匹配就不匹配，尽可能最少\n\n## 贪婪模式非贪婪实战\n\n** 贪婪模式标识符 **\n<font style=\"color:#c33;padding:2px;\">+</font>、<font style=\"color:#c33;padding:2px;\">?</font>、<font style=\"color:#c33;padding:2px;\">\\*</font>、<font style=\"color:#c33;padding:2px;\">{n}</font>、<font style=\"color:#c33;padding:2px;\">{n,}</font>、<font style=\"color:#c33;padding:2px;\">{n,m}</font>\n<br>\n上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容\n\n** 非贪婪模式标识符 **\n<font style=\"color:#c33;padding:2px;\">+?</font>、<font style=\"color:#c33;padding:2px;\">??</font>、<font style=\"color:#c33;padding:2px;\">\\*?</font>、<font style=\"color:#c33;padding:2px;\">{n}?</font>、<font style=\"color:#c33;padding:2px;\">{n,}?</font>、<font style=\"color:#c33;padding:2px;\">{n,m}?</font>\n<br>\n非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个<font style=\"color:#c33;padding:2px;\">?</font>\n\n** 示例 **\n\n需求：匹配1后面跟任意个0\n目标源：10001\n```js\n使用贪婪模式：10*       结果：1000\n使用非贪婪模式：10*?    结果：1\n\nconst reg = /10*/\nconst reg2 = /10*?/\nconsole.log(reg.match('10001'))\nconsole.log(reg2.match('10001'))\n```\n\n[贪婪示例](https://regex101.com/r/XUpYgg/2)\n[非贪婪示例](https://regex101.com/r/XUpYgg/3)\n\n1.<font style=\"color:#c33;padding:2px;\">*</font>代表匹配0个或多个的意思：\n贪婪模式下，他首先匹配一个1然后匹配1后面的0，最多匹配到3个，因此是1000，假如我们的正则加上g模式匹配,会得到1000 和 1 两个结果\n\n2.非贪婪模式下，表示首先匹配一个1，然后以后面的0能不匹配就不匹配了，所以每次只匹配一个，然而，假如我们的正则加上g模式匹配,1 和 1 两个结果\n\n```js\n// 使用贪婪模式：10*       结果：1000 和 1\n// 使用非贪婪模式：10*?    结果：1 和 1\nconst reg = /10*/g\nconst reg2 = /10*?/g\nconsole.log(reg.match('10001'))\nconsole.log(reg2.match('10001'))\n```\n[贪婪示例](https://regex101.com/r/XUpYgg/5)\n[非贪婪示例](https://regex101.com/r/XUpYgg/4)\n\n** 看懂了？ **\n我们在来个例子：\n需求：匹配1后面跟任意个0，再跟一个1\n源串：10001\n\n```js\n// 使用贪婪模式：10*1      结果：10001\n// 使用非贪婪模式：10*?1    结果：10001\n\nconst reg = /10*/\nconst reg2 = /10*?/\nconsole.log(reg.match('10001'))\nconsole.log(reg2.match('10001'))\n```\n** 什么鬼？为什么两个结果一样**\n因为，正则表达式要判断完这整个正则才算成功：\n\n1.贪婪模式，首先匹配到一个1，然后后面尽可能的多匹配0，发现3个，最后一个匹配上1，至此，正则表达式完成匹配得到10001\n\n2.非贪婪模式，首先匹配到一个1，然后0*？是非贪婪模式，后面他不想匹配了，于是就瞅瞅后面看到1没？一看，我去，还是0，这下不能偷懒了，只能匹配0了，于是同样的故事上演了三次后，终于看到了希望，看到同胞兄弟1，完成正则匹配，得到10001\n[贪婪示例](https://regex101.com/r/XUpYgg/7)\n[非贪婪示例](https://regex101.com/r/XUpYgg/6/)\n\n** 那究竟哪个好呢？ **\n什么时候使用贪婪模式，什么时候使用非贪婪模式，哪个性能好，哪个性能不好，不能一概而论，要根据情况分析。\n下面我举个例子：\n源码：\n```html\n<a href=\"http://loadingmore.com/2017/11/18/Js上传图片本地预览几种姿势/\" target=\"_blank\" >Js上传图片本地预览几种姿势</a>\n```\n提取链接和文本：\n\n```js\nconst reg1 = /<a [^>]*?href=\"([^\"]*?)\"[^>]*?>([^<]*?)<\\/a>/\nconst reg2 = /<a [^>]*?href=\"([^\"]*)\"[^>]*>([^<]*)<\\/a>/\nconst reg3 = /<a [^>]*href=\"([^\"]*)\"[^>]*>([^<]*)<\\/a>/\n```\n\n[reg1运行次数](https://regex101.com/r/XUpYgg/8) (150次)\n[reg2运行次数](https://regex101.com/r/XUpYgg/9) (24次)\n[reg3运行次数](https://regex101.com/r/XUpYgg/10) (98次)\n\n正则1是通用写法，正则2是在确定字符不会溢出的情况下消除非贪婪模式，正则3是证明并不是全部消除非贪婪模式就是最优。\n关于贪婪模式好还是非贪婪模式好的讨论，只能说根据需求而定，不过，在平时的时候用，一般使用非贪婪模式较多，因为贪婪模式经常会由于元字符范围限制不严谨而导致匹配越界，得到非预期结果。\n\n## 提取数据示例\n\n### 提取两个\"\"中的子串，其中不能再包含\"\"\n需求: 提取两个引号之间的子串，其中不能再包括引号，例如上述的提取结果应该是: \"regular expression\" 与 \"Regex\"(每一个结束的\"后面都接空格)\n```js\nconst str = `\"The phrase \\\"regular expression\\\" is called \\\"Regex\\\" for short\"`\nconst reg = /\"[^\"]*\" /g // 注意正则最后面一个空格\nconsole.log(str.match(reg)) // [\"\"regular expression\" \", \"\"Regex\" \"]\n```\n[案例demo](https://regex101.com/r/XUpYgg/11)\n分析：\n1.从第一个\"开始匹配，接下来到12位时(\"r的\")，不满足[^\"]，也不满足之后的\"+空格，因此匹配失败了，index挪到下一个，开始下一次匹配\n2.第二个匹配从\"r的\"开始，一直匹配到n\"空格的空格，这一组刚刚好匹配成功(因为最后符合了正则的\"空格)，匹配好了\"regular expression\"空格\n3.第三个匹配匹配到了\"Regex\"空格(过程不再复述)\n4.到最后时，仅剩一个\"直接匹配失败(因为首先得符合\"才能开始正则匹配)\n5.至此，正则匹配结束，匹配成功，并且符合预期\n\n## 最后\n\n本文也只是做一些浅显的分析与引导，更多是起到抛砖引玉的作用，要深入理解还请去了解正则的原理\n\n[正则表达式之 贪婪与非贪婪模式详解](http://www.jb51.net/article/31491.htm)\n","slug":"【正则表达式系列】贪婪与非贪婪模式","published":1,"updated":"2019-09-25T15:10:25.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91p5003kla2eelpjygch","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文属于 正则表达式系列文章之一，将近一个多月了停更了，这个系列的坑得赶紧填了~~~</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p><strong> <a href=\"http://loadingmore.com/2017/11/26/【正则表达式系列】入门篇/\">【正则表达式系列】入门篇</a> </strong></p>\n<p><strong> <a href=\"\">【正则表达式系列】贪婪与非贪婪模式</a> </strong></p>\n<p><strong> 【正则表达式系列】零宽断言篇(待写) </strong></p>\n<h2 id=\"贪婪模式与非贪婪模式快速理解\"><a href=\"#贪婪模式与非贪婪模式快速理解\" class=\"headerlink\" title=\"贪婪模式与非贪婪模式快速理解\"></a>贪婪模式与非贪婪模式快速理解</h2><p>所谓贪婪模式表达式本身会尽可能的匹配更多内容,非贪婪则反之；我们可以这么理解，一个人很贪婪，所以他会能拿多少拿多少，换过来，那就是贪婪模式下的正则表达式，能匹配多少就匹配多少，尽可能最多。而非贪婪模式，则是能不匹配就不匹配，尽可能最少</p>\n<h2 id=\"贪婪模式非贪婪实战\"><a href=\"#贪婪模式非贪婪实战\" class=\"headerlink\" title=\"贪婪模式非贪婪实战\"></a>贪婪模式非贪婪实战</h2><p><strong> 贪婪模式标识符 </strong></p>\n<font style=\"color:#c33;padding:2px;\">+</font>、<font style=\"color:#c33;padding:2px;\">?</font>、<font style=\"color:#c33;padding:2px;\">*</font>、<font style=\"color:#c33;padding:2px;\">{n}</font>、<font style=\"color:#c33;padding:2px;\">{n,}</font>、<font style=\"color:#c33;padding:2px;\">{n,m}</font><br><br><br>上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容<br><br><strong> 非贪婪模式标识符 </strong><br><font style=\"color:#c33;padding:2px;\">+?</font>、<font style=\"color:#c33;padding:2px;\">??</font>、<font style=\"color:#c33;padding:2px;\">*?</font>、<font style=\"color:#c33;padding:2px;\">{n}?</font>、<font style=\"color:#c33;padding:2px;\">{n,}?</font>、<font style=\"color:#c33;padding:2px;\">{n,m}?</font><br><br><br>非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个<font style=\"color:#c33;padding:2px;\">?</font>\n\n<p><strong> 示例 </strong></p>\n<p>需求：匹配1后面跟任意个0<br>目标源：10001</p>\n<pre><code class=\"js\">使用贪婪模式：10*       结果：1000\n使用非贪婪模式：10*?    结果：1\n\nconst reg = /10*/\nconst reg2 = /10*?/\nconsole.log(reg.match(&#39;10001&#39;))\nconsole.log(reg2.match(&#39;10001&#39;))\n</code></pre>\n<p><a href=\"https://regex101.com/r/XUpYgg/2\" target=\"_blank\" rel=\"external\">贪婪示例</a><br><a href=\"https://regex101.com/r/XUpYgg/3\" target=\"_blank\" rel=\"external\">非贪婪示例</a></p>\n<p>1.<font style=\"color:#c33;padding:2px;\">*</font>代表匹配0个或多个的意思：<br>贪婪模式下，他首先匹配一个1然后匹配1后面的0，最多匹配到3个，因此是1000，假如我们的正则加上g模式匹配,会得到1000 和 1 两个结果</p>\n<p>2.非贪婪模式下，表示首先匹配一个1，然后以后面的0能不匹配就不匹配了，所以每次只匹配一个，然而，假如我们的正则加上g模式匹配,1 和 1 两个结果</p>\n<pre><code class=\"js\">// 使用贪婪模式：10*       结果：1000 和 1\n// 使用非贪婪模式：10*?    结果：1 和 1\nconst reg = /10*/g\nconst reg2 = /10*?/g\nconsole.log(reg.match(&#39;10001&#39;))\nconsole.log(reg2.match(&#39;10001&#39;))\n</code></pre>\n<p><a href=\"https://regex101.com/r/XUpYgg/5\" target=\"_blank\" rel=\"external\">贪婪示例</a><br><a href=\"https://regex101.com/r/XUpYgg/4\" target=\"_blank\" rel=\"external\">非贪婪示例</a></p>\n<p><strong> 看懂了？ </strong><br>我们在来个例子：<br>需求：匹配1后面跟任意个0，再跟一个1<br>源串：10001</p>\n<pre><code class=\"js\">// 使用贪婪模式：10*1      结果：10001\n// 使用非贪婪模式：10*?1    结果：10001\n\nconst reg = /10*/\nconst reg2 = /10*?/\nconsole.log(reg.match(&#39;10001&#39;))\nconsole.log(reg2.match(&#39;10001&#39;))\n</code></pre>\n<p><strong> 什么鬼？为什么两个结果一样</strong><br>因为，正则表达式要判断完这整个正则才算成功：</p>\n<p>1.贪婪模式，首先匹配到一个1，然后后面尽可能的多匹配0，发现3个，最后一个匹配上1，至此，正则表达式完成匹配得到10001</p>\n<p>2.非贪婪模式，首先匹配到一个1，然后0*？是非贪婪模式，后面他不想匹配了，于是就瞅瞅后面看到1没？一看，我去，还是0，这下不能偷懒了，只能匹配0了，于是同样的故事上演了三次后，终于看到了希望，看到同胞兄弟1，完成正则匹配，得到10001<br><a href=\"https://regex101.com/r/XUpYgg/7\" target=\"_blank\" rel=\"external\">贪婪示例</a><br><a href=\"https://regex101.com/r/XUpYgg/6/\" target=\"_blank\" rel=\"external\">非贪婪示例</a></p>\n<p><strong> 那究竟哪个好呢？ </strong><br>什么时候使用贪婪模式，什么时候使用非贪婪模式，哪个性能好，哪个性能不好，不能一概而论，要根据情况分析。<br>下面我举个例子：<br>源码：</p>\n<pre><code class=\"html\">&lt;a href=&quot;http://loadingmore.com/2017/11/18/Js上传图片本地预览几种姿势/&quot; target=&quot;_blank&quot; &gt;Js上传图片本地预览几种姿势&lt;/a&gt;\n</code></pre>\n<p>提取链接和文本：</p>\n<pre><code class=\"js\">const reg1 = /&lt;a [^&gt;]*?href=&quot;([^&quot;]*?)&quot;[^&gt;]*?&gt;([^&lt;]*?)&lt;\\/a&gt;/\nconst reg2 = /&lt;a [^&gt;]*?href=&quot;([^&quot;]*)&quot;[^&gt;]*&gt;([^&lt;]*)&lt;\\/a&gt;/\nconst reg3 = /&lt;a [^&gt;]*href=&quot;([^&quot;]*)&quot;[^&gt;]*&gt;([^&lt;]*)&lt;\\/a&gt;/\n</code></pre>\n<p><a href=\"https://regex101.com/r/XUpYgg/8\" target=\"_blank\" rel=\"external\">reg1运行次数</a> (150次)<br><a href=\"https://regex101.com/r/XUpYgg/9\" target=\"_blank\" rel=\"external\">reg2运行次数</a> (24次)<br><a href=\"https://regex101.com/r/XUpYgg/10\" target=\"_blank\" rel=\"external\">reg3运行次数</a> (98次)</p>\n<p>正则1是通用写法，正则2是在确定字符不会溢出的情况下消除非贪婪模式，正则3是证明并不是全部消除非贪婪模式就是最优。<br>关于贪婪模式好还是非贪婪模式好的讨论，只能说根据需求而定，不过，在平时的时候用，一般使用非贪婪模式较多，因为贪婪模式经常会由于元字符范围限制不严谨而导致匹配越界，得到非预期结果。</p>\n<h2 id=\"提取数据示例\"><a href=\"#提取数据示例\" class=\"headerlink\" title=\"提取数据示例\"></a>提取数据示例</h2><h3 id=\"提取两个””中的子串，其中不能再包含””\"><a href=\"#提取两个””中的子串，其中不能再包含””\" class=\"headerlink\" title=\"提取两个””中的子串，其中不能再包含””\"></a>提取两个””中的子串，其中不能再包含””</h3><p>需求: 提取两个引号之间的子串，其中不能再包括引号，例如上述的提取结果应该是: “regular expression” 与 “Regex”(每一个结束的”后面都接空格)</p>\n<pre><code class=\"js\">const str = `&quot;The phrase \\&quot;regular expression\\&quot; is called \\&quot;Regex\\&quot; for short&quot;`\nconst reg = /&quot;[^&quot;]*&quot; /g // 注意正则最后面一个空格\nconsole.log(str.match(reg)) // [&quot;&quot;regular expression&quot; &quot;, &quot;&quot;Regex&quot; &quot;]\n</code></pre>\n<p><a href=\"https://regex101.com/r/XUpYgg/11\" target=\"_blank\" rel=\"external\">案例demo</a><br>分析：<br>1.从第一个”开始匹配，接下来到12位时(“r的”)，不满足[^”]，也不满足之后的”+空格，因此匹配失败了，index挪到下一个，开始下一次匹配<br>2.第二个匹配从”r的”开始，一直匹配到n”空格的空格，这一组刚刚好匹配成功(因为最后符合了正则的”空格)，匹配好了”regular expression”空格<br>3.第三个匹配匹配到了”Regex”空格(过程不再复述)<br>4.到最后时，仅剩一个”直接匹配失败(因为首先得符合”才能开始正则匹配)<br>5.至此，正则匹配结束，匹配成功，并且符合预期</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>本文也只是做一些浅显的分析与引导，更多是起到抛砖引玉的作用，要深入理解还请去了解正则的原理</p>\n<p><a href=\"http://www.jb51.net/article/31491.htm\" target=\"_blank\" rel=\"external\">正则表达式之 贪婪与非贪婪模式详解</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文属于 正则表达式系列文章之一，将近一个多月了停更了，这个系列的坑得赶紧填了~~~</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p><strong> <a href=\"http://loadingmore.com/2017/11/26/【正则表达式系列】入门篇/\">【正则表达式系列】入门篇</a> </strong></p>\n<p><strong> <a href=\"\">【正则表达式系列】贪婪与非贪婪模式</a> </strong></p>\n<p><strong> 【正则表达式系列】零宽断言篇(待写) </strong></p>\n<h2 id=\"贪婪模式与非贪婪模式快速理解\"><a href=\"#贪婪模式与非贪婪模式快速理解\" class=\"headerlink\" title=\"贪婪模式与非贪婪模式快速理解\"></a>贪婪模式与非贪婪模式快速理解</h2><p>所谓贪婪模式表达式本身会尽可能的匹配更多内容,非贪婪则反之；我们可以这么理解，一个人很贪婪，所以他会能拿多少拿多少，换过来，那就是贪婪模式下的正则表达式，能匹配多少就匹配多少，尽可能最多。而非贪婪模式，则是能不匹配就不匹配，尽可能最少</p>\n<h2 id=\"贪婪模式非贪婪实战\"><a href=\"#贪婪模式非贪婪实战\" class=\"headerlink\" title=\"贪婪模式非贪婪实战\"></a>贪婪模式非贪婪实战</h2><p><strong> 贪婪模式标识符 </strong></p>\n<font style=\"color:#c33;padding:2px;\">+</font>、<font style=\"color:#c33;padding:2px;\">?</font>、<font style=\"color:#c33;padding:2px;\">*</font>、<font style=\"color:#c33;padding:2px;\">{n}</font>、<font style=\"color:#c33;padding:2px;\">{n,}</font>、<font style=\"color:#c33;padding:2px;\">{n,m}</font><br><br><br>上述标识符，代表是贪婪匹配，会尽可能多的去匹配内容<br><br><strong> 非贪婪模式标识符 </strong><br><font style=\"color:#c33;padding:2px;\">+?</font>、<font style=\"color:#c33;padding:2px;\">??</font>、<font style=\"color:#c33;padding:2px;\">*?</font>、<font style=\"color:#c33;padding:2px;\">{n}?</font>、<font style=\"color:#c33;padding:2px;\">{n,}?</font>、<font style=\"color:#c33;padding:2px;\">{n,m}?</font><br><br><br>非贪婪模式的标识符很有规律，就是贪婪模式的标识符后面加上一个<font style=\"color:#c33;padding:2px;\">?</font>\n\n<p><strong> 示例 </strong></p>\n<p>需求：匹配1后面跟任意个0<br>目标源：10001</p>\n<pre><code class=\"js\">使用贪婪模式：10*       结果：1000\n使用非贪婪模式：10*?    结果：1\n\nconst reg = /10*/\nconst reg2 = /10*?/\nconsole.log(reg.match(&#39;10001&#39;))\nconsole.log(reg2.match(&#39;10001&#39;))\n</code></pre>\n<p><a href=\"https://regex101.com/r/XUpYgg/2\" target=\"_blank\" rel=\"external\">贪婪示例</a><br><a href=\"https://regex101.com/r/XUpYgg/3\" target=\"_blank\" rel=\"external\">非贪婪示例</a></p>\n<p>1.<font style=\"color:#c33;padding:2px;\">*</font>代表匹配0个或多个的意思：<br>贪婪模式下，他首先匹配一个1然后匹配1后面的0，最多匹配到3个，因此是1000，假如我们的正则加上g模式匹配,会得到1000 和 1 两个结果</p>\n<p>2.非贪婪模式下，表示首先匹配一个1，然后以后面的0能不匹配就不匹配了，所以每次只匹配一个，然而，假如我们的正则加上g模式匹配,1 和 1 两个结果</p>\n<pre><code class=\"js\">// 使用贪婪模式：10*       结果：1000 和 1\n// 使用非贪婪模式：10*?    结果：1 和 1\nconst reg = /10*/g\nconst reg2 = /10*?/g\nconsole.log(reg.match(&#39;10001&#39;))\nconsole.log(reg2.match(&#39;10001&#39;))\n</code></pre>\n<p><a href=\"https://regex101.com/r/XUpYgg/5\" target=\"_blank\" rel=\"external\">贪婪示例</a><br><a href=\"https://regex101.com/r/XUpYgg/4\" target=\"_blank\" rel=\"external\">非贪婪示例</a></p>\n<p><strong> 看懂了？ </strong><br>我们在来个例子：<br>需求：匹配1后面跟任意个0，再跟一个1<br>源串：10001</p>\n<pre><code class=\"js\">// 使用贪婪模式：10*1      结果：10001\n// 使用非贪婪模式：10*?1    结果：10001\n\nconst reg = /10*/\nconst reg2 = /10*?/\nconsole.log(reg.match(&#39;10001&#39;))\nconsole.log(reg2.match(&#39;10001&#39;))\n</code></pre>\n<p><strong> 什么鬼？为什么两个结果一样</strong><br>因为，正则表达式要判断完这整个正则才算成功：</p>\n<p>1.贪婪模式，首先匹配到一个1，然后后面尽可能的多匹配0，发现3个，最后一个匹配上1，至此，正则表达式完成匹配得到10001</p>\n<p>2.非贪婪模式，首先匹配到一个1，然后0*？是非贪婪模式，后面他不想匹配了，于是就瞅瞅后面看到1没？一看，我去，还是0，这下不能偷懒了，只能匹配0了，于是同样的故事上演了三次后，终于看到了希望，看到同胞兄弟1，完成正则匹配，得到10001<br><a href=\"https://regex101.com/r/XUpYgg/7\" target=\"_blank\" rel=\"external\">贪婪示例</a><br><a href=\"https://regex101.com/r/XUpYgg/6/\" target=\"_blank\" rel=\"external\">非贪婪示例</a></p>\n<p><strong> 那究竟哪个好呢？ </strong><br>什么时候使用贪婪模式，什么时候使用非贪婪模式，哪个性能好，哪个性能不好，不能一概而论，要根据情况分析。<br>下面我举个例子：<br>源码：</p>\n<pre><code class=\"html\">&lt;a href=&quot;http://loadingmore.com/2017/11/18/Js上传图片本地预览几种姿势/&quot; target=&quot;_blank&quot; &gt;Js上传图片本地预览几种姿势&lt;/a&gt;\n</code></pre>\n<p>提取链接和文本：</p>\n<pre><code class=\"js\">const reg1 = /&lt;a [^&gt;]*?href=&quot;([^&quot;]*?)&quot;[^&gt;]*?&gt;([^&lt;]*?)&lt;\\/a&gt;/\nconst reg2 = /&lt;a [^&gt;]*?href=&quot;([^&quot;]*)&quot;[^&gt;]*&gt;([^&lt;]*)&lt;\\/a&gt;/\nconst reg3 = /&lt;a [^&gt;]*href=&quot;([^&quot;]*)&quot;[^&gt;]*&gt;([^&lt;]*)&lt;\\/a&gt;/\n</code></pre>\n<p><a href=\"https://regex101.com/r/XUpYgg/8\" target=\"_blank\" rel=\"external\">reg1运行次数</a> (150次)<br><a href=\"https://regex101.com/r/XUpYgg/9\" target=\"_blank\" rel=\"external\">reg2运行次数</a> (24次)<br><a href=\"https://regex101.com/r/XUpYgg/10\" target=\"_blank\" rel=\"external\">reg3运行次数</a> (98次)</p>\n<p>正则1是通用写法，正则2是在确定字符不会溢出的情况下消除非贪婪模式，正则3是证明并不是全部消除非贪婪模式就是最优。<br>关于贪婪模式好还是非贪婪模式好的讨论，只能说根据需求而定，不过，在平时的时候用，一般使用非贪婪模式较多，因为贪婪模式经常会由于元字符范围限制不严谨而导致匹配越界，得到非预期结果。</p>\n<h2 id=\"提取数据示例\"><a href=\"#提取数据示例\" class=\"headerlink\" title=\"提取数据示例\"></a>提取数据示例</h2><h3 id=\"提取两个””中的子串，其中不能再包含””\"><a href=\"#提取两个””中的子串，其中不能再包含””\" class=\"headerlink\" title=\"提取两个””中的子串，其中不能再包含””\"></a>提取两个””中的子串，其中不能再包含””</h3><p>需求: 提取两个引号之间的子串，其中不能再包括引号，例如上述的提取结果应该是: “regular expression” 与 “Regex”(每一个结束的”后面都接空格)</p>\n<pre><code class=\"js\">const str = `&quot;The phrase \\&quot;regular expression\\&quot; is called \\&quot;Regex\\&quot; for short&quot;`\nconst reg = /&quot;[^&quot;]*&quot; /g // 注意正则最后面一个空格\nconsole.log(str.match(reg)) // [&quot;&quot;regular expression&quot; &quot;, &quot;&quot;Regex&quot; &quot;]\n</code></pre>\n<p><a href=\"https://regex101.com/r/XUpYgg/11\" target=\"_blank\" rel=\"external\">案例demo</a><br>分析：<br>1.从第一个”开始匹配，接下来到12位时(“r的”)，不满足[^”]，也不满足之后的”+空格，因此匹配失败了，index挪到下一个，开始下一次匹配<br>2.第二个匹配从”r的”开始，一直匹配到n”空格的空格，这一组刚刚好匹配成功(因为最后符合了正则的”空格)，匹配好了”regular expression”空格<br>3.第三个匹配匹配到了”Regex”空格(过程不再复述)<br>4.到最后时，仅剩一个”直接匹配失败(因为首先得符合”才能开始正则匹配)<br>5.至此，正则匹配结束，匹配成功，并且符合预期</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>本文也只是做一些浅显的分析与引导，更多是起到抛砖引玉的作用，要深入理解还请去了解正则的原理</p>\n<p><a href=\"http://www.jb51.net/article/31491.htm\" target=\"_blank\" rel=\"external\">正则表达式之 贪婪与非贪婪模式详解</a></p>\n"},{"title":"一个有点意思的正则","date":"2017-07-01T13:37:38.000Z","author":"LoadingMore","header-img":"form-opts.png","cdn":"header-on","_content":"> 周末闲来无事，没事逛逛前端群,碰到一个有点意思的题目,记录下来\n\n## 需求\n一个数组，里面的字符串都有相同的前几个字，但是后面的不相同  如何把这相同的提取出来\n大概像下面这样：\n```js\nconst arr = ['test23','testtr','test90'] //共同体 test\nconst arr1 = ['tes23','testtr','test90'] //共同体 tes  小心搞错哦\nconst arr2 = ['回家3','回家5','回家吗'] // 共同体 回家\n```\n## 我的方法\n看到的第一感觉就是用正则(谁让我逻辑很菜呢...)\n```js\n/**\n* @param {len} 数组长度 下面用来匹配重复的个数\n* @param {reg} 不用说了，我们的匹配规则\n* @param {data} 换个思路，当做字符串进行处理\n*/\nfunction getWord(arr){\n    var len = arr.length,\n        reg = new RegExp('^(.*)(.*\\\\1){'+(len-1)+'}','g'),\n        data = arr.join('');\n    return reg.exec(data)[1]\n}\nconsole.log(getWord(arr)) // test\nconsole.log(getWord(arr1)) //tes\nconsole.log(getWord(arr2)) //回家\n```\n## 使用场景\n我也不知道(逃...),我就想安安静静的温习个正则而已.\n如果有更好的方法，烦请与我联系,向您请教，如有bug,请轻拍.我的邮箱：biyuqiwan@163.com\n","source":"_posts/一个有点意思的正则.md","raw":"---\ntitle: 一个有点意思的正则\ndate: 2017-07-01 21:37:38\ntags: [RegExp,'正则']\nauthor: \"LoadingMore\"\nheader-img: \"form-opts.png\"\ncdn: 'header-on'\n---\n> 周末闲来无事，没事逛逛前端群,碰到一个有点意思的题目,记录下来\n\n## 需求\n一个数组，里面的字符串都有相同的前几个字，但是后面的不相同  如何把这相同的提取出来\n大概像下面这样：\n```js\nconst arr = ['test23','testtr','test90'] //共同体 test\nconst arr1 = ['tes23','testtr','test90'] //共同体 tes  小心搞错哦\nconst arr2 = ['回家3','回家5','回家吗'] // 共同体 回家\n```\n## 我的方法\n看到的第一感觉就是用正则(谁让我逻辑很菜呢...)\n```js\n/**\n* @param {len} 数组长度 下面用来匹配重复的个数\n* @param {reg} 不用说了，我们的匹配规则\n* @param {data} 换个思路，当做字符串进行处理\n*/\nfunction getWord(arr){\n    var len = arr.length,\n        reg = new RegExp('^(.*)(.*\\\\1){'+(len-1)+'}','g'),\n        data = arr.join('');\n    return reg.exec(data)[1]\n}\nconsole.log(getWord(arr)) // test\nconsole.log(getWord(arr1)) //tes\nconsole.log(getWord(arr2)) //回家\n```\n## 使用场景\n我也不知道(逃...),我就想安安静静的温习个正则而已.\n如果有更好的方法，烦请与我联系,向您请教，如有bug,请轻拍.我的邮箱：biyuqiwan@163.com\n","slug":"一个有点意思的正则","published":1,"updated":"2019-09-25T15:10:25.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91p6003pla2edj06hv6g","content":"<blockquote>\n<p>周末闲来无事，没事逛逛前端群,碰到一个有点意思的题目,记录下来</p>\n</blockquote>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>一个数组，里面的字符串都有相同的前几个字，但是后面的不相同  如何把这相同的提取出来<br>大概像下面这样：</p>\n<pre><code class=\"js\">const arr = [&#39;test23&#39;,&#39;testtr&#39;,&#39;test90&#39;] //共同体 test\nconst arr1 = [&#39;tes23&#39;,&#39;testtr&#39;,&#39;test90&#39;] //共同体 tes  小心搞错哦\nconst arr2 = [&#39;回家3&#39;,&#39;回家5&#39;,&#39;回家吗&#39;] // 共同体 回家\n</code></pre>\n<h2 id=\"我的方法\"><a href=\"#我的方法\" class=\"headerlink\" title=\"我的方法\"></a>我的方法</h2><p>看到的第一感觉就是用正则(谁让我逻辑很菜呢…)</p>\n<pre><code class=\"js\">/**\n* @param {len} 数组长度 下面用来匹配重复的个数\n* @param {reg} 不用说了，我们的匹配规则\n* @param {data} 换个思路，当做字符串进行处理\n*/\nfunction getWord(arr){\n    var len = arr.length,\n        reg = new RegExp(&#39;^(.*)(.*\\\\1){&#39;+(len-1)+&#39;}&#39;,&#39;g&#39;),\n        data = arr.join(&#39;&#39;);\n    return reg.exec(data)[1]\n}\nconsole.log(getWord(arr)) // test\nconsole.log(getWord(arr1)) //tes\nconsole.log(getWord(arr2)) //回家\n</code></pre>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>我也不知道(逃…),我就想安安静静的温习个正则而已.<br>如果有更好的方法，烦请与我联系,向您请教，如有bug,请轻拍.我的邮箱：biyuqiwan@163.com</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>周末闲来无事，没事逛逛前端群,碰到一个有点意思的题目,记录下来</p>\n</blockquote>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>一个数组，里面的字符串都有相同的前几个字，但是后面的不相同  如何把这相同的提取出来<br>大概像下面这样：</p>\n<pre><code class=\"js\">const arr = [&#39;test23&#39;,&#39;testtr&#39;,&#39;test90&#39;] //共同体 test\nconst arr1 = [&#39;tes23&#39;,&#39;testtr&#39;,&#39;test90&#39;] //共同体 tes  小心搞错哦\nconst arr2 = [&#39;回家3&#39;,&#39;回家5&#39;,&#39;回家吗&#39;] // 共同体 回家\n</code></pre>\n<h2 id=\"我的方法\"><a href=\"#我的方法\" class=\"headerlink\" title=\"我的方法\"></a>我的方法</h2><p>看到的第一感觉就是用正则(谁让我逻辑很菜呢…)</p>\n<pre><code class=\"js\">/**\n* @param {len} 数组长度 下面用来匹配重复的个数\n* @param {reg} 不用说了，我们的匹配规则\n* @param {data} 换个思路，当做字符串进行处理\n*/\nfunction getWord(arr){\n    var len = arr.length,\n        reg = new RegExp(&#39;^(.*)(.*\\\\1){&#39;+(len-1)+&#39;}&#39;,&#39;g&#39;),\n        data = arr.join(&#39;&#39;);\n    return reg.exec(data)[1]\n}\nconsole.log(getWord(arr)) // test\nconsole.log(getWord(arr1)) //tes\nconsole.log(getWord(arr2)) //回家\n</code></pre>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>我也不知道(逃…),我就想安安静静的温习个正则而已.<br>如果有更好的方法，烦请与我联系,向您请教，如有bug,请轻拍.我的邮箱：biyuqiwan@163.com</p>\n"},{"title":"收集一些有趣常用的npm包","date":"2018-10-31T15:26:38.000Z","_content":"> 记录一些当前或以后要用到的npm包\n\n**RSS**\n* [rss-parser](https://github.com/bobby-brennan/rss-parser) A lightweight RSS parser, for Node and the browser\n* [node-rss](https://github.com/dylang/node-rss) RSS feed generator for Node\n\n**微信推送**\n* [PushBear](https://pushbear.ftqq.com/admin/#/) 基于微信模板的一对多消息送达服务\n\n**任务调度**(强烈推荐)\n\n* [node-schedule](https://github.com/node-schedule/node-schedule) A cron-like and not-cron-like job scheduler for Node.\n\n**异步**\n\n* [async](https://github.com/caolan/async) Async utilities for node and the browser \n\n**锚点滚动**\n\n* [smooth-scroll](https://github.com/cferdinandi/smooth-scroll) A lightweight script to animate scrolling to anchor links.\n\n\n","source":"_posts/一些有趣常用的npm包收集.md","raw":"---\ntitle: 收集一些有趣常用的npm包\ndate: 2018-10-31 23:26:38\ntags: [npm']\ncategories: Tool\n---\n> 记录一些当前或以后要用到的npm包\n\n**RSS**\n* [rss-parser](https://github.com/bobby-brennan/rss-parser) A lightweight RSS parser, for Node and the browser\n* [node-rss](https://github.com/dylang/node-rss) RSS feed generator for Node\n\n**微信推送**\n* [PushBear](https://pushbear.ftqq.com/admin/#/) 基于微信模板的一对多消息送达服务\n\n**任务调度**(强烈推荐)\n\n* [node-schedule](https://github.com/node-schedule/node-schedule) A cron-like and not-cron-like job scheduler for Node.\n\n**异步**\n\n* [async](https://github.com/caolan/async) Async utilities for node and the browser \n\n**锚点滚动**\n\n* [smooth-scroll](https://github.com/cferdinandi/smooth-scroll) A lightweight script to animate scrolling to anchor links.\n\n\n","slug":"一些有趣常用的npm包收集","published":1,"updated":"2019-09-25T15:10:25.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91p9003sla2e2cgfne32","content":"<blockquote>\n<p>记录一些当前或以后要用到的npm包</p>\n</blockquote>\n<p><strong>RSS</strong></p>\n<ul>\n<li><a href=\"https://github.com/bobby-brennan/rss-parser\" target=\"_blank\" rel=\"external\">rss-parser</a> A lightweight RSS parser, for Node and the browser</li>\n<li><a href=\"https://github.com/dylang/node-rss\" target=\"_blank\" rel=\"external\">node-rss</a> RSS feed generator for Node</li>\n</ul>\n<p><strong>微信推送</strong></p>\n<ul>\n<li><a href=\"https://pushbear.ftqq.com/admin/#/\" target=\"_blank\" rel=\"external\">PushBear</a> 基于微信模板的一对多消息送达服务</li>\n</ul>\n<p><strong>任务调度</strong>(强烈推荐)</p>\n<ul>\n<li><a href=\"https://github.com/node-schedule/node-schedule\" target=\"_blank\" rel=\"external\">node-schedule</a> A cron-like and not-cron-like job scheduler for Node.</li>\n</ul>\n<p><strong>异步</strong></p>\n<ul>\n<li><a href=\"https://github.com/caolan/async\" target=\"_blank\" rel=\"external\">async</a> Async utilities for node and the browser </li>\n</ul>\n<p><strong>锚点滚动</strong></p>\n<ul>\n<li><a href=\"https://github.com/cferdinandi/smooth-scroll\" target=\"_blank\" rel=\"external\">smooth-scroll</a> A lightweight script to animate scrolling to anchor links.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录一些当前或以后要用到的npm包</p>\n</blockquote>\n<p><strong>RSS</strong></p>\n<ul>\n<li><a href=\"https://github.com/bobby-brennan/rss-parser\" target=\"_blank\" rel=\"external\">rss-parser</a> A lightweight RSS parser, for Node and the browser</li>\n<li><a href=\"https://github.com/dylang/node-rss\" target=\"_blank\" rel=\"external\">node-rss</a> RSS feed generator for Node</li>\n</ul>\n<p><strong>微信推送</strong></p>\n<ul>\n<li><a href=\"https://pushbear.ftqq.com/admin/#/\" target=\"_blank\" rel=\"external\">PushBear</a> 基于微信模板的一对多消息送达服务</li>\n</ul>\n<p><strong>任务调度</strong>(强烈推荐)</p>\n<ul>\n<li><a href=\"https://github.com/node-schedule/node-schedule\" target=\"_blank\" rel=\"external\">node-schedule</a> A cron-like and not-cron-like job scheduler for Node.</li>\n</ul>\n<p><strong>异步</strong></p>\n<ul>\n<li><a href=\"https://github.com/caolan/async\" target=\"_blank\" rel=\"external\">async</a> Async utilities for node and the browser </li>\n</ul>\n<p><strong>锚点滚动</strong></p>\n<ul>\n<li><a href=\"https://github.com/cferdinandi/smooth-scroll\" target=\"_blank\" rel=\"external\">smooth-scroll</a> A lightweight script to animate scrolling to anchor links.</li>\n</ul>\n"},{"title":"一次FormData递归上传图片小记","date":"2017-08-14T12:09:48.000Z","author":"LoadingMore","_content":"## 问题\n最近项目开发中遇到一个多图上传的需求，后台给的接口支持FormData.[这里查看详情FormData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData)\n\n## 解决\n刚开始没有太好的办法，之前用formdata传图，都是固定的个数，对应唯一的filename参数名字，不会发生冲突，所以刚开始想到了for循环...结果就是能上传，但是顺序全部搞乱了，还有就是图片传的重复，缺失严重\n\n## 递归优化\n想着for循环也不能控制上传进度，所以采用了递归的思路\n```js\n// 伪代码\n$('#sleect_input').off().on('change',function(e){\n    var files = e.target.files,\n        resFiles = [];\n    // 收集files\n    for(var i=0;i<files.length;i++){\n        resFiles.push(files[i])\n    }\n\n    // 上传\n    $('#upLoad').on('click',function(){\n        // 递归\n        (function uploadFiles(){\n            var f = resFiles.shift();\n            if(f){\n                // 这里创建是为了避免重名导致上传混乱，每次都重新创建新的对象\n                var formdata = new FormData();\n                formdata.append('file',f);\n                $.ajax({\n                    url:'XXXXXXXXXXXXXXXXXXXXXX',\n                    type: \"POST\",\n                    data: formdata,\n                    processData: false,\n                    contentType: false,\n                }).always(function(){\n                    console.log(\"pending+正在上传\");\n                    // 继续下一步上传\n                    uploadFiles();\n                });\n            }else{\n                console.log(\"finished+上传完毕要做的事\");\n            }\n        })()\n    })\n})\n```\n至此，解决了多图片上传的问题\n","source":"_posts/一次FormData递归上传图片小记.md","raw":"---\ntitle: 一次FormData递归上传图片小记\ndate: 2017-08-14 20:09:48\ntags: [Javascript,'FormData']\nauthor: \"LoadingMore\"\n---\n## 问题\n最近项目开发中遇到一个多图上传的需求，后台给的接口支持FormData.[这里查看详情FormData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData)\n\n## 解决\n刚开始没有太好的办法，之前用formdata传图，都是固定的个数，对应唯一的filename参数名字，不会发生冲突，所以刚开始想到了for循环...结果就是能上传，但是顺序全部搞乱了，还有就是图片传的重复，缺失严重\n\n## 递归优化\n想着for循环也不能控制上传进度，所以采用了递归的思路\n```js\n// 伪代码\n$('#sleect_input').off().on('change',function(e){\n    var files = e.target.files,\n        resFiles = [];\n    // 收集files\n    for(var i=0;i<files.length;i++){\n        resFiles.push(files[i])\n    }\n\n    // 上传\n    $('#upLoad').on('click',function(){\n        // 递归\n        (function uploadFiles(){\n            var f = resFiles.shift();\n            if(f){\n                // 这里创建是为了避免重名导致上传混乱，每次都重新创建新的对象\n                var formdata = new FormData();\n                formdata.append('file',f);\n                $.ajax({\n                    url:'XXXXXXXXXXXXXXXXXXXXXX',\n                    type: \"POST\",\n                    data: formdata,\n                    processData: false,\n                    contentType: false,\n                }).always(function(){\n                    console.log(\"pending+正在上传\");\n                    // 继续下一步上传\n                    uploadFiles();\n                });\n            }else{\n                console.log(\"finished+上传完毕要做的事\");\n            }\n        })()\n    })\n})\n```\n至此，解决了多图片上传的问题\n","slug":"一次FormData递归上传图片小记","published":1,"updated":"2019-09-25T15:10:25.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pa003vla2emipgbhxd","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>最近项目开发中遇到一个多图上传的需求，后台给的接口支持FormData.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData\" target=\"_blank\" rel=\"external\">这里查看详情FormData</a></p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>刚开始没有太好的办法，之前用formdata传图，都是固定的个数，对应唯一的filename参数名字，不会发生冲突，所以刚开始想到了for循环…结果就是能上传，但是顺序全部搞乱了，还有就是图片传的重复，缺失严重</p>\n<h2 id=\"递归优化\"><a href=\"#递归优化\" class=\"headerlink\" title=\"递归优化\"></a>递归优化</h2><p>想着for循环也不能控制上传进度，所以采用了递归的思路</p>\n<pre><code class=\"js\">// 伪代码\n$(&#39;#sleect_input&#39;).off().on(&#39;change&#39;,function(e){\n    var files = e.target.files,\n        resFiles = [];\n    // 收集files\n    for(var i=0;i&lt;files.length;i++){\n        resFiles.push(files[i])\n    }\n\n    // 上传\n    $(&#39;#upLoad&#39;).on(&#39;click&#39;,function(){\n        // 递归\n        (function uploadFiles(){\n            var f = resFiles.shift();\n            if(f){\n                // 这里创建是为了避免重名导致上传混乱，每次都重新创建新的对象\n                var formdata = new FormData();\n                formdata.append(&#39;file&#39;,f);\n                $.ajax({\n                    url:&#39;XXXXXXXXXXXXXXXXXXXXXX&#39;,\n                    type: &quot;POST&quot;,\n                    data: formdata,\n                    processData: false,\n                    contentType: false,\n                }).always(function(){\n                    console.log(&quot;pending+正在上传&quot;);\n                    // 继续下一步上传\n                    uploadFiles();\n                });\n            }else{\n                console.log(&quot;finished+上传完毕要做的事&quot;);\n            }\n        })()\n    })\n})\n</code></pre>\n<p>至此，解决了多图片上传的问题</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>最近项目开发中遇到一个多图上传的需求，后台给的接口支持FormData.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData\" target=\"_blank\" rel=\"external\">这里查看详情FormData</a></p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>刚开始没有太好的办法，之前用formdata传图，都是固定的个数，对应唯一的filename参数名字，不会发生冲突，所以刚开始想到了for循环…结果就是能上传，但是顺序全部搞乱了，还有就是图片传的重复，缺失严重</p>\n<h2 id=\"递归优化\"><a href=\"#递归优化\" class=\"headerlink\" title=\"递归优化\"></a>递归优化</h2><p>想着for循环也不能控制上传进度，所以采用了递归的思路</p>\n<pre><code class=\"js\">// 伪代码\n$(&#39;#sleect_input&#39;).off().on(&#39;change&#39;,function(e){\n    var files = e.target.files,\n        resFiles = [];\n    // 收集files\n    for(var i=0;i&lt;files.length;i++){\n        resFiles.push(files[i])\n    }\n\n    // 上传\n    $(&#39;#upLoad&#39;).on(&#39;click&#39;,function(){\n        // 递归\n        (function uploadFiles(){\n            var f = resFiles.shift();\n            if(f){\n                // 这里创建是为了避免重名导致上传混乱，每次都重新创建新的对象\n                var formdata = new FormData();\n                formdata.append(&#39;file&#39;,f);\n                $.ajax({\n                    url:&#39;XXXXXXXXXXXXXXXXXXXXXX&#39;,\n                    type: &quot;POST&quot;,\n                    data: formdata,\n                    processData: false,\n                    contentType: false,\n                }).always(function(){\n                    console.log(&quot;pending+正在上传&quot;);\n                    // 继续下一步上传\n                    uploadFiles();\n                });\n            }else{\n                console.log(&quot;finished+上传完毕要做的事&quot;);\n            }\n        })()\n    })\n})\n</code></pre>\n<p>至此，解决了多图片上传的问题</p>\n"},{"title":"写的每条正则记录在册(持续更新)","date":"2017-03-20T14:45:12.000Z","_content":"> 正则这门语言实在是太强大,用的好可以大大减少工作量,大多时候会写很多重复类似的正则，处于爱护脑细胞的考虑，我决定从今往后的所写的正则,都记录下来.\n\n\n<!-- more -->\n### 不能纯字母数字 必须包含两者\n```javascript\nvar reg1 = /^(?=.*?[0-9])(?=.*?[a-z])[0-9a-z]+$/;\nvar reg2 = /(?!^[0-9]+$)(?!^[a-z]+$)^[0-9a-z]+$/;\n```\n\n### 不能纯字母数字  必须包含三者 (....发散下思维判断密码强弱的表达式)\n```javascript\nvar reg3 = /(?!^[0-9]+$)(?!^[a-z]+$)(?!^[_\\-@&=]]+$)^[0-9a-z_\\-@&=]+$/;\nvar reg4 = /^(?=.*?[0-9])(?=.*?[a-z])(?=.*?[_\\-@&=])[0-9a-z_\\-@&=]+$/;\n```\n### 药品库规格 药品规格 测试用例\n```javascript\n//ex:匹配如下\n//12*13  12mg*3 12mg*3 片(盒|粒)\n//0.12*12 7片*6盒\nvar reg = /^(([1-9]+\\d*(\\.\\d*)?)|(^0\\.[1-9]+\\d*))([a-zA-Zμ]*|[\\u4e00-\\u9fa5]*)*?\\*([1-9]+\\d*)[\\u4e00-\\u9fa5]*$/;\n```\n\n### 判断文件类型\n```javascript\nvar reg6 = /\\.(doc|png|image)$/;//等等 需要什么文件可以自动添加\n```\n\n### 排除指定字符\n```javascript\n//找出其中 包含 p 但不包含 ph 的所有单词，即\n//[ 'python', 'javascript', 'jsonp' ]\nvar web_development = \"python php ruby javascript jsonp perhapsphpisoutdated\";\nvar reg = /\\b(?=\\w*p)(?!\\w*ph)\\w+\\b/g\n```\n### 排除结尾不以什么字符结尾\n```javascript\n//不以is结尾的单词\nvar str =  `existing\n            pessimist\n            this\n            is\n            the\n            `;\nvar reg = /\\b\\w+[^is]$\\b/gm;//跨行\n```\n\n### 检测是否出现重复字符2个及以上(2017/4/6)\n```javascript\nfunction get(s){\n    // 例如aabcdf abbbdfsdf\n    var reg = /(.)\\1+/g;\n    //排序\n    s = s.split('');\n    s.sort();\n    s = s.join('');\n    //校验\n    if(reg.test(s)){\n        console.log(\"哎呀,碰到了重复字符\")\n    }\n}\nvar str = 'asfawertyha';\nget(str);\n```\n### 字符去重(2017/4/10)\n```javascript\nfunction get(s){\n    //排序\n    s = s.split('');\n    s.sort();\n    s = s.join('');\n    //该正则与上一条有区别\n    var reg = /(.)\\1*/g;\n    var tt = '';//存储新字符串\n    var m;//变量\n    while (m = reg.exec(s)){\n        tt += m[1];//循环去重\n    }\n    //返回去重后的字符\n    return tt;\n}\nvar str = 'asfaasdwesdfrtyha';\nget(str);\n//adefhrstwy\n```\n### 匹配1000-65535区间的数字(不包含9999)(2017/5/4)\n```javascript\nvar reg = /^(?!9999)([1-9]\\d{3}|[1-5]\\d{4}|6[0-5]{2}[0-3][0-5])$/;\n```\n### 链接巧妙取纯数字(2017/5/4)\n```javascript\nvar reg = /\\b\\d+\\b/;\n//test 尾数后面的纯数字，不出意外都可以取出来\nhttp://www.66play.com/Home/share/match/id/39455  \nhttp://www.66play.com/match-detail-151951\nhttp://www.66play.com/Home/share/match/id/148853?\n```\n","source":"_posts/从今天起写的每条正则都记录在册.md","raw":"---\ntitle: 写的每条正则记录在册(持续更新)\ndate: 2017-03-20 22:45:12\ntags: [javascript,'正则','RegExp']\ncategories: Javascript\n---\n> 正则这门语言实在是太强大,用的好可以大大减少工作量,大多时候会写很多重复类似的正则，处于爱护脑细胞的考虑，我决定从今往后的所写的正则,都记录下来.\n\n\n<!-- more -->\n### 不能纯字母数字 必须包含两者\n```javascript\nvar reg1 = /^(?=.*?[0-9])(?=.*?[a-z])[0-9a-z]+$/;\nvar reg2 = /(?!^[0-9]+$)(?!^[a-z]+$)^[0-9a-z]+$/;\n```\n\n### 不能纯字母数字  必须包含三者 (....发散下思维判断密码强弱的表达式)\n```javascript\nvar reg3 = /(?!^[0-9]+$)(?!^[a-z]+$)(?!^[_\\-@&=]]+$)^[0-9a-z_\\-@&=]+$/;\nvar reg4 = /^(?=.*?[0-9])(?=.*?[a-z])(?=.*?[_\\-@&=])[0-9a-z_\\-@&=]+$/;\n```\n### 药品库规格 药品规格 测试用例\n```javascript\n//ex:匹配如下\n//12*13  12mg*3 12mg*3 片(盒|粒)\n//0.12*12 7片*6盒\nvar reg = /^(([1-9]+\\d*(\\.\\d*)?)|(^0\\.[1-9]+\\d*))([a-zA-Zμ]*|[\\u4e00-\\u9fa5]*)*?\\*([1-9]+\\d*)[\\u4e00-\\u9fa5]*$/;\n```\n\n### 判断文件类型\n```javascript\nvar reg6 = /\\.(doc|png|image)$/;//等等 需要什么文件可以自动添加\n```\n\n### 排除指定字符\n```javascript\n//找出其中 包含 p 但不包含 ph 的所有单词，即\n//[ 'python', 'javascript', 'jsonp' ]\nvar web_development = \"python php ruby javascript jsonp perhapsphpisoutdated\";\nvar reg = /\\b(?=\\w*p)(?!\\w*ph)\\w+\\b/g\n```\n### 排除结尾不以什么字符结尾\n```javascript\n//不以is结尾的单词\nvar str =  `existing\n            pessimist\n            this\n            is\n            the\n            `;\nvar reg = /\\b\\w+[^is]$\\b/gm;//跨行\n```\n\n### 检测是否出现重复字符2个及以上(2017/4/6)\n```javascript\nfunction get(s){\n    // 例如aabcdf abbbdfsdf\n    var reg = /(.)\\1+/g;\n    //排序\n    s = s.split('');\n    s.sort();\n    s = s.join('');\n    //校验\n    if(reg.test(s)){\n        console.log(\"哎呀,碰到了重复字符\")\n    }\n}\nvar str = 'asfawertyha';\nget(str);\n```\n### 字符去重(2017/4/10)\n```javascript\nfunction get(s){\n    //排序\n    s = s.split('');\n    s.sort();\n    s = s.join('');\n    //该正则与上一条有区别\n    var reg = /(.)\\1*/g;\n    var tt = '';//存储新字符串\n    var m;//变量\n    while (m = reg.exec(s)){\n        tt += m[1];//循环去重\n    }\n    //返回去重后的字符\n    return tt;\n}\nvar str = 'asfaasdwesdfrtyha';\nget(str);\n//adefhrstwy\n```\n### 匹配1000-65535区间的数字(不包含9999)(2017/5/4)\n```javascript\nvar reg = /^(?!9999)([1-9]\\d{3}|[1-5]\\d{4}|6[0-5]{2}[0-3][0-5])$/;\n```\n### 链接巧妙取纯数字(2017/5/4)\n```javascript\nvar reg = /\\b\\d+\\b/;\n//test 尾数后面的纯数字，不出意外都可以取出来\nhttp://www.66play.com/Home/share/match/id/39455  \nhttp://www.66play.com/match-detail-151951\nhttp://www.66play.com/Home/share/match/id/148853?\n```\n","slug":"从今天起写的每条正则都记录在册","published":1,"updated":"2019-09-25T15:10:25.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pd0040la2ewi8he59s","content":"<blockquote>\n<p>正则这门语言实在是太强大,用的好可以大大减少工作量,大多时候会写很多重复类似的正则，处于爱护脑细胞的考虑，我决定从今往后的所写的正则,都记录下来.</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"不能纯字母数字-必须包含两者\"><a href=\"#不能纯字母数字-必须包含两者\" class=\"headerlink\" title=\"不能纯字母数字 必须包含两者\"></a>不能纯字母数字 必须包含两者</h3><pre><code class=\"javascript\">var reg1 = /^(?=.*?[0-9])(?=.*?[a-z])[0-9a-z]+$/;\nvar reg2 = /(?!^[0-9]+$)(?!^[a-z]+$)^[0-9a-z]+$/;\n</code></pre>\n<h3 id=\"不能纯字母数字-必须包含三者-…-发散下思维判断密码强弱的表达式\"><a href=\"#不能纯字母数字-必须包含三者-…-发散下思维判断密码强弱的表达式\" class=\"headerlink\" title=\"不能纯字母数字  必须包含三者 (….发散下思维判断密码强弱的表达式)\"></a>不能纯字母数字  必须包含三者 (….发散下思维判断密码强弱的表达式)</h3><pre><code class=\"javascript\">var reg3 = /(?!^[0-9]+$)(?!^[a-z]+$)(?!^[_\\-@&amp;=]]+$)^[0-9a-z_\\-@&amp;=]+$/;\nvar reg4 = /^(?=.*?[0-9])(?=.*?[a-z])(?=.*?[_\\-@&amp;=])[0-9a-z_\\-@&amp;=]+$/;\n</code></pre>\n<h3 id=\"药品库规格-药品规格-测试用例\"><a href=\"#药品库规格-药品规格-测试用例\" class=\"headerlink\" title=\"药品库规格 药品规格 测试用例\"></a>药品库规格 药品规格 测试用例</h3><pre><code class=\"javascript\">//ex:匹配如下\n//12*13  12mg*3 12mg*3 片(盒|粒)\n//0.12*12 7片*6盒\nvar reg = /^(([1-9]+\\d*(\\.\\d*)?)|(^0\\.[1-9]+\\d*))([a-zA-Zμ]*|[\\u4e00-\\u9fa5]*)*?\\*([1-9]+\\d*)[\\u4e00-\\u9fa5]*$/;\n</code></pre>\n<h3 id=\"判断文件类型\"><a href=\"#判断文件类型\" class=\"headerlink\" title=\"判断文件类型\"></a>判断文件类型</h3><pre><code class=\"javascript\">var reg6 = /\\.(doc|png|image)$/;//等等 需要什么文件可以自动添加\n</code></pre>\n<h3 id=\"排除指定字符\"><a href=\"#排除指定字符\" class=\"headerlink\" title=\"排除指定字符\"></a>排除指定字符</h3><pre><code class=\"javascript\">//找出其中 包含 p 但不包含 ph 的所有单词，即\n//[ &#39;python&#39;, &#39;javascript&#39;, &#39;jsonp&#39; ]\nvar web_development = &quot;python php ruby javascript jsonp perhapsphpisoutdated&quot;;\nvar reg = /\\b(?=\\w*p)(?!\\w*ph)\\w+\\b/g\n</code></pre>\n<h3 id=\"排除结尾不以什么字符结尾\"><a href=\"#排除结尾不以什么字符结尾\" class=\"headerlink\" title=\"排除结尾不以什么字符结尾\"></a>排除结尾不以什么字符结尾</h3><pre><code class=\"javascript\">//不以is结尾的单词\nvar str =  `existing\n            pessimist\n            this\n            is\n            the\n            `;\nvar reg = /\\b\\w+[^is]$\\b/gm;//跨行\n</code></pre>\n<h3 id=\"检测是否出现重复字符2个及以上-2017-4-6\"><a href=\"#检测是否出现重复字符2个及以上-2017-4-6\" class=\"headerlink\" title=\"检测是否出现重复字符2个及以上(2017/4/6)\"></a>检测是否出现重复字符2个及以上(2017/4/6)</h3><pre><code class=\"javascript\">function get(s){\n    // 例如aabcdf abbbdfsdf\n    var reg = /(.)\\1+/g;\n    //排序\n    s = s.split(&#39;&#39;);\n    s.sort();\n    s = s.join(&#39;&#39;);\n    //校验\n    if(reg.test(s)){\n        console.log(&quot;哎呀,碰到了重复字符&quot;)\n    }\n}\nvar str = &#39;asfawertyha&#39;;\nget(str);\n</code></pre>\n<h3 id=\"字符去重-2017-4-10\"><a href=\"#字符去重-2017-4-10\" class=\"headerlink\" title=\"字符去重(2017/4/10)\"></a>字符去重(2017/4/10)</h3><pre><code class=\"javascript\">function get(s){\n    //排序\n    s = s.split(&#39;&#39;);\n    s.sort();\n    s = s.join(&#39;&#39;);\n    //该正则与上一条有区别\n    var reg = /(.)\\1*/g;\n    var tt = &#39;&#39;;//存储新字符串\n    var m;//变量\n    while (m = reg.exec(s)){\n        tt += m[1];//循环去重\n    }\n    //返回去重后的字符\n    return tt;\n}\nvar str = &#39;asfaasdwesdfrtyha&#39;;\nget(str);\n//adefhrstwy\n</code></pre>\n<h3 id=\"匹配1000-65535区间的数字-不包含9999-2017-5-4\"><a href=\"#匹配1000-65535区间的数字-不包含9999-2017-5-4\" class=\"headerlink\" title=\"匹配1000-65535区间的数字(不包含9999)(2017/5/4)\"></a>匹配1000-65535区间的数字(不包含9999)(2017/5/4)</h3><pre><code class=\"javascript\">var reg = /^(?!9999)([1-9]\\d{3}|[1-5]\\d{4}|6[0-5]{2}[0-3][0-5])$/;\n</code></pre>\n<h3 id=\"链接巧妙取纯数字-2017-5-4\"><a href=\"#链接巧妙取纯数字-2017-5-4\" class=\"headerlink\" title=\"链接巧妙取纯数字(2017/5/4)\"></a>链接巧妙取纯数字(2017/5/4)</h3><pre><code class=\"javascript\">var reg = /\\b\\d+\\b/;\n//test 尾数后面的纯数字，不出意外都可以取出来\nhttp://www.66play.com/Home/share/match/id/39455  \nhttp://www.66play.com/match-detail-151951\nhttp://www.66play.com/Home/share/match/id/148853?\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>正则这门语言实在是太强大,用的好可以大大减少工作量,大多时候会写很多重复类似的正则，处于爱护脑细胞的考虑，我决定从今往后的所写的正则,都记录下来.</p>\n</blockquote>","more":"<h3 id=\"不能纯字母数字-必须包含两者\"><a href=\"#不能纯字母数字-必须包含两者\" class=\"headerlink\" title=\"不能纯字母数字 必须包含两者\"></a>不能纯字母数字 必须包含两者</h3><pre><code class=\"javascript\">var reg1 = /^(?=.*?[0-9])(?=.*?[a-z])[0-9a-z]+$/;\nvar reg2 = /(?!^[0-9]+$)(?!^[a-z]+$)^[0-9a-z]+$/;\n</code></pre>\n<h3 id=\"不能纯字母数字-必须包含三者-…-发散下思维判断密码强弱的表达式\"><a href=\"#不能纯字母数字-必须包含三者-…-发散下思维判断密码强弱的表达式\" class=\"headerlink\" title=\"不能纯字母数字  必须包含三者 (….发散下思维判断密码强弱的表达式)\"></a>不能纯字母数字  必须包含三者 (….发散下思维判断密码强弱的表达式)</h3><pre><code class=\"javascript\">var reg3 = /(?!^[0-9]+$)(?!^[a-z]+$)(?!^[_\\-@&amp;=]]+$)^[0-9a-z_\\-@&amp;=]+$/;\nvar reg4 = /^(?=.*?[0-9])(?=.*?[a-z])(?=.*?[_\\-@&amp;=])[0-9a-z_\\-@&amp;=]+$/;\n</code></pre>\n<h3 id=\"药品库规格-药品规格-测试用例\"><a href=\"#药品库规格-药品规格-测试用例\" class=\"headerlink\" title=\"药品库规格 药品规格 测试用例\"></a>药品库规格 药品规格 测试用例</h3><pre><code class=\"javascript\">//ex:匹配如下\n//12*13  12mg*3 12mg*3 片(盒|粒)\n//0.12*12 7片*6盒\nvar reg = /^(([1-9]+\\d*(\\.\\d*)?)|(^0\\.[1-9]+\\d*))([a-zA-Zμ]*|[\\u4e00-\\u9fa5]*)*?\\*([1-9]+\\d*)[\\u4e00-\\u9fa5]*$/;\n</code></pre>\n<h3 id=\"判断文件类型\"><a href=\"#判断文件类型\" class=\"headerlink\" title=\"判断文件类型\"></a>判断文件类型</h3><pre><code class=\"javascript\">var reg6 = /\\.(doc|png|image)$/;//等等 需要什么文件可以自动添加\n</code></pre>\n<h3 id=\"排除指定字符\"><a href=\"#排除指定字符\" class=\"headerlink\" title=\"排除指定字符\"></a>排除指定字符</h3><pre><code class=\"javascript\">//找出其中 包含 p 但不包含 ph 的所有单词，即\n//[ &#39;python&#39;, &#39;javascript&#39;, &#39;jsonp&#39; ]\nvar web_development = &quot;python php ruby javascript jsonp perhapsphpisoutdated&quot;;\nvar reg = /\\b(?=\\w*p)(?!\\w*ph)\\w+\\b/g\n</code></pre>\n<h3 id=\"排除结尾不以什么字符结尾\"><a href=\"#排除结尾不以什么字符结尾\" class=\"headerlink\" title=\"排除结尾不以什么字符结尾\"></a>排除结尾不以什么字符结尾</h3><pre><code class=\"javascript\">//不以is结尾的单词\nvar str =  `existing\n            pessimist\n            this\n            is\n            the\n            `;\nvar reg = /\\b\\w+[^is]$\\b/gm;//跨行\n</code></pre>\n<h3 id=\"检测是否出现重复字符2个及以上-2017-4-6\"><a href=\"#检测是否出现重复字符2个及以上-2017-4-6\" class=\"headerlink\" title=\"检测是否出现重复字符2个及以上(2017/4/6)\"></a>检测是否出现重复字符2个及以上(2017/4/6)</h3><pre><code class=\"javascript\">function get(s){\n    // 例如aabcdf abbbdfsdf\n    var reg = /(.)\\1+/g;\n    //排序\n    s = s.split(&#39;&#39;);\n    s.sort();\n    s = s.join(&#39;&#39;);\n    //校验\n    if(reg.test(s)){\n        console.log(&quot;哎呀,碰到了重复字符&quot;)\n    }\n}\nvar str = &#39;asfawertyha&#39;;\nget(str);\n</code></pre>\n<h3 id=\"字符去重-2017-4-10\"><a href=\"#字符去重-2017-4-10\" class=\"headerlink\" title=\"字符去重(2017/4/10)\"></a>字符去重(2017/4/10)</h3><pre><code class=\"javascript\">function get(s){\n    //排序\n    s = s.split(&#39;&#39;);\n    s.sort();\n    s = s.join(&#39;&#39;);\n    //该正则与上一条有区别\n    var reg = /(.)\\1*/g;\n    var tt = &#39;&#39;;//存储新字符串\n    var m;//变量\n    while (m = reg.exec(s)){\n        tt += m[1];//循环去重\n    }\n    //返回去重后的字符\n    return tt;\n}\nvar str = &#39;asfaasdwesdfrtyha&#39;;\nget(str);\n//adefhrstwy\n</code></pre>\n<h3 id=\"匹配1000-65535区间的数字-不包含9999-2017-5-4\"><a href=\"#匹配1000-65535区间的数字-不包含9999-2017-5-4\" class=\"headerlink\" title=\"匹配1000-65535区间的数字(不包含9999)(2017/5/4)\"></a>匹配1000-65535区间的数字(不包含9999)(2017/5/4)</h3><pre><code class=\"javascript\">var reg = /^(?!9999)([1-9]\\d{3}|[1-5]\\d{4}|6[0-5]{2}[0-3][0-5])$/;\n</code></pre>\n<h3 id=\"链接巧妙取纯数字-2017-5-4\"><a href=\"#链接巧妙取纯数字-2017-5-4\" class=\"headerlink\" title=\"链接巧妙取纯数字(2017/5/4)\"></a>链接巧妙取纯数字(2017/5/4)</h3><pre><code class=\"javascript\">var reg = /\\b\\d+\\b/;\n//test 尾数后面的纯数字，不出意外都可以取出来\nhttp://www.66play.com/Home/share/match/id/39455  \nhttp://www.66play.com/match-detail-151951\nhttp://www.66play.com/Home/share/match/id/148853?\n</code></pre>"},{"title":"写个正则匹配url参数的字典(方便提取查询参数)","date":"2017-04-04T14:38:00.000Z","_content":"> 项目经常会用到提取地址栏的参数的问题，之前都是随用随写，这不趁着放假，总结了一下\n\n<!-- more -->\n### 我的版本\n```javascript\nfunction getUrlPart(url){\n    url = url == null ? window.location.href : url;\n    var str = url.substring(url.indexOf('?')+1);\n    // 或者 var str = url.split('?')[1];也可以拿到?后面参数\n    var reg = /([^?&=]+)=([^?&=]+)/gi;\n    var m,res = {};\n    while (m = reg.exec(str)){\n        res[m[1]] = m[2];\n    }\n    return res;\n}\n```\n### 来个高程三的版本\n```javascript\nfunction getQueryStringArgs(){\n    //取得查询字符串并渠道开头问好\n    var qs = (location.search.length > 0 ? location.search.substring(1) : \"\"),\n\n    //保存数据对象\n    args = {},\n\n    //取得每一项\n    items = qs.length ? qs.split(\"&\") : [],\n    item = null,\n    name = null,\n    value = null,\n\n    //for循环中使用\n    i = 0,\n    len = items.length;\n\n    for(i=0;i<len;i++){\n        item = items[i].split(\"=\");\n        name = decodeURIComponent(item[0]);\n        value = decodeURIComponent(item[1]);\n\n        if(name.length){\n            args[name] = value;\n        }\n    }\n    return args;\n}\n```\n","source":"_posts/写个正则匹配url参数的字典-方便提取查询参数.md","raw":"---\ntitle: 写个正则匹配url参数的字典(方便提取查询参数)\ndate: 2017-04-04 22:38:00\ntags: [javascript,'正则','RegExp','查询参数']\ncategories: Javascript\n---\n> 项目经常会用到提取地址栏的参数的问题，之前都是随用随写，这不趁着放假，总结了一下\n\n<!-- more -->\n### 我的版本\n```javascript\nfunction getUrlPart(url){\n    url = url == null ? window.location.href : url;\n    var str = url.substring(url.indexOf('?')+1);\n    // 或者 var str = url.split('?')[1];也可以拿到?后面参数\n    var reg = /([^?&=]+)=([^?&=]+)/gi;\n    var m,res = {};\n    while (m = reg.exec(str)){\n        res[m[1]] = m[2];\n    }\n    return res;\n}\n```\n### 来个高程三的版本\n```javascript\nfunction getQueryStringArgs(){\n    //取得查询字符串并渠道开头问好\n    var qs = (location.search.length > 0 ? location.search.substring(1) : \"\"),\n\n    //保存数据对象\n    args = {},\n\n    //取得每一项\n    items = qs.length ? qs.split(\"&\") : [],\n    item = null,\n    name = null,\n    value = null,\n\n    //for循环中使用\n    i = 0,\n    len = items.length;\n\n    for(i=0;i<len;i++){\n        item = items[i].split(\"=\");\n        name = decodeURIComponent(item[0]);\n        value = decodeURIComponent(item[1]);\n\n        if(name.length){\n            args[name] = value;\n        }\n    }\n    return args;\n}\n```\n","slug":"写个正则匹配url参数的字典-方便提取查询参数","published":1,"updated":"2019-09-25T15:10:25.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pe0043la2eco6j3thh","content":"<blockquote>\n<p>项目经常会用到提取地址栏的参数的问题，之前都是随用随写，这不趁着放假，总结了一下</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"我的版本\"><a href=\"#我的版本\" class=\"headerlink\" title=\"我的版本\"></a>我的版本</h3><pre><code class=\"javascript\">function getUrlPart(url){\n    url = url == null ? window.location.href : url;\n    var str = url.substring(url.indexOf(&#39;?&#39;)+1);\n    // 或者 var str = url.split(&#39;?&#39;)[1];也可以拿到?后面参数\n    var reg = /([^?&amp;=]+)=([^?&amp;=]+)/gi;\n    var m,res = {};\n    while (m = reg.exec(str)){\n        res[m[1]] = m[2];\n    }\n    return res;\n}\n</code></pre>\n<h3 id=\"来个高程三的版本\"><a href=\"#来个高程三的版本\" class=\"headerlink\" title=\"来个高程三的版本\"></a>来个高程三的版本</h3><pre><code class=\"javascript\">function getQueryStringArgs(){\n    //取得查询字符串并渠道开头问好\n    var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;),\n\n    //保存数据对象\n    args = {},\n\n    //取得每一项\n    items = qs.length ? qs.split(&quot;&amp;&quot;) : [],\n    item = null,\n    name = null,\n    value = null,\n\n    //for循环中使用\n    i = 0,\n    len = items.length;\n\n    for(i=0;i&lt;len;i++){\n        item = items[i].split(&quot;=&quot;);\n        name = decodeURIComponent(item[0]);\n        value = decodeURIComponent(item[1]);\n\n        if(name.length){\n            args[name] = value;\n        }\n    }\n    return args;\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>项目经常会用到提取地址栏的参数的问题，之前都是随用随写，这不趁着放假，总结了一下</p>\n</blockquote>","more":"<h3 id=\"我的版本\"><a href=\"#我的版本\" class=\"headerlink\" title=\"我的版本\"></a>我的版本</h3><pre><code class=\"javascript\">function getUrlPart(url){\n    url = url == null ? window.location.href : url;\n    var str = url.substring(url.indexOf(&#39;?&#39;)+1);\n    // 或者 var str = url.split(&#39;?&#39;)[1];也可以拿到?后面参数\n    var reg = /([^?&amp;=]+)=([^?&amp;=]+)/gi;\n    var m,res = {};\n    while (m = reg.exec(str)){\n        res[m[1]] = m[2];\n    }\n    return res;\n}\n</code></pre>\n<h3 id=\"来个高程三的版本\"><a href=\"#来个高程三的版本\" class=\"headerlink\" title=\"来个高程三的版本\"></a>来个高程三的版本</h3><pre><code class=\"javascript\">function getQueryStringArgs(){\n    //取得查询字符串并渠道开头问好\n    var qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;),\n\n    //保存数据对象\n    args = {},\n\n    //取得每一项\n    items = qs.length ? qs.split(&quot;&amp;&quot;) : [],\n    item = null,\n    name = null,\n    value = null,\n\n    //for循环中使用\n    i = 0,\n    len = items.length;\n\n    for(i=0;i&lt;len;i++){\n        item = items[i].split(&quot;=&quot;);\n        name = decodeURIComponent(item[0]);\n        value = decodeURIComponent(item[1]);\n\n        if(name.length){\n            args[name] = value;\n        }\n    }\n    return args;\n}\n</code></pre>"},{"title":"利用TravisCi自动部署博客到gitPage","date":"2018-09-18T09:32:00.000Z","_content":"\n> 一篇测试文档，测试自动部署gitPage，稍后会写篇博客进行记录,先温习下git\n\n### 创建本地分支\n* **git branch 分支名**\n  eg: git branch dev 基于当前的分支创建本地分支\n\n### 切换到本地分支\n* **git checkout 分支名**\n  eg: git checkout dev 切换到dev分支\n\n### 创建并切换到本地分支\n* **git checkout -b 分支名**\n  eg: git checkout -b dev，这条命令把创建本地分支和切换到该分支的功能结合起来了，即基于当前分支master创建本地分支dev并切换到该分支下\n\n### 删除分支\n* **git branch -d 分支名**\n  eg: git branch -d dev 删除本地dev分支\n\n### 删除未提交分支\n* **git branch -D 分支名**\n  eg: git branch -D dev 强制删除本地dev分支\n\n### 合并分支\n合并dev到master\n* **git checkout master**  # 切换到master分支\n* **git merge 分支名** # 合并该分支到master\n\n### 提交本地分支到远程仓库\n* **git push origin 远程仓库名**\n  eg: git push origin dev，这条命令表示把本地dev分支提交到远程仓库，即创建了远程分支dev\n\n## 基于远程分支新建本地分支\n* **git checkout -b 本地分支 origin/远程分支**\n  eg: git checkout -b dev origin/dev\n\n### 新建本地分支与远程分支关联\n* **git branch --set-upstream dev origin/dev**\n  eg: git branch –set-upstream dev origin/dev，把本地dev分支和远程dev分支相关联\n\n注意：本地新建分支， push到远程服务器上之后，使用git pull或者git pull 拉取或提交数据时会报错，必须使用命令：git pull origin dev（指定远程分支）；如果想直接使用git pull或git push拉去提交数据就必须创建本地分支与远程分支的关联\n\n\n\n\n\n\n","source":"_posts/利用TravisCi自动部署博客到gitPage.md","raw":"---\ntitle: 利用TravisCi自动部署博客到gitPage\ndate: 2018-09-18 17:32:00\ntags: ['hexo', 'Travis-CI']\ncategories: Javascript\n---\n\n> 一篇测试文档，测试自动部署gitPage，稍后会写篇博客进行记录,先温习下git\n\n### 创建本地分支\n* **git branch 分支名**\n  eg: git branch dev 基于当前的分支创建本地分支\n\n### 切换到本地分支\n* **git checkout 分支名**\n  eg: git checkout dev 切换到dev分支\n\n### 创建并切换到本地分支\n* **git checkout -b 分支名**\n  eg: git checkout -b dev，这条命令把创建本地分支和切换到该分支的功能结合起来了，即基于当前分支master创建本地分支dev并切换到该分支下\n\n### 删除分支\n* **git branch -d 分支名**\n  eg: git branch -d dev 删除本地dev分支\n\n### 删除未提交分支\n* **git branch -D 分支名**\n  eg: git branch -D dev 强制删除本地dev分支\n\n### 合并分支\n合并dev到master\n* **git checkout master**  # 切换到master分支\n* **git merge 分支名** # 合并该分支到master\n\n### 提交本地分支到远程仓库\n* **git push origin 远程仓库名**\n  eg: git push origin dev，这条命令表示把本地dev分支提交到远程仓库，即创建了远程分支dev\n\n## 基于远程分支新建本地分支\n* **git checkout -b 本地分支 origin/远程分支**\n  eg: git checkout -b dev origin/dev\n\n### 新建本地分支与远程分支关联\n* **git branch --set-upstream dev origin/dev**\n  eg: git branch –set-upstream dev origin/dev，把本地dev分支和远程dev分支相关联\n\n注意：本地新建分支， push到远程服务器上之后，使用git pull或者git pull 拉取或提交数据时会报错，必须使用命令：git pull origin dev（指定远程分支）；如果想直接使用git pull或git push拉去提交数据就必须创建本地分支与远程分支的关联\n\n\n\n\n\n\n","slug":"利用TravisCi自动部署博客到gitPage","published":1,"updated":"2019-09-25T15:10:25.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pg0047la2eh34d7hq0","content":"<blockquote>\n<p>一篇测试文档，测试自动部署gitPage，稍后会写篇博客进行记录,先温习下git</p>\n</blockquote>\n<h3 id=\"创建本地分支\"><a href=\"#创建本地分支\" class=\"headerlink\" title=\"创建本地分支\"></a>创建本地分支</h3><ul>\n<li><strong>git branch 分支名</strong><br>eg: git branch dev 基于当前的分支创建本地分支</li>\n</ul>\n<h3 id=\"切换到本地分支\"><a href=\"#切换到本地分支\" class=\"headerlink\" title=\"切换到本地分支\"></a>切换到本地分支</h3><ul>\n<li><strong>git checkout 分支名</strong><br>eg: git checkout dev 切换到dev分支</li>\n</ul>\n<h3 id=\"创建并切换到本地分支\"><a href=\"#创建并切换到本地分支\" class=\"headerlink\" title=\"创建并切换到本地分支\"></a>创建并切换到本地分支</h3><ul>\n<li><strong>git checkout -b 分支名</strong><br>eg: git checkout -b dev，这条命令把创建本地分支和切换到该分支的功能结合起来了，即基于当前分支master创建本地分支dev并切换到该分支下</li>\n</ul>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><ul>\n<li><strong>git branch -d 分支名</strong><br>eg: git branch -d dev 删除本地dev分支</li>\n</ul>\n<h3 id=\"删除未提交分支\"><a href=\"#删除未提交分支\" class=\"headerlink\" title=\"删除未提交分支\"></a>删除未提交分支</h3><ul>\n<li><strong>git branch -D 分支名</strong><br>eg: git branch -D dev 强制删除本地dev分支</li>\n</ul>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><p>合并dev到master</p>\n<ul>\n<li><strong>git checkout master</strong>  # 切换到master分支</li>\n<li><strong>git merge 分支名</strong> # 合并该分支到master</li>\n</ul>\n<h3 id=\"提交本地分支到远程仓库\"><a href=\"#提交本地分支到远程仓库\" class=\"headerlink\" title=\"提交本地分支到远程仓库\"></a>提交本地分支到远程仓库</h3><ul>\n<li><strong>git push origin 远程仓库名</strong><br>eg: git push origin dev，这条命令表示把本地dev分支提交到远程仓库，即创建了远程分支dev</li>\n</ul>\n<h2 id=\"基于远程分支新建本地分支\"><a href=\"#基于远程分支新建本地分支\" class=\"headerlink\" title=\"基于远程分支新建本地分支\"></a>基于远程分支新建本地分支</h2><ul>\n<li><strong>git checkout -b 本地分支 origin/远程分支</strong><br>eg: git checkout -b dev origin/dev</li>\n</ul>\n<h3 id=\"新建本地分支与远程分支关联\"><a href=\"#新建本地分支与远程分支关联\" class=\"headerlink\" title=\"新建本地分支与远程分支关联\"></a>新建本地分支与远程分支关联</h3><ul>\n<li><strong>git branch –set-upstream dev origin/dev</strong><br>eg: git branch –set-upstream dev origin/dev，把本地dev分支和远程dev分支相关联</li>\n</ul>\n<p>注意：本地新建分支， push到远程服务器上之后，使用git pull或者git pull 拉取或提交数据时会报错，必须使用命令：git pull origin dev（指定远程分支）；如果想直接使用git pull或git push拉去提交数据就必须创建本地分支与远程分支的关联</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一篇测试文档，测试自动部署gitPage，稍后会写篇博客进行记录,先温习下git</p>\n</blockquote>\n<h3 id=\"创建本地分支\"><a href=\"#创建本地分支\" class=\"headerlink\" title=\"创建本地分支\"></a>创建本地分支</h3><ul>\n<li><strong>git branch 分支名</strong><br>eg: git branch dev 基于当前的分支创建本地分支</li>\n</ul>\n<h3 id=\"切换到本地分支\"><a href=\"#切换到本地分支\" class=\"headerlink\" title=\"切换到本地分支\"></a>切换到本地分支</h3><ul>\n<li><strong>git checkout 分支名</strong><br>eg: git checkout dev 切换到dev分支</li>\n</ul>\n<h3 id=\"创建并切换到本地分支\"><a href=\"#创建并切换到本地分支\" class=\"headerlink\" title=\"创建并切换到本地分支\"></a>创建并切换到本地分支</h3><ul>\n<li><strong>git checkout -b 分支名</strong><br>eg: git checkout -b dev，这条命令把创建本地分支和切换到该分支的功能结合起来了，即基于当前分支master创建本地分支dev并切换到该分支下</li>\n</ul>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><ul>\n<li><strong>git branch -d 分支名</strong><br>eg: git branch -d dev 删除本地dev分支</li>\n</ul>\n<h3 id=\"删除未提交分支\"><a href=\"#删除未提交分支\" class=\"headerlink\" title=\"删除未提交分支\"></a>删除未提交分支</h3><ul>\n<li><strong>git branch -D 分支名</strong><br>eg: git branch -D dev 强制删除本地dev分支</li>\n</ul>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><p>合并dev到master</p>\n<ul>\n<li><strong>git checkout master</strong>  # 切换到master分支</li>\n<li><strong>git merge 分支名</strong> # 合并该分支到master</li>\n</ul>\n<h3 id=\"提交本地分支到远程仓库\"><a href=\"#提交本地分支到远程仓库\" class=\"headerlink\" title=\"提交本地分支到远程仓库\"></a>提交本地分支到远程仓库</h3><ul>\n<li><strong>git push origin 远程仓库名</strong><br>eg: git push origin dev，这条命令表示把本地dev分支提交到远程仓库，即创建了远程分支dev</li>\n</ul>\n<h2 id=\"基于远程分支新建本地分支\"><a href=\"#基于远程分支新建本地分支\" class=\"headerlink\" title=\"基于远程分支新建本地分支\"></a>基于远程分支新建本地分支</h2><ul>\n<li><strong>git checkout -b 本地分支 origin/远程分支</strong><br>eg: git checkout -b dev origin/dev</li>\n</ul>\n<h3 id=\"新建本地分支与远程分支关联\"><a href=\"#新建本地分支与远程分支关联\" class=\"headerlink\" title=\"新建本地分支与远程分支关联\"></a>新建本地分支与远程分支关联</h3><ul>\n<li><strong>git branch –set-upstream dev origin/dev</strong><br>eg: git branch –set-upstream dev origin/dev，把本地dev分支和远程dev分支相关联</li>\n</ul>\n<p>注意：本地新建分支， push到远程服务器上之后，使用git pull或者git pull 拉取或提交数据时会报错，必须使用命令：git pull origin dev（指定远程分支）；如果想直接使用git pull或git push拉去提交数据就必须创建本地分支与远程分支的关联</p>\n"},{"title":"原生JS模拟点击事件和自定义事件","date":"2017-06-11T08:46:45.000Z","author":"Yuqi Bi","header-img":"form-opts.png","cdn":"header-on","_content":"> 事件，就是网页中某个特别值得关注的瞬间，事件是经常有用户操作或通过其他浏览器功能来触发，但是很少有人知道，也可以使用javascript来在任意时刻触发特定事件，此时事件如同浏览器创建的事件一样。 ------ 《高级程序设计3》\n\n## 高程三的实现方法\n模拟点击事件应该是一个很常见的行为，经常用jQ来实现，今天研究下原生js如何模拟触发点击事件\n```js\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n    </head>\n    <body>\n        <div id=\"container\">\n            点击\n        </div>\n        <script>\n            var doms = document.querySelector('#container')\n            doms.addEventListener('click',function(){\n                console.log(\"莫名其妙被点击\")\n            })\n            // 使用createEvent() 创建event事件 传入鼠标事件字符串 MouseEvents\n            var events = document.createEvent(\"MouseEvents\")\n            // 返回的对象有一个名为 initMouseEvent()方法 用于指定与该鼠标售价仅有关的信息\n            events.initMouseEvent(\"click\",true,true,document.defaultView)\n            // 最后一步触发事件 dispatchEvent()\n            doms.dispatchEvent(events)\n        </script>\n    </body>\n</html>\n```\n很遗憾的是，在我查过MDN后，得知该方法已经废弃\n** 注：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 **\n\n## MDN MouseEvent()\nMDN上已经说得很清楚,尽管为了保持向后兼容MouseEvent.initMouseEvent()仍然可用,但是呢,我们应该使用MouseEvent().\n```js\n语法：event = new MouseEvent(typeArg, mouseEventInit);\n```\n```js\nvar doms = document.querySelector('#container')\ndoms.addEventListener('click',function(){\n    console.log(\"莫名其妙被点击\")\n})\n// 创建模拟对象\nvar events = new MouseEvent(\"click\",{\n    bubbles:true,\n    cancelable:true,\n    view:window\n})\n// 最后一步触发事件 dispatchEvent()\ndoms.dispatchEvent(events)\n\n// 至此 我们的自动触发事件已经完成 控制台已经打印：莫名其妙被点击\n```\ntypeArg|DOMString 格式的事件名称。\n------------ | ----------\nmouseEventInit | 可选\n更多的属性请看这里[点击查看](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/MouseEvent#浏览器兼容性)\n\n## IE兼容\n```js\nvar doms = document.getElementById('container');\n// 注意低版本ie兼容\ndoms.attachEvent('onclick', function () {\n    console.log(\"莫名其妙被点击\")\n});\n\n// 创建事件对象\nvar event = document.createEventObject()\n// 触发\ndoms.fireEvent('onclick',event)\n```\n先创建enent对象，然后为其制定相应的信息，然后触发事件\nfireEvent()方法会自动为event对象添加scrElement和type属性，其他属性都必须手动添加\n\n## 创建自定义事件\n** 自定义事件有两种方法,一种是使用new Event(),另一种是new customEvent() **\n```js\nvar doms = document.getElementById('container');\n// 创建自定义事件\nvar event = new Event('build',{\n      bubbles: 'true',\n      cancelable: 'true'\n});\n\n// 监听事件\ndoms.addEventListener('build', function (e) {\n    console.log(\"测试自定义事件\")\n}, false);\n\n// 触发事件.\ndoms.dispatchEvent(event);\n// 控制台\n// 测试自定义事件\n```\n\n```js\nvar doms = document.getElementById('container');\n// 创建自定义事件\nvar event = new CustomEvent('build',{\n      bubbles: 'true', //一个布尔值,表明该事件是否会冒泡.\n      cancelable: 'true', //一个布尔值,表明该事件是否可以被取消.\n      detail:\"我是测试数据\" //当事件初始化时传递的数据.\n});\n\n// 监听事件\ndoms.addEventListener('build', function (e) {\n    console.log(\"测试自定义事件\")\n    console.log(e.detail)\n}, false);\n\n// 触发事件.\ndoms.dispatchEvent(event);\n// 控制台\n// 测试自定义事件\n```\n可以很明显的看到,其实new customEvent()比new Event()多了可以在event.detail属性里携带自定义数据的功能\n\n绝大多数现代浏览器中都会支持这个构造函数（Internet Explorer例外）。 要了解更为复杂的方法，可参考下面的 [过时的方法](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events)。\n[customEvent()](https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent)和[ Event()](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event) MDN链接在此\n\n总结下来发现,除了模拟自定义事件比较好用,兼容性还可以，模拟鼠标事件兼容性各方面都支持的不太好，DOM这块水很深啊，继续研究...\n","source":"_posts/原生JS模拟点击事件和自定义事件.md","raw":"---\ntitle: 原生JS模拟点击事件和自定义事件\ndate: 2017-06-11 16:46:45\ntags: [javascript]\nauthor: \"Yuqi Bi\"\nheader-img: \"form-opts.png\"\ncdn: 'header-on'\n---\n> 事件，就是网页中某个特别值得关注的瞬间，事件是经常有用户操作或通过其他浏览器功能来触发，但是很少有人知道，也可以使用javascript来在任意时刻触发特定事件，此时事件如同浏览器创建的事件一样。 ------ 《高级程序设计3》\n\n## 高程三的实现方法\n模拟点击事件应该是一个很常见的行为，经常用jQ来实现，今天研究下原生js如何模拟触发点击事件\n```js\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <title></title>\n    </head>\n    <body>\n        <div id=\"container\">\n            点击\n        </div>\n        <script>\n            var doms = document.querySelector('#container')\n            doms.addEventListener('click',function(){\n                console.log(\"莫名其妙被点击\")\n            })\n            // 使用createEvent() 创建event事件 传入鼠标事件字符串 MouseEvents\n            var events = document.createEvent(\"MouseEvents\")\n            // 返回的对象有一个名为 initMouseEvent()方法 用于指定与该鼠标售价仅有关的信息\n            events.initMouseEvent(\"click\",true,true,document.defaultView)\n            // 最后一步触发事件 dispatchEvent()\n            doms.dispatchEvent(events)\n        </script>\n    </body>\n</html>\n```\n很遗憾的是，在我查过MDN后，得知该方法已经废弃\n** 注：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 **\n\n## MDN MouseEvent()\nMDN上已经说得很清楚,尽管为了保持向后兼容MouseEvent.initMouseEvent()仍然可用,但是呢,我们应该使用MouseEvent().\n```js\n语法：event = new MouseEvent(typeArg, mouseEventInit);\n```\n```js\nvar doms = document.querySelector('#container')\ndoms.addEventListener('click',function(){\n    console.log(\"莫名其妙被点击\")\n})\n// 创建模拟对象\nvar events = new MouseEvent(\"click\",{\n    bubbles:true,\n    cancelable:true,\n    view:window\n})\n// 最后一步触发事件 dispatchEvent()\ndoms.dispatchEvent(events)\n\n// 至此 我们的自动触发事件已经完成 控制台已经打印：莫名其妙被点击\n```\ntypeArg|DOMString 格式的事件名称。\n------------ | ----------\nmouseEventInit | 可选\n更多的属性请看这里[点击查看](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/MouseEvent#浏览器兼容性)\n\n## IE兼容\n```js\nvar doms = document.getElementById('container');\n// 注意低版本ie兼容\ndoms.attachEvent('onclick', function () {\n    console.log(\"莫名其妙被点击\")\n});\n\n// 创建事件对象\nvar event = document.createEventObject()\n// 触发\ndoms.fireEvent('onclick',event)\n```\n先创建enent对象，然后为其制定相应的信息，然后触发事件\nfireEvent()方法会自动为event对象添加scrElement和type属性，其他属性都必须手动添加\n\n## 创建自定义事件\n** 自定义事件有两种方法,一种是使用new Event(),另一种是new customEvent() **\n```js\nvar doms = document.getElementById('container');\n// 创建自定义事件\nvar event = new Event('build',{\n      bubbles: 'true',\n      cancelable: 'true'\n});\n\n// 监听事件\ndoms.addEventListener('build', function (e) {\n    console.log(\"测试自定义事件\")\n}, false);\n\n// 触发事件.\ndoms.dispatchEvent(event);\n// 控制台\n// 测试自定义事件\n```\n\n```js\nvar doms = document.getElementById('container');\n// 创建自定义事件\nvar event = new CustomEvent('build',{\n      bubbles: 'true', //一个布尔值,表明该事件是否会冒泡.\n      cancelable: 'true', //一个布尔值,表明该事件是否可以被取消.\n      detail:\"我是测试数据\" //当事件初始化时传递的数据.\n});\n\n// 监听事件\ndoms.addEventListener('build', function (e) {\n    console.log(\"测试自定义事件\")\n    console.log(e.detail)\n}, false);\n\n// 触发事件.\ndoms.dispatchEvent(event);\n// 控制台\n// 测试自定义事件\n```\n可以很明显的看到,其实new customEvent()比new Event()多了可以在event.detail属性里携带自定义数据的功能\n\n绝大多数现代浏览器中都会支持这个构造函数（Internet Explorer例外）。 要了解更为复杂的方法，可参考下面的 [过时的方法](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events)。\n[customEvent()](https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent)和[ Event()](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event) MDN链接在此\n\n总结下来发现,除了模拟自定义事件比较好用,兼容性还可以，模拟鼠标事件兼容性各方面都支持的不太好，DOM这块水很深啊，继续研究...\n","slug":"原生JS模拟点击事件和自定义事件","published":1,"updated":"2019-09-25T15:10:25.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ph004ala2et5st59zv","content":"<blockquote>\n<p>事件，就是网页中某个特别值得关注的瞬间，事件是经常有用户操作或通过其他浏览器功能来触发，但是很少有人知道，也可以使用javascript来在任意时刻触发特定事件，此时事件如同浏览器创建的事件一样。 —— 《高级程序设计3》</p>\n</blockquote>\n<h2 id=\"高程三的实现方法\"><a href=\"#高程三的实现方法\" class=\"headerlink\" title=\"高程三的实现方法\"></a>高程三的实现方法</h2><p>模拟点击事件应该是一个很常见的行为，经常用jQ来实现，今天研究下原生js如何模拟触发点击事件</p>\n<pre><code class=\"js\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;container&quot;&gt;\n            点击\n        &lt;/div&gt;\n        &lt;script&gt;\n            var doms = document.querySelector(&#39;#container&#39;)\n            doms.addEventListener(&#39;click&#39;,function(){\n                console.log(&quot;莫名其妙被点击&quot;)\n            })\n            // 使用createEvent() 创建event事件 传入鼠标事件字符串 MouseEvents\n            var events = document.createEvent(&quot;MouseEvents&quot;)\n            // 返回的对象有一个名为 initMouseEvent()方法 用于指定与该鼠标售价仅有关的信息\n            events.initMouseEvent(&quot;click&quot;,true,true,document.defaultView)\n            // 最后一步触发事件 dispatchEvent()\n            doms.dispatchEvent(events)\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>很遗憾的是，在我查过MDN后，得知该方法已经废弃<br><strong> 注：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 </strong></p>\n<h2 id=\"MDN-MouseEvent\"><a href=\"#MDN-MouseEvent\" class=\"headerlink\" title=\"MDN MouseEvent()\"></a>MDN MouseEvent()</h2><p>MDN上已经说得很清楚,尽管为了保持向后兼容MouseEvent.initMouseEvent()仍然可用,但是呢,我们应该使用MouseEvent().</p>\n<pre><code class=\"js\">语法：event = new MouseEvent(typeArg, mouseEventInit);\n</code></pre>\n<pre><code class=\"js\">var doms = document.querySelector(&#39;#container&#39;)\ndoms.addEventListener(&#39;click&#39;,function(){\n    console.log(&quot;莫名其妙被点击&quot;)\n})\n// 创建模拟对象\nvar events = new MouseEvent(&quot;click&quot;,{\n    bubbles:true,\n    cancelable:true,\n    view:window\n})\n// 最后一步触发事件 dispatchEvent()\ndoms.dispatchEvent(events)\n\n// 至此 我们的自动触发事件已经完成 控制台已经打印：莫名其妙被点击\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>typeArg</th>\n<th>DOMString 格式的事件名称。</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mouseEventInit</td>\n<td>可选</td>\n</tr>\n</tbody>\n</table>\n<p>更多的属性请看这里<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/MouseEvent#浏览器兼容性\" target=\"_blank\" rel=\"external\">点击查看</a></p>\n<h2 id=\"IE兼容\"><a href=\"#IE兼容\" class=\"headerlink\" title=\"IE兼容\"></a>IE兼容</h2><pre><code class=\"js\">var doms = document.getElementById(&#39;container&#39;);\n// 注意低版本ie兼容\ndoms.attachEvent(&#39;onclick&#39;, function () {\n    console.log(&quot;莫名其妙被点击&quot;)\n});\n\n// 创建事件对象\nvar event = document.createEventObject()\n// 触发\ndoms.fireEvent(&#39;onclick&#39;,event)\n</code></pre>\n<p>先创建enent对象，然后为其制定相应的信息，然后触发事件<br>fireEvent()方法会自动为event对象添加scrElement和type属性，其他属性都必须手动添加</p>\n<h2 id=\"创建自定义事件\"><a href=\"#创建自定义事件\" class=\"headerlink\" title=\"创建自定义事件\"></a>创建自定义事件</h2><p><strong> 自定义事件有两种方法,一种是使用new Event(),另一种是new customEvent() </strong></p>\n<pre><code class=\"js\">var doms = document.getElementById(&#39;container&#39;);\n// 创建自定义事件\nvar event = new Event(&#39;build&#39;,{\n      bubbles: &#39;true&#39;,\n      cancelable: &#39;true&#39;\n});\n\n// 监听事件\ndoms.addEventListener(&#39;build&#39;, function (e) {\n    console.log(&quot;测试自定义事件&quot;)\n}, false);\n\n// 触发事件.\ndoms.dispatchEvent(event);\n// 控制台\n// 测试自定义事件\n</code></pre>\n<pre><code class=\"js\">var doms = document.getElementById(&#39;container&#39;);\n// 创建自定义事件\nvar event = new CustomEvent(&#39;build&#39;,{\n      bubbles: &#39;true&#39;, //一个布尔值,表明该事件是否会冒泡.\n      cancelable: &#39;true&#39;, //一个布尔值,表明该事件是否可以被取消.\n      detail:&quot;我是测试数据&quot; //当事件初始化时传递的数据.\n});\n\n// 监听事件\ndoms.addEventListener(&#39;build&#39;, function (e) {\n    console.log(&quot;测试自定义事件&quot;)\n    console.log(e.detail)\n}, false);\n\n// 触发事件.\ndoms.dispatchEvent(event);\n// 控制台\n// 测试自定义事件\n</code></pre>\n<p>可以很明显的看到,其实new customEvent()比new Event()多了可以在event.detail属性里携带自定义数据的功能</p>\n<p>绝大多数现代浏览器中都会支持这个构造函数（Internet Explorer例外）。 要了解更为复杂的方法，可参考下面的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events\" target=\"_blank\" rel=\"external\">过时的方法</a>。<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent\" target=\"_blank\" rel=\"external\">customEvent()</a>和<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\" target=\"_blank\" rel=\"external\"> Event()</a> MDN链接在此</p>\n<p>总结下来发现,除了模拟自定义事件比较好用,兼容性还可以，模拟鼠标事件兼容性各方面都支持的不太好，DOM这块水很深啊，继续研究…</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>事件，就是网页中某个特别值得关注的瞬间，事件是经常有用户操作或通过其他浏览器功能来触发，但是很少有人知道，也可以使用javascript来在任意时刻触发特定事件，此时事件如同浏览器创建的事件一样。 —— 《高级程序设计3》</p>\n</blockquote>\n<h2 id=\"高程三的实现方法\"><a href=\"#高程三的实现方法\" class=\"headerlink\" title=\"高程三的实现方法\"></a>高程三的实现方法</h2><p>模拟点击事件应该是一个很常见的行为，经常用jQ来实现，今天研究下原生js如何模拟触发点击事件</p>\n<pre><code class=\"js\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=&quot;container&quot;&gt;\n            点击\n        &lt;/div&gt;\n        &lt;script&gt;\n            var doms = document.querySelector(&#39;#container&#39;)\n            doms.addEventListener(&#39;click&#39;,function(){\n                console.log(&quot;莫名其妙被点击&quot;)\n            })\n            // 使用createEvent() 创建event事件 传入鼠标事件字符串 MouseEvents\n            var events = document.createEvent(&quot;MouseEvents&quot;)\n            // 返回的对象有一个名为 initMouseEvent()方法 用于指定与该鼠标售价仅有关的信息\n            events.initMouseEvent(&quot;click&quot;,true,true,document.defaultView)\n            // 最后一步触发事件 dispatchEvent()\n            doms.dispatchEvent(events)\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>很遗憾的是，在我查过MDN后，得知该方法已经废弃<br><strong> 注：该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 </strong></p>\n<h2 id=\"MDN-MouseEvent\"><a href=\"#MDN-MouseEvent\" class=\"headerlink\" title=\"MDN MouseEvent()\"></a>MDN MouseEvent()</h2><p>MDN上已经说得很清楚,尽管为了保持向后兼容MouseEvent.initMouseEvent()仍然可用,但是呢,我们应该使用MouseEvent().</p>\n<pre><code class=\"js\">语法：event = new MouseEvent(typeArg, mouseEventInit);\n</code></pre>\n<pre><code class=\"js\">var doms = document.querySelector(&#39;#container&#39;)\ndoms.addEventListener(&#39;click&#39;,function(){\n    console.log(&quot;莫名其妙被点击&quot;)\n})\n// 创建模拟对象\nvar events = new MouseEvent(&quot;click&quot;,{\n    bubbles:true,\n    cancelable:true,\n    view:window\n})\n// 最后一步触发事件 dispatchEvent()\ndoms.dispatchEvent(events)\n\n// 至此 我们的自动触发事件已经完成 控制台已经打印：莫名其妙被点击\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>typeArg</th>\n<th>DOMString 格式的事件名称。</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>mouseEventInit</td>\n<td>可选</td>\n</tr>\n</tbody>\n</table>\n<p>更多的属性请看这里<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/MouseEvent#浏览器兼容性\" target=\"_blank\" rel=\"external\">点击查看</a></p>\n<h2 id=\"IE兼容\"><a href=\"#IE兼容\" class=\"headerlink\" title=\"IE兼容\"></a>IE兼容</h2><pre><code class=\"js\">var doms = document.getElementById(&#39;container&#39;);\n// 注意低版本ie兼容\ndoms.attachEvent(&#39;onclick&#39;, function () {\n    console.log(&quot;莫名其妙被点击&quot;)\n});\n\n// 创建事件对象\nvar event = document.createEventObject()\n// 触发\ndoms.fireEvent(&#39;onclick&#39;,event)\n</code></pre>\n<p>先创建enent对象，然后为其制定相应的信息，然后触发事件<br>fireEvent()方法会自动为event对象添加scrElement和type属性，其他属性都必须手动添加</p>\n<h2 id=\"创建自定义事件\"><a href=\"#创建自定义事件\" class=\"headerlink\" title=\"创建自定义事件\"></a>创建自定义事件</h2><p><strong> 自定义事件有两种方法,一种是使用new Event(),另一种是new customEvent() </strong></p>\n<pre><code class=\"js\">var doms = document.getElementById(&#39;container&#39;);\n// 创建自定义事件\nvar event = new Event(&#39;build&#39;,{\n      bubbles: &#39;true&#39;,\n      cancelable: &#39;true&#39;\n});\n\n// 监听事件\ndoms.addEventListener(&#39;build&#39;, function (e) {\n    console.log(&quot;测试自定义事件&quot;)\n}, false);\n\n// 触发事件.\ndoms.dispatchEvent(event);\n// 控制台\n// 测试自定义事件\n</code></pre>\n<pre><code class=\"js\">var doms = document.getElementById(&#39;container&#39;);\n// 创建自定义事件\nvar event = new CustomEvent(&#39;build&#39;,{\n      bubbles: &#39;true&#39;, //一个布尔值,表明该事件是否会冒泡.\n      cancelable: &#39;true&#39;, //一个布尔值,表明该事件是否可以被取消.\n      detail:&quot;我是测试数据&quot; //当事件初始化时传递的数据.\n});\n\n// 监听事件\ndoms.addEventListener(&#39;build&#39;, function (e) {\n    console.log(&quot;测试自定义事件&quot;)\n    console.log(e.detail)\n}, false);\n\n// 触发事件.\ndoms.dispatchEvent(event);\n// 控制台\n// 测试自定义事件\n</code></pre>\n<p>可以很明显的看到,其实new customEvent()比new Event()多了可以在event.detail属性里携带自定义数据的功能</p>\n<p>绝大多数现代浏览器中都会支持这个构造函数（Internet Explorer例外）。 要了解更为复杂的方法，可参考下面的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events\" target=\"_blank\" rel=\"external\">过时的方法</a>。<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent\" target=\"_blank\" rel=\"external\">customEvent()</a>和<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\" target=\"_blank\" rel=\"external\"> Event()</a> MDN链接在此</p>\n<p>总结下来发现,除了模拟自定义事件比较好用,兼容性还可以，模拟鼠标事件兼容性各方面都支持的不太好，DOM这块水很深啊，继续研究…</p>\n"},{"title":"JavaScript获取CSS样式遇到的一些问题","date":"2017-09-25T12:09:48.000Z","author":"LoadingMore","_content":"> 最近在写一个效果需要获取一个元素translateX的值，因为没有采用JQ,所以用原生方法\n\n\n## 获取不到样式\n```js\nconst res = document.querySelector('.target').style.width\n\nconsole.log(res) // 结果为空\n```\n郁闷啊。。。\n突然想到之前看高程的时候看到过getComputedStyle这个方法，于是MDN了一下[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle)\n\n```js\nstyle                  //只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。\ncurrentStyle         //适用于IE8及以下。\ngetComputedStyle     //同currentStyle作用相同，但是适用于FF、opera、safari、chrome IE9+。\n```\n## getComputedStyle\ngetComputedStyle 是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读\n\n语法：\n```js\nlet style = window.getComputedStyle(element, [pseudoElt]);\n\n// 用于获取计算样式的Element\n// pseudoElt 可选 指定一个要匹配的伪元素的字符串\n```\n\n## 兼容性写法\n```js\nconst getStyle = function(obj,attr){\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle($(obj))[attr]\n}\n```\n## Javascript获取transform中的属性值\n```js\nconst $ = function(el){\n    return document.querySelector(el)\n}\nconst getStyle = function(obj,attr){\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle(obj)[attr]\n}\nconst getTransform = function(data){\n    const reg = /matrix\\((.*)\\)/\n    const result = reg.exec(data)[1].split(',')\n    return {\n        transX: parseInt(result[result.length-2]),\n        transY: parseInt(result[result.length-1])\n    }\n}\ngetTransform(getStyle($('.box'),'transform'))\n// {transX: -4, transY: -8}\n```\n","source":"_posts/原生JavaScript获取CSS样式遇到的一些问题.md","raw":"---\ntitle: JavaScript获取CSS样式遇到的一些问题\ndate: 2017-09-25 20:09:48\ntags: [Javascript,'CSS']\nauthor: \"LoadingMore\"\n---\n> 最近在写一个效果需要获取一个元素translateX的值，因为没有采用JQ,所以用原生方法\n\n\n## 获取不到样式\n```js\nconst res = document.querySelector('.target').style.width\n\nconsole.log(res) // 结果为空\n```\n郁闷啊。。。\n突然想到之前看高程的时候看到过getComputedStyle这个方法，于是MDN了一下[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle)\n\n```js\nstyle                  //只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。\ncurrentStyle         //适用于IE8及以下。\ngetComputedStyle     //同currentStyle作用相同，但是适用于FF、opera、safari、chrome IE9+。\n```\n## getComputedStyle\ngetComputedStyle 是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读\n\n语法：\n```js\nlet style = window.getComputedStyle(element, [pseudoElt]);\n\n// 用于获取计算样式的Element\n// pseudoElt 可选 指定一个要匹配的伪元素的字符串\n```\n\n## 兼容性写法\n```js\nconst getStyle = function(obj,attr){\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle($(obj))[attr]\n}\n```\n## Javascript获取transform中的属性值\n```js\nconst $ = function(el){\n    return document.querySelector(el)\n}\nconst getStyle = function(obj,attr){\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle(obj)[attr]\n}\nconst getTransform = function(data){\n    const reg = /matrix\\((.*)\\)/\n    const result = reg.exec(data)[1].split(',')\n    return {\n        transX: parseInt(result[result.length-2]),\n        transY: parseInt(result[result.length-1])\n    }\n}\ngetTransform(getStyle($('.box'),'transform'))\n// {transX: -4, transY: -8}\n```\n","slug":"原生JavaScript获取CSS样式遇到的一些问题","published":1,"updated":"2019-09-25T15:10:25.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pj004ela2ec1hon05m","content":"<blockquote>\n<p>最近在写一个效果需要获取一个元素translateX的值，因为没有采用JQ,所以用原生方法</p>\n</blockquote>\n<h2 id=\"获取不到样式\"><a href=\"#获取不到样式\" class=\"headerlink\" title=\"获取不到样式\"></a>获取不到样式</h2><pre><code class=\"js\">const res = document.querySelector(&#39;.target&#39;).style.width\n\nconsole.log(res) // 结果为空\n</code></pre>\n<p>郁闷啊。。。<br>突然想到之前看高程的时候看到过getComputedStyle这个方法，于是MDN了一下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle\" target=\"_blank\" rel=\"external\">这里</a></p>\n<pre><code class=\"js\">style                  //只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。\ncurrentStyle         //适用于IE8及以下。\ngetComputedStyle     //同currentStyle作用相同，但是适用于FF、opera、safari、chrome IE9+。\n</code></pre>\n<h2 id=\"getComputedStyle\"><a href=\"#getComputedStyle\" class=\"headerlink\" title=\"getComputedStyle\"></a>getComputedStyle</h2><p>getComputedStyle 是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读</p>\n<p>语法：</p>\n<pre><code class=\"js\">let style = window.getComputedStyle(element, [pseudoElt]);\n\n// 用于获取计算样式的Element\n// pseudoElt 可选 指定一个要匹配的伪元素的字符串\n</code></pre>\n<h2 id=\"兼容性写法\"><a href=\"#兼容性写法\" class=\"headerlink\" title=\"兼容性写法\"></a>兼容性写法</h2><pre><code class=\"js\">const getStyle = function(obj,attr){\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle($(obj))[attr]\n}\n</code></pre>\n<h2 id=\"Javascript获取transform中的属性值\"><a href=\"#Javascript获取transform中的属性值\" class=\"headerlink\" title=\"Javascript获取transform中的属性值\"></a>Javascript获取transform中的属性值</h2><pre><code class=\"js\">const $ = function(el){\n    return document.querySelector(el)\n}\nconst getStyle = function(obj,attr){\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle(obj)[attr]\n}\nconst getTransform = function(data){\n    const reg = /matrix\\((.*)\\)/\n    const result = reg.exec(data)[1].split(&#39;,&#39;)\n    return {\n        transX: parseInt(result[result.length-2]),\n        transY: parseInt(result[result.length-1])\n    }\n}\ngetTransform(getStyle($(&#39;.box&#39;),&#39;transform&#39;))\n// {transX: -4, transY: -8}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近在写一个效果需要获取一个元素translateX的值，因为没有采用JQ,所以用原生方法</p>\n</blockquote>\n<h2 id=\"获取不到样式\"><a href=\"#获取不到样式\" class=\"headerlink\" title=\"获取不到样式\"></a>获取不到样式</h2><pre><code class=\"js\">const res = document.querySelector(&#39;.target&#39;).style.width\n\nconsole.log(res) // 结果为空\n</code></pre>\n<p>郁闷啊。。。<br>突然想到之前看高程的时候看到过getComputedStyle这个方法，于是MDN了一下<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle\" target=\"_blank\" rel=\"external\">这里</a></p>\n<pre><code class=\"js\">style                  //只能获取元素的内联样式，内部样式和外部样式使用style是获取不到的。\ncurrentStyle         //适用于IE8及以下。\ngetComputedStyle     //同currentStyle作用相同，但是适用于FF、opera、safari、chrome IE9+。\n</code></pre>\n<h2 id=\"getComputedStyle\"><a href=\"#getComputedStyle\" class=\"headerlink\" title=\"getComputedStyle\"></a>getComputedStyle</h2><p>getComputedStyle 是一个可以获取当前元素所有最终使用的CSS属性值。返回的是一个CSS样式声明对象([object CSSStyleDeclaration])，只读</p>\n<p>语法：</p>\n<pre><code class=\"js\">let style = window.getComputedStyle(element, [pseudoElt]);\n\n// 用于获取计算样式的Element\n// pseudoElt 可选 指定一个要匹配的伪元素的字符串\n</code></pre>\n<h2 id=\"兼容性写法\"><a href=\"#兼容性写法\" class=\"headerlink\" title=\"兼容性写法\"></a>兼容性写法</h2><pre><code class=\"js\">const getStyle = function(obj,attr){\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle($(obj))[attr]\n}\n</code></pre>\n<h2 id=\"Javascript获取transform中的属性值\"><a href=\"#Javascript获取transform中的属性值\" class=\"headerlink\" title=\"Javascript获取transform中的属性值\"></a>Javascript获取transform中的属性值</h2><pre><code class=\"js\">const $ = function(el){\n    return document.querySelector(el)\n}\nconst getStyle = function(obj,attr){\n    return obj.currentStyle ? obj.currentStyle[attr] : window.getComputedStyle(obj)[attr]\n}\nconst getTransform = function(data){\n    const reg = /matrix\\((.*)\\)/\n    const result = reg.exec(data)[1].split(&#39;,&#39;)\n    return {\n        transX: parseInt(result[result.length-2]),\n        transY: parseInt(result[result.length-1])\n    }\n}\ngetTransform(getStyle($(&#39;.box&#39;),&#39;transform&#39;))\n// {transX: -4, transY: -8}\n</code></pre>\n"},{"title":"原生js实现类似于Jquery的ajax请求方式","date":"2017-01-16T14:18:17.000Z","_content":"> 最近用数据这块挺多，随手写了个原生Js的ajax封装，调用方式与JQuery一样\n\n<!-- more -->\n## 封装\n```javascript\n/*\n* @obj 传入入口的对象属性和方法\n* @type  请求方式 GET 或者. 默认GET\n* @url 请求链接API\n* @boolType 是否异步 true or false\n* @dataType 数据类型 默认JSON\n* @success 请求数据成功后的回调\n* @error 请求数据失败的回调\n*/\nfunction ajax(obj){\n    //定义请求数据方式\n    obj.type = obj.type || \"GET\";\n    //创建实例\n    if(window.XMLHttpRequest){\n\t\txhr = new XMLHttpRequest();\n\t}else if(window.ActiveXObject){\n\t\txhr = new ActiveXObject(Microsoft.XMLHTTP);\n\t}\n    //发送请求\n    xhr.open(obj.type,obj.url,obj.boolType);\n    //触发事件后\n    xhr.onload = function(){\n        if(xhr.readyState === 4){\n            if(xhr.status >=200 && xhr.status <300 || xhr.status === 304){\n                //判断数据类型\n                if(obj.dataType && obj.dataType.toLowerCase() === \"json\"){\n                    //声明类型 按json解析\n                    return obj.success(JSON.parse(xhr.responseText));\n                }\n                 //默认输出\n                return obj.success(xhr.responseText);\n            }\n        }else{\n            return obj.error(new Error(xhr.statusText));\n        }\n    };\n    //触发数据失败的提示\n    xhr.onerror = function(){\n        return obj.error(new Error(xhr.statusText));\n    }\n    //判断数据get or post\n    obj.type && obj.type.toLowerCase() === \"post\" ?\n\t\txhr.send(obj.data) : xhr.send(null);\n}\n```\n## 调用：\n```javascript\najax({\n    url:\"https://biyuqi.github.io/gnotes/data/bloger.json\",//数据可用，无跨域\n    type:\"GET\",\n    boolType:true,\n    dataType:\"JSON\",\n    success:function(data){\n        console.log(data);//可以在浏览器查看数据了\n    },\n    error:function(error){\n        console.log(error);\n    }\n})\n\n```\n## 追加一个promise方式的ajax之Get请求\nupdate at 2017-12-29\n```js\nconst ajax_GET = function(param){\n    return new Promise((resolve,reject) => {\n        const xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\")\n\n        xhr.open(\"GET\",param.url,true)\n\n        xhr.send()\n\n        xhr.onload  = function(){\n            resolve(xhr.responseText)\n        }\n        xhr.onerror = function(error){\n            reject(error)\n        }\n    })\n}\najax_GET({url:xxxxxxxxx})\n    .then((data)=>{\n        console.log(JSON.parse(data))\n    })\n    .catch((err)=>{\n        console.log(err)\n    })\n\n```\nPOST请求一样的道理，这里就不加赘述了\n\n[1]: http://oiukswkar.bkt.clouddn.com/ajax.jpg\n","source":"_posts/原生js实现类似于Jquery的ajax请求方式.md","raw":"---\ntitle: 原生js实现类似于Jquery的ajax请求方式\ndate: 2017-01-16 22:18:17\ntags: [javascript]\ncategories: Javascript\n---\n> 最近用数据这块挺多，随手写了个原生Js的ajax封装，调用方式与JQuery一样\n\n<!-- more -->\n## 封装\n```javascript\n/*\n* @obj 传入入口的对象属性和方法\n* @type  请求方式 GET 或者. 默认GET\n* @url 请求链接API\n* @boolType 是否异步 true or false\n* @dataType 数据类型 默认JSON\n* @success 请求数据成功后的回调\n* @error 请求数据失败的回调\n*/\nfunction ajax(obj){\n    //定义请求数据方式\n    obj.type = obj.type || \"GET\";\n    //创建实例\n    if(window.XMLHttpRequest){\n\t\txhr = new XMLHttpRequest();\n\t}else if(window.ActiveXObject){\n\t\txhr = new ActiveXObject(Microsoft.XMLHTTP);\n\t}\n    //发送请求\n    xhr.open(obj.type,obj.url,obj.boolType);\n    //触发事件后\n    xhr.onload = function(){\n        if(xhr.readyState === 4){\n            if(xhr.status >=200 && xhr.status <300 || xhr.status === 304){\n                //判断数据类型\n                if(obj.dataType && obj.dataType.toLowerCase() === \"json\"){\n                    //声明类型 按json解析\n                    return obj.success(JSON.parse(xhr.responseText));\n                }\n                 //默认输出\n                return obj.success(xhr.responseText);\n            }\n        }else{\n            return obj.error(new Error(xhr.statusText));\n        }\n    };\n    //触发数据失败的提示\n    xhr.onerror = function(){\n        return obj.error(new Error(xhr.statusText));\n    }\n    //判断数据get or post\n    obj.type && obj.type.toLowerCase() === \"post\" ?\n\t\txhr.send(obj.data) : xhr.send(null);\n}\n```\n## 调用：\n```javascript\najax({\n    url:\"https://biyuqi.github.io/gnotes/data/bloger.json\",//数据可用，无跨域\n    type:\"GET\",\n    boolType:true,\n    dataType:\"JSON\",\n    success:function(data){\n        console.log(data);//可以在浏览器查看数据了\n    },\n    error:function(error){\n        console.log(error);\n    }\n})\n\n```\n## 追加一个promise方式的ajax之Get请求\nupdate at 2017-12-29\n```js\nconst ajax_GET = function(param){\n    return new Promise((resolve,reject) => {\n        const xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\")\n\n        xhr.open(\"GET\",param.url,true)\n\n        xhr.send()\n\n        xhr.onload  = function(){\n            resolve(xhr.responseText)\n        }\n        xhr.onerror = function(error){\n            reject(error)\n        }\n    })\n}\najax_GET({url:xxxxxxxxx})\n    .then((data)=>{\n        console.log(JSON.parse(data))\n    })\n    .catch((err)=>{\n        console.log(err)\n    })\n\n```\nPOST请求一样的道理，这里就不加赘述了\n\n[1]: http://oiukswkar.bkt.clouddn.com/ajax.jpg\n","slug":"原生js实现类似于Jquery的ajax请求方式","published":1,"updated":"2019-09-25T15:10:25.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pk004hla2erk5lpiy3","content":"<blockquote>\n<p>最近用数据这块挺多，随手写了个原生Js的ajax封装，调用方式与JQuery一样</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><pre><code class=\"javascript\">/*\n* @obj 传入入口的对象属性和方法\n* @type  请求方式 GET 或者. 默认GET\n* @url 请求链接API\n* @boolType 是否异步 true or false\n* @dataType 数据类型 默认JSON\n* @success 请求数据成功后的回调\n* @error 请求数据失败的回调\n*/\nfunction ajax(obj){\n    //定义请求数据方式\n    obj.type = obj.type || &quot;GET&quot;;\n    //创建实例\n    if(window.XMLHttpRequest){\n        xhr = new XMLHttpRequest();\n    }else if(window.ActiveXObject){\n        xhr = new ActiveXObject(Microsoft.XMLHTTP);\n    }\n    //发送请求\n    xhr.open(obj.type,obj.url,obj.boolType);\n    //触发事件后\n    xhr.onload = function(){\n        if(xhr.readyState === 4){\n            if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt;300 || xhr.status === 304){\n                //判断数据类型\n                if(obj.dataType &amp;&amp; obj.dataType.toLowerCase() === &quot;json&quot;){\n                    //声明类型 按json解析\n                    return obj.success(JSON.parse(xhr.responseText));\n                }\n                 //默认输出\n                return obj.success(xhr.responseText);\n            }\n        }else{\n            return obj.error(new Error(xhr.statusText));\n        }\n    };\n    //触发数据失败的提示\n    xhr.onerror = function(){\n        return obj.error(new Error(xhr.statusText));\n    }\n    //判断数据get or post\n    obj.type &amp;&amp; obj.type.toLowerCase() === &quot;post&quot; ?\n        xhr.send(obj.data) : xhr.send(null);\n}\n</code></pre>\n<h2 id=\"调用：\"><a href=\"#调用：\" class=\"headerlink\" title=\"调用：\"></a>调用：</h2><pre><code class=\"javascript\">ajax({\n    url:&quot;https://biyuqi.github.io/gnotes/data/bloger.json&quot;,//数据可用，无跨域\n    type:&quot;GET&quot;,\n    boolType:true,\n    dataType:&quot;JSON&quot;,\n    success:function(data){\n        console.log(data);//可以在浏览器查看数据了\n    },\n    error:function(error){\n        console.log(error);\n    }\n})\n</code></pre>\n<h2 id=\"追加一个promise方式的ajax之Get请求\"><a href=\"#追加一个promise方式的ajax之Get请求\" class=\"headerlink\" title=\"追加一个promise方式的ajax之Get请求\"></a>追加一个promise方式的ajax之Get请求</h2><p>update at 2017-12-29</p>\n<pre><code class=\"js\">const ajax_GET = function(param){\n    return new Promise((resolve,reject) =&gt; {\n        const xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)\n\n        xhr.open(&quot;GET&quot;,param.url,true)\n\n        xhr.send()\n\n        xhr.onload  = function(){\n            resolve(xhr.responseText)\n        }\n        xhr.onerror = function(error){\n            reject(error)\n        }\n    })\n}\najax_GET({url:xxxxxxxxx})\n    .then((data)=&gt;{\n        console.log(JSON.parse(data))\n    })\n    .catch((err)=&gt;{\n        console.log(err)\n    })\n</code></pre>\n<p>POST请求一样的道理，这里就不加赘述了</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近用数据这块挺多，随手写了个原生Js的ajax封装，调用方式与JQuery一样</p>\n</blockquote>","more":"<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><pre><code class=\"javascript\">/*\n* @obj 传入入口的对象属性和方法\n* @type  请求方式 GET 或者. 默认GET\n* @url 请求链接API\n* @boolType 是否异步 true or false\n* @dataType 数据类型 默认JSON\n* @success 请求数据成功后的回调\n* @error 请求数据失败的回调\n*/\nfunction ajax(obj){\n    //定义请求数据方式\n    obj.type = obj.type || &quot;GET&quot;;\n    //创建实例\n    if(window.XMLHttpRequest){\n        xhr = new XMLHttpRequest();\n    }else if(window.ActiveXObject){\n        xhr = new ActiveXObject(Microsoft.XMLHTTP);\n    }\n    //发送请求\n    xhr.open(obj.type,obj.url,obj.boolType);\n    //触发事件后\n    xhr.onload = function(){\n        if(xhr.readyState === 4){\n            if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt;300 || xhr.status === 304){\n                //判断数据类型\n                if(obj.dataType &amp;&amp; obj.dataType.toLowerCase() === &quot;json&quot;){\n                    //声明类型 按json解析\n                    return obj.success(JSON.parse(xhr.responseText));\n                }\n                 //默认输出\n                return obj.success(xhr.responseText);\n            }\n        }else{\n            return obj.error(new Error(xhr.statusText));\n        }\n    };\n    //触发数据失败的提示\n    xhr.onerror = function(){\n        return obj.error(new Error(xhr.statusText));\n    }\n    //判断数据get or post\n    obj.type &amp;&amp; obj.type.toLowerCase() === &quot;post&quot; ?\n        xhr.send(obj.data) : xhr.send(null);\n}\n</code></pre>\n<h2 id=\"调用：\"><a href=\"#调用：\" class=\"headerlink\" title=\"调用：\"></a>调用：</h2><pre><code class=\"javascript\">ajax({\n    url:&quot;https://biyuqi.github.io/gnotes/data/bloger.json&quot;,//数据可用，无跨域\n    type:&quot;GET&quot;,\n    boolType:true,\n    dataType:&quot;JSON&quot;,\n    success:function(data){\n        console.log(data);//可以在浏览器查看数据了\n    },\n    error:function(error){\n        console.log(error);\n    }\n})\n</code></pre>\n<h2 id=\"追加一个promise方式的ajax之Get请求\"><a href=\"#追加一个promise方式的ajax之Get请求\" class=\"headerlink\" title=\"追加一个promise方式的ajax之Get请求\"></a>追加一个promise方式的ajax之Get请求</h2><p>update at 2017-12-29</p>\n<pre><code class=\"js\">const ajax_GET = function(param){\n    return new Promise((resolve,reject) =&gt; {\n        const xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)\n\n        xhr.open(&quot;GET&quot;,param.url,true)\n\n        xhr.send()\n\n        xhr.onload  = function(){\n            resolve(xhr.responseText)\n        }\n        xhr.onerror = function(error){\n            reject(error)\n        }\n    })\n}\najax_GET({url:xxxxxxxxx})\n    .then((data)=&gt;{\n        console.log(JSON.parse(data))\n    })\n    .catch((err)=&gt;{\n        console.log(err)\n    })\n</code></pre>\n<p>POST请求一样的道理，这里就不加赘述了</p>"},{"title":"只执行一次的函数该怎么写?","date":"2017-03-02T11:45:43.000Z","_content":"> 实际项目中也许会遇到一些只能执行一次的事件,该怎么写呢？\n\n\n<!-- more -->\n### 代码\n```javascript\nfunction once(fn){\n    var isFlag = false;\n    return function(){\n        if(!isFlag){\n            isFlag = true;\n            fn();\n        }\n    }\n}\n//demo\n//html结构省略 测试点击事件\n//只执行一次\nvar box = document.querySelector('.box');\nbox.addEventListener('click',once(function(){\n        //放心鼠标点破,也只会执行一次\n        console.log(\"二狗\");\n}),false)\n```\n剩下的就看根据需求,来决定使用场景了\n\n[1]: http://oiukswkar.bkt.clouddn.com/once.jpg\n","source":"_posts/只执行一次的函数该怎么写.md","raw":"---\ntitle: 只执行一次的函数该怎么写?\ndate: 2017-03-02 19:45:43\ntags: [javascript,\"小技巧\"]\ncategories: Javascript\n---\n> 实际项目中也许会遇到一些只能执行一次的事件,该怎么写呢？\n\n\n<!-- more -->\n### 代码\n```javascript\nfunction once(fn){\n    var isFlag = false;\n    return function(){\n        if(!isFlag){\n            isFlag = true;\n            fn();\n        }\n    }\n}\n//demo\n//html结构省略 测试点击事件\n//只执行一次\nvar box = document.querySelector('.box');\nbox.addEventListener('click',once(function(){\n        //放心鼠标点破,也只会执行一次\n        console.log(\"二狗\");\n}),false)\n```\n剩下的就看根据需求,来决定使用场景了\n\n[1]: http://oiukswkar.bkt.clouddn.com/once.jpg\n","slug":"只执行一次的函数该怎么写","published":1,"updated":"2019-09-25T15:10:25.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pl004lla2e2wvx71ih","content":"<blockquote>\n<p>实际项目中也许会遇到一些只能执行一次的事件,该怎么写呢？</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre><code class=\"javascript\">function once(fn){\n    var isFlag = false;\n    return function(){\n        if(!isFlag){\n            isFlag = true;\n            fn();\n        }\n    }\n}\n//demo\n//html结构省略 测试点击事件\n//只执行一次\nvar box = document.querySelector(&#39;.box&#39;);\nbox.addEventListener(&#39;click&#39;,once(function(){\n        //放心鼠标点破,也只会执行一次\n        console.log(&quot;二狗&quot;);\n}),false)\n</code></pre>\n<p>剩下的就看根据需求,来决定使用场景了</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>实际项目中也许会遇到一些只能执行一次的事件,该怎么写呢？</p>\n</blockquote>","more":"<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre><code class=\"javascript\">function once(fn){\n    var isFlag = false;\n    return function(){\n        if(!isFlag){\n            isFlag = true;\n            fn();\n        }\n    }\n}\n//demo\n//html结构省略 测试点击事件\n//只执行一次\nvar box = document.querySelector(&#39;.box&#39;);\nbox.addEventListener(&#39;click&#39;,once(function(){\n        //放心鼠标点破,也只会执行一次\n        console.log(&quot;二狗&quot;);\n}),false)\n</code></pre>\n<p>剩下的就看根据需求,来决定使用场景了</p>"},{"title":"如何优雅的拼接url之GET请求参数","date":"2017-01-17T12:08:07.000Z","_content":"> 请求的URL后面带参数在项目中是很常见的，常用在的地方比如跳转到新页面或者搜索关键词等，刚好项目用到，就写了我认为比较简便的方法提取参数\n\n<!-- more -->\n\n### 最常见的形式\n\n```javascript\n url?arg1=value1&arg2=value2&arg3=value3...\n```\n### 如何拼接URL？\n假如一个查询系统有很多字段,刚好需要拼接URl的形式进行查询，此刻我们可以采用对象过滤的方法进行转换：\n```js\nconst searchParam = {\n    name: 'Bob',\n    age: 20,\n    address: '',\n    phone: 18888888888\n}\n\nconst transformParamToUrl = (param) => {\n    const tempObj = []\n    if (!param || typeof param !== 'object') {\n        return\n    }\n\n    for (let i in param) {\n        if (param.hasOwnProperty(i) && param[i]) {\n            tempObj.push(i)\n            tempObj.push('=')\n            tempObj.push(param[i])\n            tempObj.push('&')\n        }\n    }\n    // remove the last field &\n    tempObj.pop()\n    return tempObj.join('')\n}\ntransformParamToUrl(searchParam)\n// name=Bob&age=20&phone=18888888888\n```\n\n我们得到了拼接好的URL，并且未将无效值加入.\n\n### 解析URL参数\n\n我们拼接了URl，下面讲下如何解析URL参数.\n```js\nconst flatten = (arr) => \n    arr.reduce((initial, curr, index) => \n    Array.isArray(curr) ? initial.concat(flatten(curr)) : initial.concat(curr), [])\n\nconst parseQuery = (query) => {\n    const regexp = /(\\w+)=([^&]+)/g\n    const result = {}\n    let match\n\n    while(match = regexp.exec(query)) {\n        let key = match[1], value = match[2].replace(/\\n/g, '')\n        result[key] ? result[key] = flatten([result[key], value]) : result[key] = value\n    }\n\n    return result\n}\n\n// example:\nconst query = `\nhttps://www.baidu.com/s?ie=utf8&f=8&f=90&rsv_bp=1&rsv_idx=1&rsv_bp=1&tn=baidu&wd=%E6%B0%B4%E7%94%B5%E8%B4%B9&rsv_pq=c7797024000434a8&rsv_t=b786FJnGwOOxPk7E7gsn1VbYHpmSP93UpP1470GL9ajYJkd09MOyBzSTsVk&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=5&rsv_sug1=4&rsv_sug7=101&rsv_bp=234&rsv_sug2=0&inputT=1760&rsv_sug4=2010&jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM\n`.split('?')[1]\n\nparseQuery(query)\n\n// { \n//   ie: 'utf8',\n//   f: [ '8', '90' ],\n//   rsv_bp: [ '1', '1', '234' ],\n//   rsv_idx: '1',\n//   tn: 'baidu',\n//   rsv_pq: 'c7797024000434a8',\n//   rsv_t: 'b786FJnGwOOxPk7E7gsn1VbYHpmSP93UpP1470GL9ajYJkd09MOyBzSTsVk',\n//   rqlang: 'cn',\n//   rsv_enter: '1',\n//   rsv_dl: 'tb',\n//   rsv_sug3: '5',\n//   rsv_sug1: '4',\n//   rsv_sug7: '101',\n//   rsv_sug2: '0',\n//   inputT: '1760',\n//   rsv_sug4: '2010' \n// }\n```\n我们得到了预期的解析数据，并且相同的key进行了数组化存储.\n\n### 在线小Demo\nDemo仅做参考，请看代码请看上面👆.\n[DEMO](https://biyuqi.github.io/demo/src/html/url.html)","source":"_posts/如何优雅的拼接url之GET请求参数.md","raw":"---\ntitle: 如何优雅的拼接url之GET请求参数\ndate: 2017-01-17 20:08:07\ntags: [javascript, url, 'URL拼接', '解析URL']\ncategories: Javascript\n---\n> 请求的URL后面带参数在项目中是很常见的，常用在的地方比如跳转到新页面或者搜索关键词等，刚好项目用到，就写了我认为比较简便的方法提取参数\n\n<!-- more -->\n\n### 最常见的形式\n\n```javascript\n url?arg1=value1&arg2=value2&arg3=value3...\n```\n### 如何拼接URL？\n假如一个查询系统有很多字段,刚好需要拼接URl的形式进行查询，此刻我们可以采用对象过滤的方法进行转换：\n```js\nconst searchParam = {\n    name: 'Bob',\n    age: 20,\n    address: '',\n    phone: 18888888888\n}\n\nconst transformParamToUrl = (param) => {\n    const tempObj = []\n    if (!param || typeof param !== 'object') {\n        return\n    }\n\n    for (let i in param) {\n        if (param.hasOwnProperty(i) && param[i]) {\n            tempObj.push(i)\n            tempObj.push('=')\n            tempObj.push(param[i])\n            tempObj.push('&')\n        }\n    }\n    // remove the last field &\n    tempObj.pop()\n    return tempObj.join('')\n}\ntransformParamToUrl(searchParam)\n// name=Bob&age=20&phone=18888888888\n```\n\n我们得到了拼接好的URL，并且未将无效值加入.\n\n### 解析URL参数\n\n我们拼接了URl，下面讲下如何解析URL参数.\n```js\nconst flatten = (arr) => \n    arr.reduce((initial, curr, index) => \n    Array.isArray(curr) ? initial.concat(flatten(curr)) : initial.concat(curr), [])\n\nconst parseQuery = (query) => {\n    const regexp = /(\\w+)=([^&]+)/g\n    const result = {}\n    let match\n\n    while(match = regexp.exec(query)) {\n        let key = match[1], value = match[2].replace(/\\n/g, '')\n        result[key] ? result[key] = flatten([result[key], value]) : result[key] = value\n    }\n\n    return result\n}\n\n// example:\nconst query = `\nhttps://www.baidu.com/s?ie=utf8&f=8&f=90&rsv_bp=1&rsv_idx=1&rsv_bp=1&tn=baidu&wd=%E6%B0%B4%E7%94%B5%E8%B4%B9&rsv_pq=c7797024000434a8&rsv_t=b786FJnGwOOxPk7E7gsn1VbYHpmSP93UpP1470GL9ajYJkd09MOyBzSTsVk&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=5&rsv_sug1=4&rsv_sug7=101&rsv_bp=234&rsv_sug2=0&inputT=1760&rsv_sug4=2010&jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM\n`.split('?')[1]\n\nparseQuery(query)\n\n// { \n//   ie: 'utf8',\n//   f: [ '8', '90' ],\n//   rsv_bp: [ '1', '1', '234' ],\n//   rsv_idx: '1',\n//   tn: 'baidu',\n//   rsv_pq: 'c7797024000434a8',\n//   rsv_t: 'b786FJnGwOOxPk7E7gsn1VbYHpmSP93UpP1470GL9ajYJkd09MOyBzSTsVk',\n//   rqlang: 'cn',\n//   rsv_enter: '1',\n//   rsv_dl: 'tb',\n//   rsv_sug3: '5',\n//   rsv_sug1: '4',\n//   rsv_sug7: '101',\n//   rsv_sug2: '0',\n//   inputT: '1760',\n//   rsv_sug4: '2010' \n// }\n```\n我们得到了预期的解析数据，并且相同的key进行了数组化存储.\n\n### 在线小Demo\nDemo仅做参考，请看代码请看上面👆.\n[DEMO](https://biyuqi.github.io/demo/src/html/url.html)","slug":"如何优雅的拼接url之GET请求参数","published":1,"updated":"2019-10-19T00:03:25.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pm004nla2egp8uhvj4","content":"<blockquote>\n<p>请求的URL后面带参数在项目中是很常见的，常用在的地方比如跳转到新页面或者搜索关键词等，刚好项目用到，就写了我认为比较简便的方法提取参数</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"最常见的形式\"><a href=\"#最常见的形式\" class=\"headerlink\" title=\"最常见的形式\"></a>最常见的形式</h3><pre><code class=\"javascript\"> url?arg1=value1&amp;arg2=value2&amp;arg3=value3...\n</code></pre>\n<h3 id=\"如何拼接URL？\"><a href=\"#如何拼接URL？\" class=\"headerlink\" title=\"如何拼接URL？\"></a>如何拼接URL？</h3><p>假如一个查询系统有很多字段,刚好需要拼接URl的形式进行查询，此刻我们可以采用对象过滤的方法进行转换：</p>\n<pre><code class=\"js\">const searchParam = {\n    name: &#39;Bob&#39;,\n    age: 20,\n    address: &#39;&#39;,\n    phone: 18888888888\n}\n\nconst transformParamToUrl = (param) =&gt; {\n    const tempObj = []\n    if (!param || typeof param !== &#39;object&#39;) {\n        return\n    }\n\n    for (let i in param) {\n        if (param.hasOwnProperty(i) &amp;&amp; param[i]) {\n            tempObj.push(i)\n            tempObj.push(&#39;=&#39;)\n            tempObj.push(param[i])\n            tempObj.push(&#39;&amp;&#39;)\n        }\n    }\n    // remove the last field &amp;\n    tempObj.pop()\n    return tempObj.join(&#39;&#39;)\n}\ntransformParamToUrl(searchParam)\n// name=Bob&amp;age=20&amp;phone=18888888888\n</code></pre>\n<p>我们得到了拼接好的URL，并且未将无效值加入.</p>\n<h3 id=\"解析URL参数\"><a href=\"#解析URL参数\" class=\"headerlink\" title=\"解析URL参数\"></a>解析URL参数</h3><p>我们拼接了URl，下面讲下如何解析URL参数.</p>\n<pre><code class=\"js\">const flatten = (arr) =&gt; \n    arr.reduce((initial, curr, index) =&gt; \n    Array.isArray(curr) ? initial.concat(flatten(curr)) : initial.concat(curr), [])\n\nconst parseQuery = (query) =&gt; {\n    const regexp = /(\\w+)=([^&amp;]+)/g\n    const result = {}\n    let match\n\n    while(match = regexp.exec(query)) {\n        let key = match[1], value = match[2].replace(/\\n/g, &#39;&#39;)\n        result[key] ? result[key] = flatten([result[key], value]) : result[key] = value\n    }\n\n    return result\n}\n\n// example:\nconst query = `\nhttps://www.baidu.com/s?ie=utf8&amp;f=8&amp;f=90&amp;rsv_bp=1&amp;rsv_idx=1&amp;rsv_bp=1&amp;tn=baidu&amp;wd=%E6%B0%B4%E7%94%B5%E8%B4%B9&amp;rsv_pq=c7797024000434a8&amp;rsv_t=b786FJnGwOOxPk7E7gsn1VbYHpmSP93UpP1470GL9ajYJkd09MOyBzSTsVk&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=5&amp;rsv_sug1=4&amp;rsv_sug7=101&amp;rsv_bp=234&amp;rsv_sug2=0&amp;inputT=1760&amp;rsv_sug4=2010&amp;jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM\n`.split(&#39;?&#39;)[1]\n\nparseQuery(query)\n\n// { \n//   ie: &#39;utf8&#39;,\n//   f: [ &#39;8&#39;, &#39;90&#39; ],\n//   rsv_bp: [ &#39;1&#39;, &#39;1&#39;, &#39;234&#39; ],\n//   rsv_idx: &#39;1&#39;,\n//   tn: &#39;baidu&#39;,\n//   rsv_pq: &#39;c7797024000434a8&#39;,\n//   rsv_t: &#39;b786FJnGwOOxPk7E7gsn1VbYHpmSP93UpP1470GL9ajYJkd09MOyBzSTsVk&#39;,\n//   rqlang: &#39;cn&#39;,\n//   rsv_enter: &#39;1&#39;,\n//   rsv_dl: &#39;tb&#39;,\n//   rsv_sug3: &#39;5&#39;,\n//   rsv_sug1: &#39;4&#39;,\n//   rsv_sug7: &#39;101&#39;,\n//   rsv_sug2: &#39;0&#39;,\n//   inputT: &#39;1760&#39;,\n//   rsv_sug4: &#39;2010&#39; \n// }\n</code></pre>\n<p>我们得到了预期的解析数据，并且相同的key进行了数组化存储.</p>\n<h3 id=\"在线小Demo\"><a href=\"#在线小Demo\" class=\"headerlink\" title=\"在线小Demo\"></a>在线小Demo</h3><p>Demo仅做参考，请看代码请看上面👆.<br><a href=\"https://biyuqi.github.io/demo/src/html/url.html\" target=\"_blank\" rel=\"external\">DEMO</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>请求的URL后面带参数在项目中是很常见的，常用在的地方比如跳转到新页面或者搜索关键词等，刚好项目用到，就写了我认为比较简便的方法提取参数</p>\n</blockquote>","more":"<h3 id=\"最常见的形式\"><a href=\"#最常见的形式\" class=\"headerlink\" title=\"最常见的形式\"></a>最常见的形式</h3><pre><code class=\"javascript\"> url?arg1=value1&amp;arg2=value2&amp;arg3=value3...\n</code></pre>\n<h3 id=\"如何拼接URL？\"><a href=\"#如何拼接URL？\" class=\"headerlink\" title=\"如何拼接URL？\"></a>如何拼接URL？</h3><p>假如一个查询系统有很多字段,刚好需要拼接URl的形式进行查询，此刻我们可以采用对象过滤的方法进行转换：</p>\n<pre><code class=\"js\">const searchParam = {\n    name: &#39;Bob&#39;,\n    age: 20,\n    address: &#39;&#39;,\n    phone: 18888888888\n}\n\nconst transformParamToUrl = (param) =&gt; {\n    const tempObj = []\n    if (!param || typeof param !== &#39;object&#39;) {\n        return\n    }\n\n    for (let i in param) {\n        if (param.hasOwnProperty(i) &amp;&amp; param[i]) {\n            tempObj.push(i)\n            tempObj.push(&#39;=&#39;)\n            tempObj.push(param[i])\n            tempObj.push(&#39;&amp;&#39;)\n        }\n    }\n    // remove the last field &amp;\n    tempObj.pop()\n    return tempObj.join(&#39;&#39;)\n}\ntransformParamToUrl(searchParam)\n// name=Bob&amp;age=20&amp;phone=18888888888\n</code></pre>\n<p>我们得到了拼接好的URL，并且未将无效值加入.</p>\n<h3 id=\"解析URL参数\"><a href=\"#解析URL参数\" class=\"headerlink\" title=\"解析URL参数\"></a>解析URL参数</h3><p>我们拼接了URl，下面讲下如何解析URL参数.</p>\n<pre><code class=\"js\">const flatten = (arr) =&gt; \n    arr.reduce((initial, curr, index) =&gt; \n    Array.isArray(curr) ? initial.concat(flatten(curr)) : initial.concat(curr), [])\n\nconst parseQuery = (query) =&gt; {\n    const regexp = /(\\w+)=([^&amp;]+)/g\n    const result = {}\n    let match\n\n    while(match = regexp.exec(query)) {\n        let key = match[1], value = match[2].replace(/\\n/g, &#39;&#39;)\n        result[key] ? result[key] = flatten([result[key], value]) : result[key] = value\n    }\n\n    return result\n}\n\n// example:\nconst query = `\nhttps://www.baidu.com/s?ie=utf8&amp;f=8&amp;f=90&amp;rsv_bp=1&amp;rsv_idx=1&amp;rsv_bp=1&amp;tn=baidu&amp;wd=%E6%B0%B4%E7%94%B5%E8%B4%B9&amp;rsv_pq=c7797024000434a8&amp;rsv_t=b786FJnGwOOxPk7E7gsn1VbYHpmSP93UpP1470GL9ajYJkd09MOyBzSTsVk&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=5&amp;rsv_sug1=4&amp;rsv_sug7=101&amp;rsv_bp=234&amp;rsv_sug2=0&amp;inputT=1760&amp;rsv_sug4=2010&amp;jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM\n`.split(&#39;?&#39;)[1]\n\nparseQuery(query)\n\n// { \n//   ie: &#39;utf8&#39;,\n//   f: [ &#39;8&#39;, &#39;90&#39; ],\n//   rsv_bp: [ &#39;1&#39;, &#39;1&#39;, &#39;234&#39; ],\n//   rsv_idx: &#39;1&#39;,\n//   tn: &#39;baidu&#39;,\n//   rsv_pq: &#39;c7797024000434a8&#39;,\n//   rsv_t: &#39;b786FJnGwOOxPk7E7gsn1VbYHpmSP93UpP1470GL9ajYJkd09MOyBzSTsVk&#39;,\n//   rqlang: &#39;cn&#39;,\n//   rsv_enter: &#39;1&#39;,\n//   rsv_dl: &#39;tb&#39;,\n//   rsv_sug3: &#39;5&#39;,\n//   rsv_sug1: &#39;4&#39;,\n//   rsv_sug7: &#39;101&#39;,\n//   rsv_sug2: &#39;0&#39;,\n//   inputT: &#39;1760&#39;,\n//   rsv_sug4: &#39;2010&#39; \n// }\n</code></pre>\n<p>我们得到了预期的解析数据，并且相同的key进行了数组化存储.</p>\n<h3 id=\"在线小Demo\"><a href=\"#在线小Demo\" class=\"headerlink\" title=\"在线小Demo\"></a>在线小Demo</h3><p>Demo仅做参考，请看代码请看上面👆.<br><a href=\"https://biyuqi.github.io/demo/src/html/url.html\" target=\"_blank\" rel=\"external\">DEMO</a></p>"},{"title":"学习下如何优雅的写表单验证","date":"2017-05-14T11:44:53.000Z","_content":"> 最近项目挺赶,博客许久没更新(借口~),周末充下电,表单是一个项目中必不可少的模块了，像注册，登录等。学习下解决下工作中关于表单验证这块的问题\n\n<!-- more -->\n### DEMO\ndemo源码可能与博客有些略微不同(但是核心思想一模一样)\n[线上案例](http://loadingmore.com/demo/src/html/form-opt.html)\n\n### 问题\n看看平时我写表单的代码风格吧(求轻喷~)\n```javascript\nif(userName.value === ''){\n    console.log(\"姓名不为空\");\n    return;\n}\nif(!reg.test(userName.value)){\n    console.log(\"姓名不合格\");\n    return;\n}\nif(userPass.value === ''){\n    //.........\n}\nif(userPass.value !=== reUserPass.value){\n    console.log(\"密码不一致\");\n    return;\n}\nif(mobile.value === ''){\n    console.log(\"手机号码不能为空\");\n    return;\n}\n//此处略去n多if-esle\n```\n这样编写代码对于实现业务需求来说是没有问题的，但是总觉得哪里怪怪的:\n> * 我有密集恐惧症，那么多的if-else看着怪恶心的\n* 验证的规则复用性太差了,哪里需要，只是拷贝来，粘贴过去,飞来飞去\n* 这样的代码容易被喷，不容易维护\n\n### 怎么解决呢\n假如我们不想使用那么多的if语句，那么你心中理想的验证表单的方式是什么呢？写一系列规则，最后一步验证，这样写起来很嗨吧\n```javascript\n// 首页获取form元素\nvar registerForm = document.querySelector('#re-form');\n\n// 创建实例\nvar validator = new Validator();\n\nvalidator.add(registerForm.userName,'isEmpty','用户名不能为空');\nvalidator.add(registerForm.userPass,'minLength:6','密码至少六位');\n\n//校验信息\nvar errorMsg = validator.start();\n\nif(errorMsg){\n    console.log(errorMsg);\n}\n```\n如果能这样写那就太爽了,很优雅,很方便,下一步需要了解下什么是策略模式\n\n### 策略模式\n所谓策略就是做事情的方法,好比玩三国杀，每个人都有自己的技能，每个人物都有自己的制胜策略;比如去旅游,就有很多种路线供你选择，要么坐飞机，要么坐高铁，要么徒步;\n\n所以，做一件事情会有很多种方法,接下来编码也会以这种方式进行;核心思想是，将要做什么和谁去做进行分离。一个完整的策略需要两个类：策略类,环境类;环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展。\n在表单验证的例子中，各种验证的方法组成了策略类，比如：判断是否为空的方法(如：isNonEmpty)，判断最小长度的方法(如：minLength)，判断是否为手机号的方法(isMoblie)等等，他们组成了策略类，供给环境类去委托请求。下面，我们就来实战一下。\n### 策略类\n```javascript\n// 完成我们的策略表 (自由定制)\nvar ruleList = {\n    //验证为空\n    isEmpoty: function(value,errorMsg){\n        if(value == ''){\n            return errorMsg;\n        }\n    },\n    //验证最小长度\n    minLength: function(value,len,errorMsg){\n        if(value.length < len){\n            return errorMsg;\n        }\n    },\n    //验证手机号\n    isMobile: function(value,errorMsg){\n        if(!/^1\\d{10}$/.test(value)){\n            return errorMsg;\n        }\n    }\n};\n```\n### 环境类\n根据之前的畅想：\n```js\nvalidator.add(registerForm.userName,'isEmpty','用户名不能为空');\nvalidator.add(registerForm.userName,'isMobile','手机号码有误');\n```\n我们可能需要创建一个类，类里面有两个方法 add()add()接收三个参数，第一个是表单字段(校验对象),第二个是策略方法名字,使用冒号(:)分隔，亲一个是方法名字，后一个是传给该方法的参数(如长度),第三个是验证不通过的返回信息;\n然后用start方法进行验证：\n```js\nvar errorMsg = validation.start();\n```\n但是这种参数配置还是有问题，我们的要求是多种校验规则，比如用户名既不能为空，又要满足用户名长度不小于6，并不是单一的，上面的为什么要写两次，这种看着就不舒服，这时候我就需要对配置参数做一点小小的改动，我们用数组来传递多个校验规则：\n```js\n//最终实现\nvalidator.add(registerForm.username, [{\n    strategy: 'isEmpty',\n    errorMsg: '用户名不能为空！'\n}, {\n    strategy: 'minLength:6',\n    errorMsg: '用户名长度不能小于6位！'\n}])\n```\n\n### 实现\n```js\nvar FormValidator = function(ruleList){\n    //保存策略规则列表\n    this.strategies = ruleList;\n    //储存规则方法\n    this.validationFns = [];\n};\nFormValidator.prototype = {\n    add:function(dom,rule){\n        var that = this;\n        for(var i=0;i<rule.length;i++){\n            // 这里使用闭包储存i 动态添加方法\n            (function(i){\n                //\n                that.validationFns.push(function(){\n                    /*\n                    * aryNames 规则名字(包含传的参数minLeng:6) 所以需要动态的解析\n                    * errorMsg 错误信息\n                    * rulename 方法名字\n                    * dataArr 储存参数 value method名字 错误信息\n                    * strategies 使用apply 向指定方法传参数\n                     */\n                    var aryNames = rule[i].strategy.split(':'),\n                        errorMsg = rule[i].errorMsg,\n                        rulename = aryNames[0],\n                        dataArr = [];\n                        dataArr.push(dom.value);\n                        if(aryNames[1]){\n                            dataArr.push(aryNames[1]);\n                        }\n                        dataArr.push(errorMsg);\n                    return that.strategies[rulename].apply(dom,dataArr);\n                })\n            })(i)\n        }\n    },\n    start:function(){\n        var that = this;\n        // 遍历规则集合 抛出错误\n        for(i in that.validationFns){\n            var msg = that.validationFns[i]();\n            if(msg){\n                return msg;\n            }\n        }\n    }\n};\n```\n** 规则集合**\n```js\n// 规则集合\nvar rules = {\n    //验证为空\n    isEmpoty: function(value,errorMsg){\n        if(value == ''){\n            return errorMsg;\n        }\n    },\n    //验证最小长度\n    minLength: function(value,len,errorMsg){\n        if(value.length < len){\n            return errorMsg;\n        }\n    },\n    //验证手机号\n    isMobile: function(value,errorMsg){\n        if(!/^1\\d{10}$/.test(value)){\n            return errorMsg;\n        }\n    }\n};\n```\n** 客户端调用代码方法**\n```html\n<form id=\"submit\">\n    <input type=\"text\" class=\"username\" name=\"username\">\n    <input type=\"text\" class=\"userpass\" name=\"userpass\">\n</form>\n<div class=\"btn\">提交</div>\n```\n```js\nvar forms = document.querySelector('#submit');\nvar btn = document.querySelector('.btn');\n\n// 构造函数 传入规则\nvar validation = new FormValidator(rules);\n// 直接调用规则方法即可 返回错误信息\nfunction getErrorMsg(){\n    // 直接调用规则方法即可\n    validation.add(forms.username,[\n        {\n            strategy:'isEmpoty', //strategy 为固定字段\n            errorMsg:'用户名不能为空' //errorMsg 为固定字段\n        },\n        {\n            strategy:'minLength:6',\n            errorMsg:'用户名长度最低6位'\n        }\n    ]);\n    validation.add(forms.userpass,[\n        {\n            strategy:'isMobile',\n            errorMsg:'手机号码有误'\n        }\n    ]);\n\n    var error = validation.start();\n    return error;\n}\n// 点击事件\nbtn.addEventListener('click',function(){\n    var msg = getErrorMsg();\n    if(msg){\n        console.log(msg)//错误提示\n    }else{\n        //在此提交数据\n    }\n},false)\n```\n在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如我们想要将用户名输入框的校验规则改成用户名不能少于4个字符。可以看到，这时候的修改是毫不费力的。代码如下：\n```js\n// 更具体的方法 可以在rules中修改\nvalidation.add(forms.username, [{\n        strategy: 'isNonEmpty',\n        errorMsg: '用户名不能为空！'\n    }, {\n        strategy: 'minLength:4',\n        errorMsg: '用户名长度不能小于4位！'\n    }])\n```\n参考：\n[策略模式在表单中的应用](http://hcysun.me/2016/02/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/\n)\n","source":"_posts/学习下如何优雅的写表单验证.md","raw":"---\ntitle: 学习下如何优雅的写表单验证\ndate: 2017-05-14 19:44:53\ntags: [javascript]\ncategories: Javascript\n---\n> 最近项目挺赶,博客许久没更新(借口~),周末充下电,表单是一个项目中必不可少的模块了，像注册，登录等。学习下解决下工作中关于表单验证这块的问题\n\n<!-- more -->\n### DEMO\ndemo源码可能与博客有些略微不同(但是核心思想一模一样)\n[线上案例](http://loadingmore.com/demo/src/html/form-opt.html)\n\n### 问题\n看看平时我写表单的代码风格吧(求轻喷~)\n```javascript\nif(userName.value === ''){\n    console.log(\"姓名不为空\");\n    return;\n}\nif(!reg.test(userName.value)){\n    console.log(\"姓名不合格\");\n    return;\n}\nif(userPass.value === ''){\n    //.........\n}\nif(userPass.value !=== reUserPass.value){\n    console.log(\"密码不一致\");\n    return;\n}\nif(mobile.value === ''){\n    console.log(\"手机号码不能为空\");\n    return;\n}\n//此处略去n多if-esle\n```\n这样编写代码对于实现业务需求来说是没有问题的，但是总觉得哪里怪怪的:\n> * 我有密集恐惧症，那么多的if-else看着怪恶心的\n* 验证的规则复用性太差了,哪里需要，只是拷贝来，粘贴过去,飞来飞去\n* 这样的代码容易被喷，不容易维护\n\n### 怎么解决呢\n假如我们不想使用那么多的if语句，那么你心中理想的验证表单的方式是什么呢？写一系列规则，最后一步验证，这样写起来很嗨吧\n```javascript\n// 首页获取form元素\nvar registerForm = document.querySelector('#re-form');\n\n// 创建实例\nvar validator = new Validator();\n\nvalidator.add(registerForm.userName,'isEmpty','用户名不能为空');\nvalidator.add(registerForm.userPass,'minLength:6','密码至少六位');\n\n//校验信息\nvar errorMsg = validator.start();\n\nif(errorMsg){\n    console.log(errorMsg);\n}\n```\n如果能这样写那就太爽了,很优雅,很方便,下一步需要了解下什么是策略模式\n\n### 策略模式\n所谓策略就是做事情的方法,好比玩三国杀，每个人都有自己的技能，每个人物都有自己的制胜策略;比如去旅游,就有很多种路线供你选择，要么坐飞机，要么坐高铁，要么徒步;\n\n所以，做一件事情会有很多种方法,接下来编码也会以这种方式进行;核心思想是，将要做什么和谁去做进行分离。一个完整的策略需要两个类：策略类,环境类;环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展。\n在表单验证的例子中，各种验证的方法组成了策略类，比如：判断是否为空的方法(如：isNonEmpty)，判断最小长度的方法(如：minLength)，判断是否为手机号的方法(isMoblie)等等，他们组成了策略类，供给环境类去委托请求。下面，我们就来实战一下。\n### 策略类\n```javascript\n// 完成我们的策略表 (自由定制)\nvar ruleList = {\n    //验证为空\n    isEmpoty: function(value,errorMsg){\n        if(value == ''){\n            return errorMsg;\n        }\n    },\n    //验证最小长度\n    minLength: function(value,len,errorMsg){\n        if(value.length < len){\n            return errorMsg;\n        }\n    },\n    //验证手机号\n    isMobile: function(value,errorMsg){\n        if(!/^1\\d{10}$/.test(value)){\n            return errorMsg;\n        }\n    }\n};\n```\n### 环境类\n根据之前的畅想：\n```js\nvalidator.add(registerForm.userName,'isEmpty','用户名不能为空');\nvalidator.add(registerForm.userName,'isMobile','手机号码有误');\n```\n我们可能需要创建一个类，类里面有两个方法 add()add()接收三个参数，第一个是表单字段(校验对象),第二个是策略方法名字,使用冒号(:)分隔，亲一个是方法名字，后一个是传给该方法的参数(如长度),第三个是验证不通过的返回信息;\n然后用start方法进行验证：\n```js\nvar errorMsg = validation.start();\n```\n但是这种参数配置还是有问题，我们的要求是多种校验规则，比如用户名既不能为空，又要满足用户名长度不小于6，并不是单一的，上面的为什么要写两次，这种看着就不舒服，这时候我就需要对配置参数做一点小小的改动，我们用数组来传递多个校验规则：\n```js\n//最终实现\nvalidator.add(registerForm.username, [{\n    strategy: 'isEmpty',\n    errorMsg: '用户名不能为空！'\n}, {\n    strategy: 'minLength:6',\n    errorMsg: '用户名长度不能小于6位！'\n}])\n```\n\n### 实现\n```js\nvar FormValidator = function(ruleList){\n    //保存策略规则列表\n    this.strategies = ruleList;\n    //储存规则方法\n    this.validationFns = [];\n};\nFormValidator.prototype = {\n    add:function(dom,rule){\n        var that = this;\n        for(var i=0;i<rule.length;i++){\n            // 这里使用闭包储存i 动态添加方法\n            (function(i){\n                //\n                that.validationFns.push(function(){\n                    /*\n                    * aryNames 规则名字(包含传的参数minLeng:6) 所以需要动态的解析\n                    * errorMsg 错误信息\n                    * rulename 方法名字\n                    * dataArr 储存参数 value method名字 错误信息\n                    * strategies 使用apply 向指定方法传参数\n                     */\n                    var aryNames = rule[i].strategy.split(':'),\n                        errorMsg = rule[i].errorMsg,\n                        rulename = aryNames[0],\n                        dataArr = [];\n                        dataArr.push(dom.value);\n                        if(aryNames[1]){\n                            dataArr.push(aryNames[1]);\n                        }\n                        dataArr.push(errorMsg);\n                    return that.strategies[rulename].apply(dom,dataArr);\n                })\n            })(i)\n        }\n    },\n    start:function(){\n        var that = this;\n        // 遍历规则集合 抛出错误\n        for(i in that.validationFns){\n            var msg = that.validationFns[i]();\n            if(msg){\n                return msg;\n            }\n        }\n    }\n};\n```\n** 规则集合**\n```js\n// 规则集合\nvar rules = {\n    //验证为空\n    isEmpoty: function(value,errorMsg){\n        if(value == ''){\n            return errorMsg;\n        }\n    },\n    //验证最小长度\n    minLength: function(value,len,errorMsg){\n        if(value.length < len){\n            return errorMsg;\n        }\n    },\n    //验证手机号\n    isMobile: function(value,errorMsg){\n        if(!/^1\\d{10}$/.test(value)){\n            return errorMsg;\n        }\n    }\n};\n```\n** 客户端调用代码方法**\n```html\n<form id=\"submit\">\n    <input type=\"text\" class=\"username\" name=\"username\">\n    <input type=\"text\" class=\"userpass\" name=\"userpass\">\n</form>\n<div class=\"btn\">提交</div>\n```\n```js\nvar forms = document.querySelector('#submit');\nvar btn = document.querySelector('.btn');\n\n// 构造函数 传入规则\nvar validation = new FormValidator(rules);\n// 直接调用规则方法即可 返回错误信息\nfunction getErrorMsg(){\n    // 直接调用规则方法即可\n    validation.add(forms.username,[\n        {\n            strategy:'isEmpoty', //strategy 为固定字段\n            errorMsg:'用户名不能为空' //errorMsg 为固定字段\n        },\n        {\n            strategy:'minLength:6',\n            errorMsg:'用户名长度最低6位'\n        }\n    ]);\n    validation.add(forms.userpass,[\n        {\n            strategy:'isMobile',\n            errorMsg:'手机号码有误'\n        }\n    ]);\n\n    var error = validation.start();\n    return error;\n}\n// 点击事件\nbtn.addEventListener('click',function(){\n    var msg = getErrorMsg();\n    if(msg){\n        console.log(msg)//错误提示\n    }else{\n        //在此提交数据\n    }\n},false)\n```\n在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如我们想要将用户名输入框的校验规则改成用户名不能少于4个字符。可以看到，这时候的修改是毫不费力的。代码如下：\n```js\n// 更具体的方法 可以在rules中修改\nvalidation.add(forms.username, [{\n        strategy: 'isNonEmpty',\n        errorMsg: '用户名不能为空！'\n    }, {\n        strategy: 'minLength:4',\n        errorMsg: '用户名长度不能小于4位！'\n    }])\n```\n参考：\n[策略模式在表单中的应用](http://hcysun.me/2016/02/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/\n)\n","slug":"学习下如何优雅的写表单验证","published":1,"updated":"2019-09-25T15:10:25.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pn004rla2eqvh495r2","content":"<blockquote>\n<p>最近项目挺赶,博客许久没更新(借口~),周末充下电,表单是一个项目中必不可少的模块了，像注册，登录等。学习下解决下工作中关于表单验证这块的问题</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h3><p>demo源码可能与博客有些略微不同(但是核心思想一模一样)<br><a href=\"http://loadingmore.com/demo/src/html/form-opt.html\">线上案例</a></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>看看平时我写表单的代码风格吧(求轻喷~)</p>\n<pre><code class=\"javascript\">if(userName.value === &#39;&#39;){\n    console.log(&quot;姓名不为空&quot;);\n    return;\n}\nif(!reg.test(userName.value)){\n    console.log(&quot;姓名不合格&quot;);\n    return;\n}\nif(userPass.value === &#39;&#39;){\n    //.........\n}\nif(userPass.value !=== reUserPass.value){\n    console.log(&quot;密码不一致&quot;);\n    return;\n}\nif(mobile.value === &#39;&#39;){\n    console.log(&quot;手机号码不能为空&quot;);\n    return;\n}\n//此处略去n多if-esle\n</code></pre>\n<p>这样编写代码对于实现业务需求来说是没有问题的，但是总觉得哪里怪怪的:</p>\n<blockquote>\n<ul>\n<li>我有密集恐惧症，那么多的if-else看着怪恶心的</li>\n<li>验证的规则复用性太差了,哪里需要，只是拷贝来，粘贴过去,飞来飞去</li>\n<li>这样的代码容易被喷，不容易维护</li>\n</ul>\n</blockquote>\n<h3 id=\"怎么解决呢\"><a href=\"#怎么解决呢\" class=\"headerlink\" title=\"怎么解决呢\"></a>怎么解决呢</h3><p>假如我们不想使用那么多的if语句，那么你心中理想的验证表单的方式是什么呢？写一系列规则，最后一步验证，这样写起来很嗨吧</p>\n<pre><code class=\"javascript\">// 首页获取form元素\nvar registerForm = document.querySelector(&#39;#re-form&#39;);\n\n// 创建实例\nvar validator = new Validator();\n\nvalidator.add(registerForm.userName,&#39;isEmpty&#39;,&#39;用户名不能为空&#39;);\nvalidator.add(registerForm.userPass,&#39;minLength:6&#39;,&#39;密码至少六位&#39;);\n\n//校验信息\nvar errorMsg = validator.start();\n\nif(errorMsg){\n    console.log(errorMsg);\n}\n</code></pre>\n<p>如果能这样写那就太爽了,很优雅,很方便,下一步需要了解下什么是策略模式</p>\n<h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><p>所谓策略就是做事情的方法,好比玩三国杀，每个人都有自己的技能，每个人物都有自己的制胜策略;比如去旅游,就有很多种路线供你选择，要么坐飞机，要么坐高铁，要么徒步;</p>\n<p>所以，做一件事情会有很多种方法,接下来编码也会以这种方式进行;核心思想是，将要做什么和谁去做进行分离。一个完整的策略需要两个类：策略类,环境类;环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展。<br>在表单验证的例子中，各种验证的方法组成了策略类，比如：判断是否为空的方法(如：isNonEmpty)，判断最小长度的方法(如：minLength)，判断是否为手机号的方法(isMoblie)等等，他们组成了策略类，供给环境类去委托请求。下面，我们就来实战一下。</p>\n<h3 id=\"策略类\"><a href=\"#策略类\" class=\"headerlink\" title=\"策略类\"></a>策略类</h3><pre><code class=\"javascript\">// 完成我们的策略表 (自由定制)\nvar ruleList = {\n    //验证为空\n    isEmpoty: function(value,errorMsg){\n        if(value == &#39;&#39;){\n            return errorMsg;\n        }\n    },\n    //验证最小长度\n    minLength: function(value,len,errorMsg){\n        if(value.length &lt; len){\n            return errorMsg;\n        }\n    },\n    //验证手机号\n    isMobile: function(value,errorMsg){\n        if(!/^1\\d{10}$/.test(value)){\n            return errorMsg;\n        }\n    }\n};\n</code></pre>\n<h3 id=\"环境类\"><a href=\"#环境类\" class=\"headerlink\" title=\"环境类\"></a>环境类</h3><p>根据之前的畅想：</p>\n<pre><code class=\"js\">validator.add(registerForm.userName,&#39;isEmpty&#39;,&#39;用户名不能为空&#39;);\nvalidator.add(registerForm.userName,&#39;isMobile&#39;,&#39;手机号码有误&#39;);\n</code></pre>\n<p>我们可能需要创建一个类，类里面有两个方法 add()add()接收三个参数，第一个是表单字段(校验对象),第二个是策略方法名字,使用冒号(:)分隔，亲一个是方法名字，后一个是传给该方法的参数(如长度),第三个是验证不通过的返回信息;<br>然后用start方法进行验证：</p>\n<pre><code class=\"js\">var errorMsg = validation.start();\n</code></pre>\n<p>但是这种参数配置还是有问题，我们的要求是多种校验规则，比如用户名既不能为空，又要满足用户名长度不小于6，并不是单一的，上面的为什么要写两次，这种看着就不舒服，这时候我就需要对配置参数做一点小小的改动，我们用数组来传递多个校验规则：</p>\n<pre><code class=\"js\">//最终实现\nvalidator.add(registerForm.username, [{\n    strategy: &#39;isEmpty&#39;,\n    errorMsg: &#39;用户名不能为空！&#39;\n}, {\n    strategy: &#39;minLength:6&#39;,\n    errorMsg: &#39;用户名长度不能小于6位！&#39;\n}])\n</code></pre>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><pre><code class=\"js\">var FormValidator = function(ruleList){\n    //保存策略规则列表\n    this.strategies = ruleList;\n    //储存规则方法\n    this.validationFns = [];\n};\nFormValidator.prototype = {\n    add:function(dom,rule){\n        var that = this;\n        for(var i=0;i&lt;rule.length;i++){\n            // 这里使用闭包储存i 动态添加方法\n            (function(i){\n                //\n                that.validationFns.push(function(){\n                    /*\n                    * aryNames 规则名字(包含传的参数minLeng:6) 所以需要动态的解析\n                    * errorMsg 错误信息\n                    * rulename 方法名字\n                    * dataArr 储存参数 value method名字 错误信息\n                    * strategies 使用apply 向指定方法传参数\n                     */\n                    var aryNames = rule[i].strategy.split(&#39;:&#39;),\n                        errorMsg = rule[i].errorMsg,\n                        rulename = aryNames[0],\n                        dataArr = [];\n                        dataArr.push(dom.value);\n                        if(aryNames[1]){\n                            dataArr.push(aryNames[1]);\n                        }\n                        dataArr.push(errorMsg);\n                    return that.strategies[rulename].apply(dom,dataArr);\n                })\n            })(i)\n        }\n    },\n    start:function(){\n        var that = this;\n        // 遍历规则集合 抛出错误\n        for(i in that.validationFns){\n            var msg = that.validationFns[i]();\n            if(msg){\n                return msg;\n            }\n        }\n    }\n};\n</code></pre>\n<p><strong> 规则集合</strong></p>\n<pre><code class=\"js\">// 规则集合\nvar rules = {\n    //验证为空\n    isEmpoty: function(value,errorMsg){\n        if(value == &#39;&#39;){\n            return errorMsg;\n        }\n    },\n    //验证最小长度\n    minLength: function(value,len,errorMsg){\n        if(value.length &lt; len){\n            return errorMsg;\n        }\n    },\n    //验证手机号\n    isMobile: function(value,errorMsg){\n        if(!/^1\\d{10}$/.test(value)){\n            return errorMsg;\n        }\n    }\n};\n</code></pre>\n<p><strong> 客户端调用代码方法</strong></p>\n<pre><code class=\"html\">&lt;form id=&quot;submit&quot;&gt;\n    &lt;input type=&quot;text&quot; class=&quot;username&quot; name=&quot;username&quot;&gt;\n    &lt;input type=&quot;text&quot; class=&quot;userpass&quot; name=&quot;userpass&quot;&gt;\n&lt;/form&gt;\n&lt;div class=&quot;btn&quot;&gt;提交&lt;/div&gt;\n</code></pre>\n<pre><code class=\"js\">var forms = document.querySelector(&#39;#submit&#39;);\nvar btn = document.querySelector(&#39;.btn&#39;);\n\n// 构造函数 传入规则\nvar validation = new FormValidator(rules);\n// 直接调用规则方法即可 返回错误信息\nfunction getErrorMsg(){\n    // 直接调用规则方法即可\n    validation.add(forms.username,[\n        {\n            strategy:&#39;isEmpoty&#39;, //strategy 为固定字段\n            errorMsg:&#39;用户名不能为空&#39; //errorMsg 为固定字段\n        },\n        {\n            strategy:&#39;minLength:6&#39;,\n            errorMsg:&#39;用户名长度最低6位&#39;\n        }\n    ]);\n    validation.add(forms.userpass,[\n        {\n            strategy:&#39;isMobile&#39;,\n            errorMsg:&#39;手机号码有误&#39;\n        }\n    ]);\n\n    var error = validation.start();\n    return error;\n}\n// 点击事件\nbtn.addEventListener(&#39;click&#39;,function(){\n    var msg = getErrorMsg();\n    if(msg){\n        console.log(msg)//错误提示\n    }else{\n        //在此提交数据\n    }\n},false)\n</code></pre>\n<p>在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如我们想要将用户名输入框的校验规则改成用户名不能少于4个字符。可以看到，这时候的修改是毫不费力的。代码如下：</p>\n<pre><code class=\"js\">// 更具体的方法 可以在rules中修改\nvalidation.add(forms.username, [{\n        strategy: &#39;isNonEmpty&#39;,\n        errorMsg: &#39;用户名不能为空！&#39;\n    }, {\n        strategy: &#39;minLength:4&#39;,\n        errorMsg: &#39;用户名长度不能小于4位！&#39;\n    }])\n</code></pre>\n<p>参考：<br><a href=\"http://hcysun.me/2016/02/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/\" target=\"_blank\" rel=\"external\">策略模式在表单中的应用</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近项目挺赶,博客许久没更新(借口~),周末充下电,表单是一个项目中必不可少的模块了，像注册，登录等。学习下解决下工作中关于表单验证这块的问题</p>\n</blockquote>","more":"<h3 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h3><p>demo源码可能与博客有些略微不同(但是核心思想一模一样)<br><a href=\"http://loadingmore.com/demo/src/html/form-opt.html\">线上案例</a></p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>看看平时我写表单的代码风格吧(求轻喷~)</p>\n<pre><code class=\"javascript\">if(userName.value === &#39;&#39;){\n    console.log(&quot;姓名不为空&quot;);\n    return;\n}\nif(!reg.test(userName.value)){\n    console.log(&quot;姓名不合格&quot;);\n    return;\n}\nif(userPass.value === &#39;&#39;){\n    //.........\n}\nif(userPass.value !=== reUserPass.value){\n    console.log(&quot;密码不一致&quot;);\n    return;\n}\nif(mobile.value === &#39;&#39;){\n    console.log(&quot;手机号码不能为空&quot;);\n    return;\n}\n//此处略去n多if-esle\n</code></pre>\n<p>这样编写代码对于实现业务需求来说是没有问题的，但是总觉得哪里怪怪的:</p>\n<blockquote>\n<ul>\n<li>我有密集恐惧症，那么多的if-else看着怪恶心的</li>\n<li>验证的规则复用性太差了,哪里需要，只是拷贝来，粘贴过去,飞来飞去</li>\n<li>这样的代码容易被喷，不容易维护</li>\n</ul>\n</blockquote>\n<h3 id=\"怎么解决呢\"><a href=\"#怎么解决呢\" class=\"headerlink\" title=\"怎么解决呢\"></a>怎么解决呢</h3><p>假如我们不想使用那么多的if语句，那么你心中理想的验证表单的方式是什么呢？写一系列规则，最后一步验证，这样写起来很嗨吧</p>\n<pre><code class=\"javascript\">// 首页获取form元素\nvar registerForm = document.querySelector(&#39;#re-form&#39;);\n\n// 创建实例\nvar validator = new Validator();\n\nvalidator.add(registerForm.userName,&#39;isEmpty&#39;,&#39;用户名不能为空&#39;);\nvalidator.add(registerForm.userPass,&#39;minLength:6&#39;,&#39;密码至少六位&#39;);\n\n//校验信息\nvar errorMsg = validator.start();\n\nif(errorMsg){\n    console.log(errorMsg);\n}\n</code></pre>\n<p>如果能这样写那就太爽了,很优雅,很方便,下一步需要了解下什么是策略模式</p>\n<h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><p>所谓策略就是做事情的方法,好比玩三国杀，每个人都有自己的技能，每个人物都有自己的制胜策略;比如去旅游,就有很多种路线供你选择，要么坐飞机，要么坐高铁，要么徒步;</p>\n<p>所以，做一件事情会有很多种方法,接下来编码也会以这种方式进行;核心思想是，将要做什么和谁去做进行分离。一个完整的策略需要两个类：策略类,环境类;环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展。<br>在表单验证的例子中，各种验证的方法组成了策略类，比如：判断是否为空的方法(如：isNonEmpty)，判断最小长度的方法(如：minLength)，判断是否为手机号的方法(isMoblie)等等，他们组成了策略类，供给环境类去委托请求。下面，我们就来实战一下。</p>\n<h3 id=\"策略类\"><a href=\"#策略类\" class=\"headerlink\" title=\"策略类\"></a>策略类</h3><pre><code class=\"javascript\">// 完成我们的策略表 (自由定制)\nvar ruleList = {\n    //验证为空\n    isEmpoty: function(value,errorMsg){\n        if(value == &#39;&#39;){\n            return errorMsg;\n        }\n    },\n    //验证最小长度\n    minLength: function(value,len,errorMsg){\n        if(value.length &lt; len){\n            return errorMsg;\n        }\n    },\n    //验证手机号\n    isMobile: function(value,errorMsg){\n        if(!/^1\\d{10}$/.test(value)){\n            return errorMsg;\n        }\n    }\n};\n</code></pre>\n<h3 id=\"环境类\"><a href=\"#环境类\" class=\"headerlink\" title=\"环境类\"></a>环境类</h3><p>根据之前的畅想：</p>\n<pre><code class=\"js\">validator.add(registerForm.userName,&#39;isEmpty&#39;,&#39;用户名不能为空&#39;);\nvalidator.add(registerForm.userName,&#39;isMobile&#39;,&#39;手机号码有误&#39;);\n</code></pre>\n<p>我们可能需要创建一个类，类里面有两个方法 add()add()接收三个参数，第一个是表单字段(校验对象),第二个是策略方法名字,使用冒号(:)分隔，亲一个是方法名字，后一个是传给该方法的参数(如长度),第三个是验证不通过的返回信息;<br>然后用start方法进行验证：</p>\n<pre><code class=\"js\">var errorMsg = validation.start();\n</code></pre>\n<p>但是这种参数配置还是有问题，我们的要求是多种校验规则，比如用户名既不能为空，又要满足用户名长度不小于6，并不是单一的，上面的为什么要写两次，这种看着就不舒服，这时候我就需要对配置参数做一点小小的改动，我们用数组来传递多个校验规则：</p>\n<pre><code class=\"js\">//最终实现\nvalidator.add(registerForm.username, [{\n    strategy: &#39;isEmpty&#39;,\n    errorMsg: &#39;用户名不能为空！&#39;\n}, {\n    strategy: &#39;minLength:6&#39;,\n    errorMsg: &#39;用户名长度不能小于6位！&#39;\n}])\n</code></pre>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><pre><code class=\"js\">var FormValidator = function(ruleList){\n    //保存策略规则列表\n    this.strategies = ruleList;\n    //储存规则方法\n    this.validationFns = [];\n};\nFormValidator.prototype = {\n    add:function(dom,rule){\n        var that = this;\n        for(var i=0;i&lt;rule.length;i++){\n            // 这里使用闭包储存i 动态添加方法\n            (function(i){\n                //\n                that.validationFns.push(function(){\n                    /*\n                    * aryNames 规则名字(包含传的参数minLeng:6) 所以需要动态的解析\n                    * errorMsg 错误信息\n                    * rulename 方法名字\n                    * dataArr 储存参数 value method名字 错误信息\n                    * strategies 使用apply 向指定方法传参数\n                     */\n                    var aryNames = rule[i].strategy.split(&#39;:&#39;),\n                        errorMsg = rule[i].errorMsg,\n                        rulename = aryNames[0],\n                        dataArr = [];\n                        dataArr.push(dom.value);\n                        if(aryNames[1]){\n                            dataArr.push(aryNames[1]);\n                        }\n                        dataArr.push(errorMsg);\n                    return that.strategies[rulename].apply(dom,dataArr);\n                })\n            })(i)\n        }\n    },\n    start:function(){\n        var that = this;\n        // 遍历规则集合 抛出错误\n        for(i in that.validationFns){\n            var msg = that.validationFns[i]();\n            if(msg){\n                return msg;\n            }\n        }\n    }\n};\n</code></pre>\n<p><strong> 规则集合</strong></p>\n<pre><code class=\"js\">// 规则集合\nvar rules = {\n    //验证为空\n    isEmpoty: function(value,errorMsg){\n        if(value == &#39;&#39;){\n            return errorMsg;\n        }\n    },\n    //验证最小长度\n    minLength: function(value,len,errorMsg){\n        if(value.length &lt; len){\n            return errorMsg;\n        }\n    },\n    //验证手机号\n    isMobile: function(value,errorMsg){\n        if(!/^1\\d{10}$/.test(value)){\n            return errorMsg;\n        }\n    }\n};\n</code></pre>\n<p><strong> 客户端调用代码方法</strong></p>\n<pre><code class=\"html\">&lt;form id=&quot;submit&quot;&gt;\n    &lt;input type=&quot;text&quot; class=&quot;username&quot; name=&quot;username&quot;&gt;\n    &lt;input type=&quot;text&quot; class=&quot;userpass&quot; name=&quot;userpass&quot;&gt;\n&lt;/form&gt;\n&lt;div class=&quot;btn&quot;&gt;提交&lt;/div&gt;\n</code></pre>\n<pre><code class=\"js\">var forms = document.querySelector(&#39;#submit&#39;);\nvar btn = document.querySelector(&#39;.btn&#39;);\n\n// 构造函数 传入规则\nvar validation = new FormValidator(rules);\n// 直接调用规则方法即可 返回错误信息\nfunction getErrorMsg(){\n    // 直接调用规则方法即可\n    validation.add(forms.username,[\n        {\n            strategy:&#39;isEmpoty&#39;, //strategy 为固定字段\n            errorMsg:&#39;用户名不能为空&#39; //errorMsg 为固定字段\n        },\n        {\n            strategy:&#39;minLength:6&#39;,\n            errorMsg:&#39;用户名长度最低6位&#39;\n        }\n    ]);\n    validation.add(forms.userpass,[\n        {\n            strategy:&#39;isMobile&#39;,\n            errorMsg:&#39;手机号码有误&#39;\n        }\n    ]);\n\n    var error = validation.start();\n    return error;\n}\n// 点击事件\nbtn.addEventListener(&#39;click&#39;,function(){\n    var msg = getErrorMsg();\n    if(msg){\n        console.log(msg)//错误提示\n    }else{\n        //在此提交数据\n    }\n},false)\n</code></pre>\n<p>在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如我们想要将用户名输入框的校验规则改成用户名不能少于4个字符。可以看到，这时候的修改是毫不费力的。代码如下：</p>\n<pre><code class=\"js\">// 更具体的方法 可以在rules中修改\nvalidation.add(forms.username, [{\n        strategy: &#39;isNonEmpty&#39;,\n        errorMsg: &#39;用户名不能为空！&#39;\n    }, {\n        strategy: &#39;minLength:4&#39;,\n        errorMsg: &#39;用户名长度不能小于4位！&#39;\n    }])\n</code></pre>\n<p>参考：<br><a href=\"http://hcysun.me/2016/02/21/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%9C%A8%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/\" target=\"_blank\" rel=\"external\">策略模式在表单中的应用</a></p>"},{"title":"实现一个移动端字母索引导航","date":"2017-10-22T10:20:12.000Z","_content":"\n<!-- more -->\n> 索引导航栏的效果在很多 APP 中都有应用,之前接触移动端页面开发较少，所以是边学边做，也就把这个过程中的一些东西整理记录下来。...\n\n## 效果\n[DEMO,浏览器请打开移动端调试查看具体效果](http://loadingmore.com/demo/src/html/index-slidebar/index-slidebar.html)\n![](http://oq4hkch8e.bkt.clouddn.com/slideindex.gif)\n[GITHUB代码](https://github.com/BiYuqi/demo/blob/master/src/html/index-slidebar/index-slidebar.html)\n\n## 实现逻辑\n主要分为三个步骤\n* 渲染字母表\n* 渲染页面数据\n* 实现touch事件\n![](http://oq4hkch8e.bkt.clouddn.com/indexslide-code.png)\n\n## 解释几个函数\n解释下moveTo2这个函数,主要目的就是根据touch事件返回的字母，与页面进行匹配，匹配成功后，用window.scrollTo指定跳转位置，\n```js\nmoveTo2(letter) {\n    const len = this.concatList.length\n    for(let i=0;i<len;i++){\n        // 匹配成功 即表示存在\n        if(this.concatList[i].getAttribute('data-char') === letter){\n            // this.concatList[i].offsetTop-this.offsetTop\n            // 减去this.offsetTop 是为了减去header的高度，达到预期高度\n            window.scrollTo(0,this.concatList[i].offsetTop-this.offsetTop)\n        }\n    }\n}\n```\n此方法可返回touch时 所对应的索引是哪个字符,原理就是 this.letterWrap.clientHeight是字母列高度，除以字母数量得到是每个字母的高占比，再用当前touchY去除，得到当前位置的所占比例，取整即可得到当前索引\n```js\ngetIndex(touchY) {\n    // 可返回对应的模块索引\n    return Math.floor((touchY-this.offsetTop) / (this.letterWrap.clientHeight / this.source.length))\n}\n```\ntouch事件，其中e.preventDefault()是为了阻止scroll事件\n```js\ntouchStart() {\n    this.letterWrap.addEventListener('touchstart',(e)=>{\n        if(!this.touching){\n            e.preventDefault()\n            this.touching = true\n            this.letterWrap.className += ' active'\n            const touchY = e.touches[0].clientY\n            const index = this.getIndex(touchY)\n            this.showTips(index)\n            this.moveTo2(this.source[index])\n        }\n    },false)\n}\n\ntouchMove() {\n    this.letterWrap.addEventListener('touchmove',(e)=>{\n        if(this.touching){\n            e.preventDefault()\n            const touchY = e.touches[0].clientY\n            const index = this.getIndex(touchY)\n            this.showTips(index)\n            this.moveTo2(this.source[index])\n        }\n\n    },false)\n}\n\ntouchEnd() {\n    this.letterWrap.addEventListener('touchend',()=>{\n        if(this.touching){\n            this.touching = false\n            this.letterWrap.className = this.letterWrap.className.replace(/\\s*active/,'')\n            this.hideTips()\n        }\n\n    },false)\n}\n```\n至此，基本功能已经实现，可以根据不同的需求进行改进，后期打算封装成为一个类库，对外暴露接口，这样更灵活些\n","source":"_posts/实现一个移动端字母导航索引.md","raw":"---\ntitle: 实现一个移动端字母索引导航\ndate: 2017-10-22 18:20:12\ntags: [Javascript,ES6]\ncategories: Javascript\n---\n\n<!-- more -->\n> 索引导航栏的效果在很多 APP 中都有应用,之前接触移动端页面开发较少，所以是边学边做，也就把这个过程中的一些东西整理记录下来。...\n\n## 效果\n[DEMO,浏览器请打开移动端调试查看具体效果](http://loadingmore.com/demo/src/html/index-slidebar/index-slidebar.html)\n![](http://oq4hkch8e.bkt.clouddn.com/slideindex.gif)\n[GITHUB代码](https://github.com/BiYuqi/demo/blob/master/src/html/index-slidebar/index-slidebar.html)\n\n## 实现逻辑\n主要分为三个步骤\n* 渲染字母表\n* 渲染页面数据\n* 实现touch事件\n![](http://oq4hkch8e.bkt.clouddn.com/indexslide-code.png)\n\n## 解释几个函数\n解释下moveTo2这个函数,主要目的就是根据touch事件返回的字母，与页面进行匹配，匹配成功后，用window.scrollTo指定跳转位置，\n```js\nmoveTo2(letter) {\n    const len = this.concatList.length\n    for(let i=0;i<len;i++){\n        // 匹配成功 即表示存在\n        if(this.concatList[i].getAttribute('data-char') === letter){\n            // this.concatList[i].offsetTop-this.offsetTop\n            // 减去this.offsetTop 是为了减去header的高度，达到预期高度\n            window.scrollTo(0,this.concatList[i].offsetTop-this.offsetTop)\n        }\n    }\n}\n```\n此方法可返回touch时 所对应的索引是哪个字符,原理就是 this.letterWrap.clientHeight是字母列高度，除以字母数量得到是每个字母的高占比，再用当前touchY去除，得到当前位置的所占比例，取整即可得到当前索引\n```js\ngetIndex(touchY) {\n    // 可返回对应的模块索引\n    return Math.floor((touchY-this.offsetTop) / (this.letterWrap.clientHeight / this.source.length))\n}\n```\ntouch事件，其中e.preventDefault()是为了阻止scroll事件\n```js\ntouchStart() {\n    this.letterWrap.addEventListener('touchstart',(e)=>{\n        if(!this.touching){\n            e.preventDefault()\n            this.touching = true\n            this.letterWrap.className += ' active'\n            const touchY = e.touches[0].clientY\n            const index = this.getIndex(touchY)\n            this.showTips(index)\n            this.moveTo2(this.source[index])\n        }\n    },false)\n}\n\ntouchMove() {\n    this.letterWrap.addEventListener('touchmove',(e)=>{\n        if(this.touching){\n            e.preventDefault()\n            const touchY = e.touches[0].clientY\n            const index = this.getIndex(touchY)\n            this.showTips(index)\n            this.moveTo2(this.source[index])\n        }\n\n    },false)\n}\n\ntouchEnd() {\n    this.letterWrap.addEventListener('touchend',()=>{\n        if(this.touching){\n            this.touching = false\n            this.letterWrap.className = this.letterWrap.className.replace(/\\s*active/,'')\n            this.hideTips()\n        }\n\n    },false)\n}\n```\n至此，基本功能已经实现，可以根据不同的需求进行改进，后期打算封装成为一个类库，对外暴露接口，这样更灵活些\n","slug":"实现一个移动端字母导航索引","published":1,"updated":"2019-09-25T15:10:25.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pp004ula2ew780ipj6","content":"<a id=\"more\"></a>\n<blockquote>\n<p>索引导航栏的效果在很多 APP 中都有应用,之前接触移动端页面开发较少，所以是边学边做，也就把这个过程中的一些东西整理记录下来。…</p>\n</blockquote>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><a href=\"http://loadingmore.com/demo/src/html/index-slidebar/index-slidebar.html\">DEMO,浏览器请打开移动端调试查看具体效果</a><br><img src=\"http://oq4hkch8e.bkt.clouddn.com/slideindex.gif\" alt=\"\"><br><a href=\"https://github.com/BiYuqi/demo/blob/master/src/html/index-slidebar/index-slidebar.html\" target=\"_blank\" rel=\"external\">GITHUB代码</a></p>\n<h2 id=\"实现逻辑\"><a href=\"#实现逻辑\" class=\"headerlink\" title=\"实现逻辑\"></a>实现逻辑</h2><p>主要分为三个步骤</p>\n<ul>\n<li>渲染字母表</li>\n<li>渲染页面数据</li>\n<li>实现touch事件<br><img src=\"http://oq4hkch8e.bkt.clouddn.com/indexslide-code.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"解释几个函数\"><a href=\"#解释几个函数\" class=\"headerlink\" title=\"解释几个函数\"></a>解释几个函数</h2><p>解释下moveTo2这个函数,主要目的就是根据touch事件返回的字母，与页面进行匹配，匹配成功后，用window.scrollTo指定跳转位置，</p>\n<pre><code class=\"js\">moveTo2(letter) {\n    const len = this.concatList.length\n    for(let i=0;i&lt;len;i++){\n        // 匹配成功 即表示存在\n        if(this.concatList[i].getAttribute(&#39;data-char&#39;) === letter){\n            // this.concatList[i].offsetTop-this.offsetTop\n            // 减去this.offsetTop 是为了减去header的高度，达到预期高度\n            window.scrollTo(0,this.concatList[i].offsetTop-this.offsetTop)\n        }\n    }\n}\n</code></pre>\n<p>此方法可返回touch时 所对应的索引是哪个字符,原理就是 this.letterWrap.clientHeight是字母列高度，除以字母数量得到是每个字母的高占比，再用当前touchY去除，得到当前位置的所占比例，取整即可得到当前索引</p>\n<pre><code class=\"js\">getIndex(touchY) {\n    // 可返回对应的模块索引\n    return Math.floor((touchY-this.offsetTop) / (this.letterWrap.clientHeight / this.source.length))\n}\n</code></pre>\n<p>touch事件，其中e.preventDefault()是为了阻止scroll事件</p>\n<pre><code class=\"js\">touchStart() {\n    this.letterWrap.addEventListener(&#39;touchstart&#39;,(e)=&gt;{\n        if(!this.touching){\n            e.preventDefault()\n            this.touching = true\n            this.letterWrap.className += &#39; active&#39;\n            const touchY = e.touches[0].clientY\n            const index = this.getIndex(touchY)\n            this.showTips(index)\n            this.moveTo2(this.source[index])\n        }\n    },false)\n}\n\ntouchMove() {\n    this.letterWrap.addEventListener(&#39;touchmove&#39;,(e)=&gt;{\n        if(this.touching){\n            e.preventDefault()\n            const touchY = e.touches[0].clientY\n            const index = this.getIndex(touchY)\n            this.showTips(index)\n            this.moveTo2(this.source[index])\n        }\n\n    },false)\n}\n\ntouchEnd() {\n    this.letterWrap.addEventListener(&#39;touchend&#39;,()=&gt;{\n        if(this.touching){\n            this.touching = false\n            this.letterWrap.className = this.letterWrap.className.replace(/\\s*active/,&#39;&#39;)\n            this.hideTips()\n        }\n\n    },false)\n}\n</code></pre>\n<p>至此，基本功能已经实现，可以根据不同的需求进行改进，后期打算封装成为一个类库，对外暴露接口，这样更灵活些</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>索引导航栏的效果在很多 APP 中都有应用,之前接触移动端页面开发较少，所以是边学边做，也就把这个过程中的一些东西整理记录下来。…</p>\n</blockquote>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><a href=\"http://loadingmore.com/demo/src/html/index-slidebar/index-slidebar.html\">DEMO,浏览器请打开移动端调试查看具体效果</a><br><img src=\"http://oq4hkch8e.bkt.clouddn.com/slideindex.gif\" alt=\"\"><br><a href=\"https://github.com/BiYuqi/demo/blob/master/src/html/index-slidebar/index-slidebar.html\" target=\"_blank\" rel=\"external\">GITHUB代码</a></p>\n<h2 id=\"实现逻辑\"><a href=\"#实现逻辑\" class=\"headerlink\" title=\"实现逻辑\"></a>实现逻辑</h2><p>主要分为三个步骤</p>\n<ul>\n<li>渲染字母表</li>\n<li>渲染页面数据</li>\n<li>实现touch事件<br><img src=\"http://oq4hkch8e.bkt.clouddn.com/indexslide-code.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"解释几个函数\"><a href=\"#解释几个函数\" class=\"headerlink\" title=\"解释几个函数\"></a>解释几个函数</h2><p>解释下moveTo2这个函数,主要目的就是根据touch事件返回的字母，与页面进行匹配，匹配成功后，用window.scrollTo指定跳转位置，</p>\n<pre><code class=\"js\">moveTo2(letter) {\n    const len = this.concatList.length\n    for(let i=0;i&lt;len;i++){\n        // 匹配成功 即表示存在\n        if(this.concatList[i].getAttribute(&#39;data-char&#39;) === letter){\n            // this.concatList[i].offsetTop-this.offsetTop\n            // 减去this.offsetTop 是为了减去header的高度，达到预期高度\n            window.scrollTo(0,this.concatList[i].offsetTop-this.offsetTop)\n        }\n    }\n}\n</code></pre>\n<p>此方法可返回touch时 所对应的索引是哪个字符,原理就是 this.letterWrap.clientHeight是字母列高度，除以字母数量得到是每个字母的高占比，再用当前touchY去除，得到当前位置的所占比例，取整即可得到当前索引</p>\n<pre><code class=\"js\">getIndex(touchY) {\n    // 可返回对应的模块索引\n    return Math.floor((touchY-this.offsetTop) / (this.letterWrap.clientHeight / this.source.length))\n}\n</code></pre>\n<p>touch事件，其中e.preventDefault()是为了阻止scroll事件</p>\n<pre><code class=\"js\">touchStart() {\n    this.letterWrap.addEventListener(&#39;touchstart&#39;,(e)=&gt;{\n        if(!this.touching){\n            e.preventDefault()\n            this.touching = true\n            this.letterWrap.className += &#39; active&#39;\n            const touchY = e.touches[0].clientY\n            const index = this.getIndex(touchY)\n            this.showTips(index)\n            this.moveTo2(this.source[index])\n        }\n    },false)\n}\n\ntouchMove() {\n    this.letterWrap.addEventListener(&#39;touchmove&#39;,(e)=&gt;{\n        if(this.touching){\n            e.preventDefault()\n            const touchY = e.touches[0].clientY\n            const index = this.getIndex(touchY)\n            this.showTips(index)\n            this.moveTo2(this.source[index])\n        }\n\n    },false)\n}\n\ntouchEnd() {\n    this.letterWrap.addEventListener(&#39;touchend&#39;,()=&gt;{\n        if(this.touching){\n            this.touching = false\n            this.letterWrap.className = this.letterWrap.className.replace(/\\s*active/,&#39;&#39;)\n            this.hideTips()\n        }\n\n    },false)\n}\n</code></pre>\n<p>至此，基本功能已经实现，可以根据不同的需求进行改进，后期打算封装成为一个类库，对外暴露接口，这样更灵活些</p>"},{"title":"2017, 就这样来了","date":"2016-12-29T12:47:03.000Z","_content":"\n<!-- more -->\n## 前言\n时间的脚步总是不紧不慢，一刻也不停息的向前走着，伴随着这脚步声，2016年眨眼即将过去，2017年招手即来。网上看了不少技术大牛都在做总结，趁着还能抓住2016年的尾巴，我也凑个热闹，回顾下今年。\n## 关于工作\n种种原因吧，换了份新工作，离开了之前的环境，入职一个多月了，新公司整体还是比较有活力的，最近项目不是很忙，在学习新的框架，react react-native ,对组件化有了更清晰的认知，相比angular1.x,这种写法还是比较容易接受的。\n## 关于生活\n结婚也两年了，生活嘛，总是在不惊不喜中度过，感谢媳妇对我的包容，遇到你是我的幸运。希望家人都平平安安。\n## 关于健康\n工作的原因吧，睡的总是晚一点，基本平均12点以后了，起床八九点了，现在想想，挺怀念瘦瘦的我，哈哈，有点胖了，需要注意，脖颈也没以前那么灵活了，需要加强锻炼，注意身体健康了。\n## 展望下2017\n主要说说工作吧，期望工作顺利；期待自己利用新的框架，开发出比较好的app，自己在前端领域提升快一点。\n## 给自己列个书单吧\n* 《高级程序设计》第三版 温故知新\n* 《css揭秘》css3大法好\n* 《精通CSS：高级Web标准解决方案》\n* 《Web前端黑客技术揭秘》\n* 《O'Reilly：JavaScript经典实例》\n* 《JavaScript DOM编程艺术（第2版）》\n* 《深入浅出Node.js》\n*  默默地又看了下文章开头的图片...书啃起来吧，骚年\n\n\n## 结语\n先写这么多，后面博客会同步记录我的技术研究，读书笔记。坚持更新博客也算是17年的小小目标之一吧，加油，我的2017！\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/2017.jpeg\n","source":"_posts/我也来展望下2017.md","raw":"---\ntitle: 2017, 就这样来了\ndate: 2016-12-29 20:47:03\ntags: [other]\ncategories: other\n---\n\n<!-- more -->\n## 前言\n时间的脚步总是不紧不慢，一刻也不停息的向前走着，伴随着这脚步声，2016年眨眼即将过去，2017年招手即来。网上看了不少技术大牛都在做总结，趁着还能抓住2016年的尾巴，我也凑个热闹，回顾下今年。\n## 关于工作\n种种原因吧，换了份新工作，离开了之前的环境，入职一个多月了，新公司整体还是比较有活力的，最近项目不是很忙，在学习新的框架，react react-native ,对组件化有了更清晰的认知，相比angular1.x,这种写法还是比较容易接受的。\n## 关于生活\n结婚也两年了，生活嘛，总是在不惊不喜中度过，感谢媳妇对我的包容，遇到你是我的幸运。希望家人都平平安安。\n## 关于健康\n工作的原因吧，睡的总是晚一点，基本平均12点以后了，起床八九点了，现在想想，挺怀念瘦瘦的我，哈哈，有点胖了，需要注意，脖颈也没以前那么灵活了，需要加强锻炼，注意身体健康了。\n## 展望下2017\n主要说说工作吧，期望工作顺利；期待自己利用新的框架，开发出比较好的app，自己在前端领域提升快一点。\n## 给自己列个书单吧\n* 《高级程序设计》第三版 温故知新\n* 《css揭秘》css3大法好\n* 《精通CSS：高级Web标准解决方案》\n* 《Web前端黑客技术揭秘》\n* 《O'Reilly：JavaScript经典实例》\n* 《JavaScript DOM编程艺术（第2版）》\n* 《深入浅出Node.js》\n*  默默地又看了下文章开头的图片...书啃起来吧，骚年\n\n\n## 结语\n先写这么多，后面博客会同步记录我的技术研究，读书笔记。坚持更新博客也算是17年的小小目标之一吧，加油，我的2017！\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/2017.jpeg\n","slug":"我也来展望下2017","published":1,"updated":"2019-09-25T15:10:25.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pq004yla2ei5qyllu1","content":"<a id=\"more\"></a>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>时间的脚步总是不紧不慢，一刻也不停息的向前走着，伴随着这脚步声，2016年眨眼即将过去，2017年招手即来。网上看了不少技术大牛都在做总结，趁着还能抓住2016年的尾巴，我也凑个热闹，回顾下今年。</p>\n<h2 id=\"关于工作\"><a href=\"#关于工作\" class=\"headerlink\" title=\"关于工作\"></a>关于工作</h2><p>种种原因吧，换了份新工作，离开了之前的环境，入职一个多月了，新公司整体还是比较有活力的，最近项目不是很忙，在学习新的框架，react react-native ,对组件化有了更清晰的认知，相比angular1.x,这种写法还是比较容易接受的。</p>\n<h2 id=\"关于生活\"><a href=\"#关于生活\" class=\"headerlink\" title=\"关于生活\"></a>关于生活</h2><p>结婚也两年了，生活嘛，总是在不惊不喜中度过，感谢媳妇对我的包容，遇到你是我的幸运。希望家人都平平安安。</p>\n<h2 id=\"关于健康\"><a href=\"#关于健康\" class=\"headerlink\" title=\"关于健康\"></a>关于健康</h2><p>工作的原因吧，睡的总是晚一点，基本平均12点以后了，起床八九点了，现在想想，挺怀念瘦瘦的我，哈哈，有点胖了，需要注意，脖颈也没以前那么灵活了，需要加强锻炼，注意身体健康了。</p>\n<h2 id=\"展望下2017\"><a href=\"#展望下2017\" class=\"headerlink\" title=\"展望下2017\"></a>展望下2017</h2><p>主要说说工作吧，期望工作顺利；期待自己利用新的框架，开发出比较好的app，自己在前端领域提升快一点。</p>\n<h2 id=\"给自己列个书单吧\"><a href=\"#给自己列个书单吧\" class=\"headerlink\" title=\"给自己列个书单吧\"></a>给自己列个书单吧</h2><ul>\n<li>《高级程序设计》第三版 温故知新</li>\n<li>《css揭秘》css3大法好</li>\n<li>《精通CSS：高级Web标准解决方案》</li>\n<li>《Web前端黑客技术揭秘》</li>\n<li>《O’Reilly：JavaScript经典实例》</li>\n<li>《JavaScript DOM编程艺术（第2版）》</li>\n<li>《深入浅出Node.js》</li>\n<li>默默地又看了下文章开头的图片…书啃起来吧，骚年</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>先写这么多，后面博客会同步记录我的技术研究，读书笔记。坚持更新博客也算是17年的小小目标之一吧，加油，我的2017！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>时间的脚步总是不紧不慢，一刻也不停息的向前走着，伴随着这脚步声，2016年眨眼即将过去，2017年招手即来。网上看了不少技术大牛都在做总结，趁着还能抓住2016年的尾巴，我也凑个热闹，回顾下今年。</p>\n<h2 id=\"关于工作\"><a href=\"#关于工作\" class=\"headerlink\" title=\"关于工作\"></a>关于工作</h2><p>种种原因吧，换了份新工作，离开了之前的环境，入职一个多月了，新公司整体还是比较有活力的，最近项目不是很忙，在学习新的框架，react react-native ,对组件化有了更清晰的认知，相比angular1.x,这种写法还是比较容易接受的。</p>\n<h2 id=\"关于生活\"><a href=\"#关于生活\" class=\"headerlink\" title=\"关于生活\"></a>关于生活</h2><p>结婚也两年了，生活嘛，总是在不惊不喜中度过，感谢媳妇对我的包容，遇到你是我的幸运。希望家人都平平安安。</p>\n<h2 id=\"关于健康\"><a href=\"#关于健康\" class=\"headerlink\" title=\"关于健康\"></a>关于健康</h2><p>工作的原因吧，睡的总是晚一点，基本平均12点以后了，起床八九点了，现在想想，挺怀念瘦瘦的我，哈哈，有点胖了，需要注意，脖颈也没以前那么灵活了，需要加强锻炼，注意身体健康了。</p>\n<h2 id=\"展望下2017\"><a href=\"#展望下2017\" class=\"headerlink\" title=\"展望下2017\"></a>展望下2017</h2><p>主要说说工作吧，期望工作顺利；期待自己利用新的框架，开发出比较好的app，自己在前端领域提升快一点。</p>\n<h2 id=\"给自己列个书单吧\"><a href=\"#给自己列个书单吧\" class=\"headerlink\" title=\"给自己列个书单吧\"></a>给自己列个书单吧</h2><ul>\n<li>《高级程序设计》第三版 温故知新</li>\n<li>《css揭秘》css3大法好</li>\n<li>《精通CSS：高级Web标准解决方案》</li>\n<li>《Web前端黑客技术揭秘》</li>\n<li>《O’Reilly：JavaScript经典实例》</li>\n<li>《JavaScript DOM编程艺术（第2版）》</li>\n<li>《深入浅出Node.js》</li>\n<li>默默地又看了下文章开头的图片…书啃起来吧，骚年</li>\n</ul>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>先写这么多，后面博客会同步记录我的技术研究，读书笔记。坚持更新博客也算是17年的小小目标之一吧，加油，我的2017！</p>"},{"title":"换电脑后,如何完美迁出hexo博客","date":"2017-06-21T14:25:48.000Z","author":"Yuqi Bi","header-img":"form-opts.png","cdn":"header-on","_content":"> 最近换了电脑，之前电脑上搭建的静态博客也需要迁移了，上网查了下资料，自己也着手成功的迁移到了新的电脑\n\n## 开始前准备\n本博文默认git,nodejs已经安装好\n## 分析文件\n### 1.哪些文件是必须拷贝走的(拷贝到新的电脑)\n首先是之前自己修改的文件，像配置文件_config.yml,theme文件夹，source文件夹自己写的原始文件这些都是必须要拷贝走的。除此之外还有scaffolds文件夹(文件的模板)，package.json(使用哪些包)，.gitignore(提交忽略哪些文件夹)\n总结：\n\n* _config.yml\n* theme\n* source\n* scaffolds\n* package.json\n* .gitignore\n\n** 这些是需要拷贝的 **\n\n### 2.哪些文件是需要忽略不用管的\n\n.git node_mouldes/ public/ .deploy_git/ db.json\n\n## 开始迁移\n```js\n// 全局安装hexo\nnpm install hexo-cli -g\n\n// 把必须拷贝的文件，拷贝到新建的文件夹内，执行以下命令\n// 在新建的文件夹内打开命令行，安装必要的模块，初始化\n// 这里不用hexo init初始化，因为配置文件我们已经拷贝过来(一定要慎重，严格按照教程来)\n\nnpm install\n\n// 安装其他一些必要的组件\nnpm install hexo-deployer-git --save\n\nnpm install hexo-generator-feed --save\n\nnpm install hexo-generator-sitemap --save\n```\n## 测试是否安装成功\n```js\n//先本地预览\nhexo clean\n\nhexo g\n\nhexo s\n\n//此时可以先在localhost:4000 本地预览博客，如果不报错，那就说明迁移成功\n\n// 正式部署\nhexo clean\n\nhexo g\n\nhexo d\n```\n至此，可以打开网页看看部署情况，祝各位成功，有问题随时联系我 biyuqiwan@163.com\n","source":"_posts/换电脑后-如何完美迁出hexo博客.md","raw":"---\ntitle: '换电脑后,如何完美迁出hexo博客'\ndate: 2017-06-21 22:25:48\ntags: [javascript,hexo]\nauthor: \"Yuqi Bi\"\nheader-img: \"form-opts.png\"\ncdn: 'header-on'\n---\n> 最近换了电脑，之前电脑上搭建的静态博客也需要迁移了，上网查了下资料，自己也着手成功的迁移到了新的电脑\n\n## 开始前准备\n本博文默认git,nodejs已经安装好\n## 分析文件\n### 1.哪些文件是必须拷贝走的(拷贝到新的电脑)\n首先是之前自己修改的文件，像配置文件_config.yml,theme文件夹，source文件夹自己写的原始文件这些都是必须要拷贝走的。除此之外还有scaffolds文件夹(文件的模板)，package.json(使用哪些包)，.gitignore(提交忽略哪些文件夹)\n总结：\n\n* _config.yml\n* theme\n* source\n* scaffolds\n* package.json\n* .gitignore\n\n** 这些是需要拷贝的 **\n\n### 2.哪些文件是需要忽略不用管的\n\n.git node_mouldes/ public/ .deploy_git/ db.json\n\n## 开始迁移\n```js\n// 全局安装hexo\nnpm install hexo-cli -g\n\n// 把必须拷贝的文件，拷贝到新建的文件夹内，执行以下命令\n// 在新建的文件夹内打开命令行，安装必要的模块，初始化\n// 这里不用hexo init初始化，因为配置文件我们已经拷贝过来(一定要慎重，严格按照教程来)\n\nnpm install\n\n// 安装其他一些必要的组件\nnpm install hexo-deployer-git --save\n\nnpm install hexo-generator-feed --save\n\nnpm install hexo-generator-sitemap --save\n```\n## 测试是否安装成功\n```js\n//先本地预览\nhexo clean\n\nhexo g\n\nhexo s\n\n//此时可以先在localhost:4000 本地预览博客，如果不报错，那就说明迁移成功\n\n// 正式部署\nhexo clean\n\nhexo g\n\nhexo d\n```\n至此，可以打开网页看看部署情况，祝各位成功，有问题随时联系我 biyuqiwan@163.com\n","slug":"换电脑后-如何完美迁出hexo博客","published":1,"updated":"2019-09-25T15:10:25.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pr0051la2ewiigov8d","content":"<blockquote>\n<p>最近换了电脑，之前电脑上搭建的静态博客也需要迁移了，上网查了下资料，自己也着手成功的迁移到了新的电脑</p>\n</blockquote>\n<h2 id=\"开始前准备\"><a href=\"#开始前准备\" class=\"headerlink\" title=\"开始前准备\"></a>开始前准备</h2><p>本博文默认git,nodejs已经安装好</p>\n<h2 id=\"分析文件\"><a href=\"#分析文件\" class=\"headerlink\" title=\"分析文件\"></a>分析文件</h2><h3 id=\"1-哪些文件是必须拷贝走的-拷贝到新的电脑\"><a href=\"#1-哪些文件是必须拷贝走的-拷贝到新的电脑\" class=\"headerlink\" title=\"1.哪些文件是必须拷贝走的(拷贝到新的电脑)\"></a>1.哪些文件是必须拷贝走的(拷贝到新的电脑)</h3><p>首先是之前自己修改的文件，像配置文件_config.yml,theme文件夹，source文件夹自己写的原始文件这些都是必须要拷贝走的。除此之外还有scaffolds文件夹(文件的模板)，package.json(使用哪些包)，.gitignore(提交忽略哪些文件夹)<br>总结：</p>\n<ul>\n<li>_config.yml</li>\n<li>theme</li>\n<li>source</li>\n<li>scaffolds</li>\n<li>package.json</li>\n<li>.gitignore</li>\n</ul>\n<p><strong> 这些是需要拷贝的 </strong></p>\n<h3 id=\"2-哪些文件是需要忽略不用管的\"><a href=\"#2-哪些文件是需要忽略不用管的\" class=\"headerlink\" title=\"2.哪些文件是需要忽略不用管的\"></a>2.哪些文件是需要忽略不用管的</h3><p>.git node_mouldes/ public/ .deploy_git/ db.json</p>\n<h2 id=\"开始迁移\"><a href=\"#开始迁移\" class=\"headerlink\" title=\"开始迁移\"></a>开始迁移</h2><pre><code class=\"js\">// 全局安装hexo\nnpm install hexo-cli -g\n\n// 把必须拷贝的文件，拷贝到新建的文件夹内，执行以下命令\n// 在新建的文件夹内打开命令行，安装必要的模块，初始化\n// 这里不用hexo init初始化，因为配置文件我们已经拷贝过来(一定要慎重，严格按照教程来)\n\nnpm install\n\n// 安装其他一些必要的组件\nnpm install hexo-deployer-git --save\n\nnpm install hexo-generator-feed --save\n\nnpm install hexo-generator-sitemap --save\n</code></pre>\n<h2 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h2><pre><code class=\"js\">//先本地预览\nhexo clean\n\nhexo g\n\nhexo s\n\n//此时可以先在localhost:4000 本地预览博客，如果不报错，那就说明迁移成功\n\n// 正式部署\nhexo clean\n\nhexo g\n\nhexo d\n</code></pre>\n<p>至此，可以打开网页看看部署情况，祝各位成功，有问题随时联系我 biyuqiwan@163.com</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近换了电脑，之前电脑上搭建的静态博客也需要迁移了，上网查了下资料，自己也着手成功的迁移到了新的电脑</p>\n</blockquote>\n<h2 id=\"开始前准备\"><a href=\"#开始前准备\" class=\"headerlink\" title=\"开始前准备\"></a>开始前准备</h2><p>本博文默认git,nodejs已经安装好</p>\n<h2 id=\"分析文件\"><a href=\"#分析文件\" class=\"headerlink\" title=\"分析文件\"></a>分析文件</h2><h3 id=\"1-哪些文件是必须拷贝走的-拷贝到新的电脑\"><a href=\"#1-哪些文件是必须拷贝走的-拷贝到新的电脑\" class=\"headerlink\" title=\"1.哪些文件是必须拷贝走的(拷贝到新的电脑)\"></a>1.哪些文件是必须拷贝走的(拷贝到新的电脑)</h3><p>首先是之前自己修改的文件，像配置文件_config.yml,theme文件夹，source文件夹自己写的原始文件这些都是必须要拷贝走的。除此之外还有scaffolds文件夹(文件的模板)，package.json(使用哪些包)，.gitignore(提交忽略哪些文件夹)<br>总结：</p>\n<ul>\n<li>_config.yml</li>\n<li>theme</li>\n<li>source</li>\n<li>scaffolds</li>\n<li>package.json</li>\n<li>.gitignore</li>\n</ul>\n<p><strong> 这些是需要拷贝的 </strong></p>\n<h3 id=\"2-哪些文件是需要忽略不用管的\"><a href=\"#2-哪些文件是需要忽略不用管的\" class=\"headerlink\" title=\"2.哪些文件是需要忽略不用管的\"></a>2.哪些文件是需要忽略不用管的</h3><p>.git node_mouldes/ public/ .deploy_git/ db.json</p>\n<h2 id=\"开始迁移\"><a href=\"#开始迁移\" class=\"headerlink\" title=\"开始迁移\"></a>开始迁移</h2><pre><code class=\"js\">// 全局安装hexo\nnpm install hexo-cli -g\n\n// 把必须拷贝的文件，拷贝到新建的文件夹内，执行以下命令\n// 在新建的文件夹内打开命令行，安装必要的模块，初始化\n// 这里不用hexo init初始化，因为配置文件我们已经拷贝过来(一定要慎重，严格按照教程来)\n\nnpm install\n\n// 安装其他一些必要的组件\nnpm install hexo-deployer-git --save\n\nnpm install hexo-generator-feed --save\n\nnpm install hexo-generator-sitemap --save\n</code></pre>\n<h2 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h2><pre><code class=\"js\">//先本地预览\nhexo clean\n\nhexo g\n\nhexo s\n\n//此时可以先在localhost:4000 本地预览博客，如果不报错，那就说明迁移成功\n\n// 正式部署\nhexo clean\n\nhexo g\n\nhexo d\n</code></pre>\n<p>至此，可以打开网页看看部署情况，祝各位成功，有问题随时联系我 biyuqiwan@163.com</p>\n"},{"title":"来看看select是个什么东东","date":"2017-01-23T03:30:12.000Z","_content":"> ### 关键词：select option options selectedIndex remove add\n\n<!-- more -->\n### 属性\n* options：返回包含下拉列表中的所有选项的一个数组\n* name：设置或返回下拉列表的名称。\n* selectedIndex：设置或返回下拉列表中被选项目的索引号。\n* add()：向下拉列表添加一个选项。\n* remove()：从下拉列表中删除一个选项。\n* onchange：当改变选择时调用的事件句柄。\n\n### 实战\n#### HTML结构\n```HTML\n<select class=\"s1\">\n\n</select>\n```\n####  selectedIndex, options, onchange\n写的时候注意不要写的错单词：\n```javascript\nvar s1 = document.querySelector('.s1');\ns1.onchange = function(){\n    //当前选中option 所在索引\n    //也可写成this.options.selectedIndex\n    console.log(this.selectedIndex);\n}\n```\n#### add()\n动态的添加option\n```javascript\n/*\n* elem selector的id 或者 clas\n* obj 要添加的option选项 提供批量添加\n    格式：[\n            {con:\"option文本值\",item:\"option value值\"},\n            {con:\"option文本值\",item:\"option value值\"}\n        ]\n*/\nfunction addOption(elem,obj){\n    var el = document.querySelector(elem);\n    for(i in obj){\n        var op = new Option(obj[i].con,obj[i].item);\n        el.add(op);\n    }\n}\n//测试\nvar obj = [\n    {con:\"微信\",item:\"-1\"},\n    {con:\"支付宝\",item:\"-2\"},\n    {con:\"银联\",item:\"-3\"},\n    {con:\"拒绝\",item:\"-5\"},\n    {con:\"接受\",item:\"-6\"}\n];\n//调用\n//可以在浏览器跑跑看效果了\naddOption('.s1',obj);\n```\n![enter description here][1]\n\n#### remove()\n动态的删除指定option\n```javascript\n/*\n* elem selector的id 或者 class\n* obj  要添加的option选项 提供批量删除\n*      可根据需要 更改函数 指定删除匹配的option文本\n*      本文默认匹配option  value值\n*      格式一 字符串 value值  \"-3\" 目前只支持一个\n*      推荐：格式二：[\n*             {val:\"option value值\"},\n*            {val:\"option value值\"},\n*            {val:\"option value值\"}\n*         ]\n*/\nfunction removeOption(elem,opText) {\n    var el = document.querySelector(elem);\n    for(var i=0;i<el.options.length;i++){\n        if(typeof opText === 'string'){\n            //此处可根据需要改成匹配 text\n            //el.options[i].text 即option文本值\n            //string 仅支持一次删除一个\n            if(el.options[i].value === opText){\n                el.options.remove(i);\n            }\n        }\n        if(typeof opText === 'object'){\n            for(j in opText){\n                //此处可根据需要改成匹配 text\n                //el.options[i].text 即option文本值\n                if(el.options[i].value === opText[j].val){\n                    el.options.remove(i);\n                }\n            }\n        }\n    }\n}\n//测试 上文中添加的value 值\n//推荐使用对象，可批量删除\nvar text = [\n    {val:\"-1\"},\n    {val:\"-2\"}\n];\n//调用\n//可以在浏览器跑跑看效果了\nremoveOption('.s1',text);\n```\n![enter description here][2]\n#### item(index)\n用来选择option\n```javascript\nvar s1 = document.querySelector('.s1');\ns1.item(0);//选中第一个option\n```\n### Reference\n* 1.[小胡子哥][3]\n* 2.[MDN][4]\n\n  [1]: http://oiukswkar.bkt.clouddn.com/select1.png\n  [2]: http://oiukswkar.bkt.clouddn.com/select2.png\n  [3]: http://www.barretlee.com/blog/2013/04/11/cb-options_add_and_remove/\n  [4]: https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLSelectElement\n  [5]: http://oiukswkar.bkt.clouddn.com/select.png\n","source":"_posts/来看看select是个什么东东.md","raw":"---\ntitle: 来看看select是个什么东东\ndate: 2017-01-23 11:30:12\ntags: [javascript,select]\ncategories: Javascript\n---\n> ### 关键词：select option options selectedIndex remove add\n\n<!-- more -->\n### 属性\n* options：返回包含下拉列表中的所有选项的一个数组\n* name：设置或返回下拉列表的名称。\n* selectedIndex：设置或返回下拉列表中被选项目的索引号。\n* add()：向下拉列表添加一个选项。\n* remove()：从下拉列表中删除一个选项。\n* onchange：当改变选择时调用的事件句柄。\n\n### 实战\n#### HTML结构\n```HTML\n<select class=\"s1\">\n\n</select>\n```\n####  selectedIndex, options, onchange\n写的时候注意不要写的错单词：\n```javascript\nvar s1 = document.querySelector('.s1');\ns1.onchange = function(){\n    //当前选中option 所在索引\n    //也可写成this.options.selectedIndex\n    console.log(this.selectedIndex);\n}\n```\n#### add()\n动态的添加option\n```javascript\n/*\n* elem selector的id 或者 clas\n* obj 要添加的option选项 提供批量添加\n    格式：[\n            {con:\"option文本值\",item:\"option value值\"},\n            {con:\"option文本值\",item:\"option value值\"}\n        ]\n*/\nfunction addOption(elem,obj){\n    var el = document.querySelector(elem);\n    for(i in obj){\n        var op = new Option(obj[i].con,obj[i].item);\n        el.add(op);\n    }\n}\n//测试\nvar obj = [\n    {con:\"微信\",item:\"-1\"},\n    {con:\"支付宝\",item:\"-2\"},\n    {con:\"银联\",item:\"-3\"},\n    {con:\"拒绝\",item:\"-5\"},\n    {con:\"接受\",item:\"-6\"}\n];\n//调用\n//可以在浏览器跑跑看效果了\naddOption('.s1',obj);\n```\n![enter description here][1]\n\n#### remove()\n动态的删除指定option\n```javascript\n/*\n* elem selector的id 或者 class\n* obj  要添加的option选项 提供批量删除\n*      可根据需要 更改函数 指定删除匹配的option文本\n*      本文默认匹配option  value值\n*      格式一 字符串 value值  \"-3\" 目前只支持一个\n*      推荐：格式二：[\n*             {val:\"option value值\"},\n*            {val:\"option value值\"},\n*            {val:\"option value值\"}\n*         ]\n*/\nfunction removeOption(elem,opText) {\n    var el = document.querySelector(elem);\n    for(var i=0;i<el.options.length;i++){\n        if(typeof opText === 'string'){\n            //此处可根据需要改成匹配 text\n            //el.options[i].text 即option文本值\n            //string 仅支持一次删除一个\n            if(el.options[i].value === opText){\n                el.options.remove(i);\n            }\n        }\n        if(typeof opText === 'object'){\n            for(j in opText){\n                //此处可根据需要改成匹配 text\n                //el.options[i].text 即option文本值\n                if(el.options[i].value === opText[j].val){\n                    el.options.remove(i);\n                }\n            }\n        }\n    }\n}\n//测试 上文中添加的value 值\n//推荐使用对象，可批量删除\nvar text = [\n    {val:\"-1\"},\n    {val:\"-2\"}\n];\n//调用\n//可以在浏览器跑跑看效果了\nremoveOption('.s1',text);\n```\n![enter description here][2]\n#### item(index)\n用来选择option\n```javascript\nvar s1 = document.querySelector('.s1');\ns1.item(0);//选中第一个option\n```\n### Reference\n* 1.[小胡子哥][3]\n* 2.[MDN][4]\n\n  [1]: http://oiukswkar.bkt.clouddn.com/select1.png\n  [2]: http://oiukswkar.bkt.clouddn.com/select2.png\n  [3]: http://www.barretlee.com/blog/2013/04/11/cb-options_add_and_remove/\n  [4]: https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLSelectElement\n  [5]: http://oiukswkar.bkt.clouddn.com/select.png\n","slug":"来看看select是个什么东东","published":1,"updated":"2019-09-25T15:10:25.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ps0056la2ejzkifut9","content":"<blockquote>\n<h3 id=\"关键词：select-option-options-selectedIndex-remove-add\"><a href=\"#关键词：select-option-options-selectedIndex-remove-add\" class=\"headerlink\" title=\"关键词：select option options selectedIndex remove add\"></a>关键词：select option options selectedIndex remove add</h3></blockquote>\n<a id=\"more\"></a>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><ul>\n<li>options：返回包含下拉列表中的所有选项的一个数组</li>\n<li>name：设置或返回下拉列表的名称。</li>\n<li>selectedIndex：设置或返回下拉列表中被选项目的索引号。</li>\n<li>add()：向下拉列表添加一个选项。</li>\n<li>remove()：从下拉列表中删除一个选项。</li>\n<li>onchange：当改变选择时调用的事件句柄。</li>\n</ul>\n<h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><h4 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h4><pre><code class=\"HTML\">&lt;select class=&quot;s1&quot;&gt;\n\n&lt;/select&gt;\n</code></pre>\n<h4 id=\"selectedIndex-options-onchange\"><a href=\"#selectedIndex-options-onchange\" class=\"headerlink\" title=\"selectedIndex, options, onchange\"></a>selectedIndex, options, onchange</h4><p>写的时候注意不要写的错单词：</p>\n<pre><code class=\"javascript\">var s1 = document.querySelector(&#39;.s1&#39;);\ns1.onchange = function(){\n    //当前选中option 所在索引\n    //也可写成this.options.selectedIndex\n    console.log(this.selectedIndex);\n}\n</code></pre>\n<h4 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h4><p>动态的添加option</p>\n<pre><code class=\"javascript\">/*\n* elem selector的id 或者 clas\n* obj 要添加的option选项 提供批量添加\n    格式：[\n            {con:&quot;option文本值&quot;,item:&quot;option value值&quot;},\n            {con:&quot;option文本值&quot;,item:&quot;option value值&quot;}\n        ]\n*/\nfunction addOption(elem,obj){\n    var el = document.querySelector(elem);\n    for(i in obj){\n        var op = new Option(obj[i].con,obj[i].item);\n        el.add(op);\n    }\n}\n//测试\nvar obj = [\n    {con:&quot;微信&quot;,item:&quot;-1&quot;},\n    {con:&quot;支付宝&quot;,item:&quot;-2&quot;},\n    {con:&quot;银联&quot;,item:&quot;-3&quot;},\n    {con:&quot;拒绝&quot;,item:&quot;-5&quot;},\n    {con:&quot;接受&quot;,item:&quot;-6&quot;}\n];\n//调用\n//可以在浏览器跑跑看效果了\naddOption(&#39;.s1&#39;,obj);\n</code></pre>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/select1.png\" alt=\"enter description here\"></p>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h4><p>动态的删除指定option</p>\n<pre><code class=\"javascript\">/*\n* elem selector的id 或者 class\n* obj  要添加的option选项 提供批量删除\n*      可根据需要 更改函数 指定删除匹配的option文本\n*      本文默认匹配option  value值\n*      格式一 字符串 value值  &quot;-3&quot; 目前只支持一个\n*      推荐：格式二：[\n*             {val:&quot;option value值&quot;},\n*            {val:&quot;option value值&quot;},\n*            {val:&quot;option value值&quot;}\n*         ]\n*/\nfunction removeOption(elem,opText) {\n    var el = document.querySelector(elem);\n    for(var i=0;i&lt;el.options.length;i++){\n        if(typeof opText === &#39;string&#39;){\n            //此处可根据需要改成匹配 text\n            //el.options[i].text 即option文本值\n            //string 仅支持一次删除一个\n            if(el.options[i].value === opText){\n                el.options.remove(i);\n            }\n        }\n        if(typeof opText === &#39;object&#39;){\n            for(j in opText){\n                //此处可根据需要改成匹配 text\n                //el.options[i].text 即option文本值\n                if(el.options[i].value === opText[j].val){\n                    el.options.remove(i);\n                }\n            }\n        }\n    }\n}\n//测试 上文中添加的value 值\n//推荐使用对象，可批量删除\nvar text = [\n    {val:&quot;-1&quot;},\n    {val:&quot;-2&quot;}\n];\n//调用\n//可以在浏览器跑跑看效果了\nremoveOption(&#39;.s1&#39;,text);\n</code></pre>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/select2.png\" alt=\"enter description here\"></p>\n<h4 id=\"item-index\"><a href=\"#item-index\" class=\"headerlink\" title=\"item(index)\"></a>item(index)</h4><p>用来选择option</p>\n<pre><code class=\"javascript\">var s1 = document.querySelector(&#39;.s1&#39;);\ns1.item(0);//选中第一个option\n</code></pre>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li>1.<a href=\"http://www.barretlee.com/blog/2013/04/11/cb-options_add_and_remove/\" target=\"_blank\" rel=\"external\">小胡子哥</a></li>\n<li>2.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLSelectElement\" target=\"_blank\" rel=\"external\">MDN</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<h3 id=\"关键词：select-option-options-selectedIndex-remove-add\"><a href=\"#关键词：select-option-options-selectedIndex-remove-add\" class=\"headerlink\" title=\"关键词：select option options selectedIndex remove add\"></a>关键词：select option options selectedIndex remove add</h3></blockquote>","more":"<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><ul>\n<li>options：返回包含下拉列表中的所有选项的一个数组</li>\n<li>name：设置或返回下拉列表的名称。</li>\n<li>selectedIndex：设置或返回下拉列表中被选项目的索引号。</li>\n<li>add()：向下拉列表添加一个选项。</li>\n<li>remove()：从下拉列表中删除一个选项。</li>\n<li>onchange：当改变选择时调用的事件句柄。</li>\n</ul>\n<h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><h4 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h4><pre><code class=\"HTML\">&lt;select class=&quot;s1&quot;&gt;\n\n&lt;/select&gt;\n</code></pre>\n<h4 id=\"selectedIndex-options-onchange\"><a href=\"#selectedIndex-options-onchange\" class=\"headerlink\" title=\"selectedIndex, options, onchange\"></a>selectedIndex, options, onchange</h4><p>写的时候注意不要写的错单词：</p>\n<pre><code class=\"javascript\">var s1 = document.querySelector(&#39;.s1&#39;);\ns1.onchange = function(){\n    //当前选中option 所在索引\n    //也可写成this.options.selectedIndex\n    console.log(this.selectedIndex);\n}\n</code></pre>\n<h4 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add()\"></a>add()</h4><p>动态的添加option</p>\n<pre><code class=\"javascript\">/*\n* elem selector的id 或者 clas\n* obj 要添加的option选项 提供批量添加\n    格式：[\n            {con:&quot;option文本值&quot;,item:&quot;option value值&quot;},\n            {con:&quot;option文本值&quot;,item:&quot;option value值&quot;}\n        ]\n*/\nfunction addOption(elem,obj){\n    var el = document.querySelector(elem);\n    for(i in obj){\n        var op = new Option(obj[i].con,obj[i].item);\n        el.add(op);\n    }\n}\n//测试\nvar obj = [\n    {con:&quot;微信&quot;,item:&quot;-1&quot;},\n    {con:&quot;支付宝&quot;,item:&quot;-2&quot;},\n    {con:&quot;银联&quot;,item:&quot;-3&quot;},\n    {con:&quot;拒绝&quot;,item:&quot;-5&quot;},\n    {con:&quot;接受&quot;,item:&quot;-6&quot;}\n];\n//调用\n//可以在浏览器跑跑看效果了\naddOption(&#39;.s1&#39;,obj);\n</code></pre>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/select1.png\" alt=\"enter description here\"></p>\n<h4 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove()\"></a>remove()</h4><p>动态的删除指定option</p>\n<pre><code class=\"javascript\">/*\n* elem selector的id 或者 class\n* obj  要添加的option选项 提供批量删除\n*      可根据需要 更改函数 指定删除匹配的option文本\n*      本文默认匹配option  value值\n*      格式一 字符串 value值  &quot;-3&quot; 目前只支持一个\n*      推荐：格式二：[\n*             {val:&quot;option value值&quot;},\n*            {val:&quot;option value值&quot;},\n*            {val:&quot;option value值&quot;}\n*         ]\n*/\nfunction removeOption(elem,opText) {\n    var el = document.querySelector(elem);\n    for(var i=0;i&lt;el.options.length;i++){\n        if(typeof opText === &#39;string&#39;){\n            //此处可根据需要改成匹配 text\n            //el.options[i].text 即option文本值\n            //string 仅支持一次删除一个\n            if(el.options[i].value === opText){\n                el.options.remove(i);\n            }\n        }\n        if(typeof opText === &#39;object&#39;){\n            for(j in opText){\n                //此处可根据需要改成匹配 text\n                //el.options[i].text 即option文本值\n                if(el.options[i].value === opText[j].val){\n                    el.options.remove(i);\n                }\n            }\n        }\n    }\n}\n//测试 上文中添加的value 值\n//推荐使用对象，可批量删除\nvar text = [\n    {val:&quot;-1&quot;},\n    {val:&quot;-2&quot;}\n];\n//调用\n//可以在浏览器跑跑看效果了\nremoveOption(&#39;.s1&#39;,text);\n</code></pre>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/select2.png\" alt=\"enter description here\"></p>\n<h4 id=\"item-index\"><a href=\"#item-index\" class=\"headerlink\" title=\"item(index)\"></a>item(index)</h4><p>用来选择option</p>\n<pre><code class=\"javascript\">var s1 = document.querySelector(&#39;.s1&#39;);\ns1.item(0);//选中第一个option\n</code></pre>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li>1.<a href=\"http://www.barretlee.com/blog/2013/04/11/cb-options_add_and_remove/\" target=\"_blank\" rel=\"external\">小胡子哥</a></li>\n<li>2.<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLSelectElement\" target=\"_blank\" rel=\"external\">MDN</a></li>\n</ul>"},{"title":"正则匹配字符串英文首字母小写转大写","date":"2017-02-05T11:27:10.000Z","_content":"> ** 周末无事，刚好最近一直在温习正则,就写了个小demo，匹配替换英文字符中首字母,并进行大写转换**\n\n\n<!-- more -->\n### <font color=\"#FF0000\">Demo演示</font>\n[点击查看demo][3]\n### 需求实现一篇英文文稿中单词首字母大写化\n第一步首先得匹配上每个单词，包括紧跟着单词后面的标点符号\n```javascript\n//正则\n//考虑了单词中会有数字,标点,换行,引用\n//规则如下\n/[\"a-zA-Z0-9]+[,.!-'—\"\"]*\\s?\\n?/g;\n```\n### 封装函数\n```javascript\n/*\n* @target 目标文本\n* @range 输出值\n* ToTarget(match) 匹配replace 回调函数\n*\n*/\nfunction ToLetterUpper(target){\n    var reg = /[\"a-zA-Z0-9]+[,.!-'—\"\"]*\\s?\\n?/g;\n    var range = '';//转化后的内容\n    //匹配的内容大写\n    function ToTarget(match){\n        return match.toUpperCase();\n    }\n    while(match = reg.exec(target)){\n        range += match[0].replace(/^[a-z]{1}/,ToTarget);//调用方法\n    }\n    return range;\n}\n```\n### Test\n```javascript\nvar str = 'At least 36, people. have been killed';\nToLetterUpper(str);\n//At Least 36, People. Have Been Killed\n```\n### 参考资料\n* [MDN][1]\n\n[1]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace\n[2]: http://oiukswkar.bkt.clouddn.com/letter.jpg\n[3]: https://biyuqi.github.io/demo/src/html/letToUper.html\n","source":"_posts/正则匹配字符串英文首字母小写转大写.md","raw":"---\ntitle: 正则匹配字符串英文首字母小写转大写\ndate: 2017-02-05 19:27:10\ntags: [javascript,\"正则\",RegExp]\ncategories: Javascript\n---\n> ** 周末无事，刚好最近一直在温习正则,就写了个小demo，匹配替换英文字符中首字母,并进行大写转换**\n\n\n<!-- more -->\n### <font color=\"#FF0000\">Demo演示</font>\n[点击查看demo][3]\n### 需求实现一篇英文文稿中单词首字母大写化\n第一步首先得匹配上每个单词，包括紧跟着单词后面的标点符号\n```javascript\n//正则\n//考虑了单词中会有数字,标点,换行,引用\n//规则如下\n/[\"a-zA-Z0-9]+[,.!-'—\"\"]*\\s?\\n?/g;\n```\n### 封装函数\n```javascript\n/*\n* @target 目标文本\n* @range 输出值\n* ToTarget(match) 匹配replace 回调函数\n*\n*/\nfunction ToLetterUpper(target){\n    var reg = /[\"a-zA-Z0-9]+[,.!-'—\"\"]*\\s?\\n?/g;\n    var range = '';//转化后的内容\n    //匹配的内容大写\n    function ToTarget(match){\n        return match.toUpperCase();\n    }\n    while(match = reg.exec(target)){\n        range += match[0].replace(/^[a-z]{1}/,ToTarget);//调用方法\n    }\n    return range;\n}\n```\n### Test\n```javascript\nvar str = 'At least 36, people. have been killed';\nToLetterUpper(str);\n//At Least 36, People. Have Been Killed\n```\n### 参考资料\n* [MDN][1]\n\n[1]: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace\n[2]: http://oiukswkar.bkt.clouddn.com/letter.jpg\n[3]: https://biyuqi.github.io/demo/src/html/letToUper.html\n","slug":"正则匹配字符串英文首字母小写转大写","published":1,"updated":"2019-09-25T15:10:25.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91ps0058la2epylmckjj","content":"<blockquote>\n<p><strong> 周末无事，刚好最近一直在温习正则,就写了个小demo，匹配替换英文字符中首字母,并进行大写转换</strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Demo演示\"><a href=\"#Demo演示\" class=\"headerlink\" title=\"Demo演示\"></a><font color=\"#FF0000\">Demo演示</font></h3><p><a href=\"https://biyuqi.github.io/demo/src/html/letToUper.html\" target=\"_blank\" rel=\"external\">点击查看demo</a></p>\n<h3 id=\"需求实现一篇英文文稿中单词首字母大写化\"><a href=\"#需求实现一篇英文文稿中单词首字母大写化\" class=\"headerlink\" title=\"需求实现一篇英文文稿中单词首字母大写化\"></a>需求实现一篇英文文稿中单词首字母大写化</h3><p>第一步首先得匹配上每个单词，包括紧跟着单词后面的标点符号</p>\n<pre><code class=\"javascript\">//正则\n//考虑了单词中会有数字,标点,换行,引用\n//规则如下\n/[&quot;a-zA-Z0-9]+[,.!-&#39;—&quot;&quot;]*\\s?\\n?/g;\n</code></pre>\n<h3 id=\"封装函数\"><a href=\"#封装函数\" class=\"headerlink\" title=\"封装函数\"></a>封装函数</h3><pre><code class=\"javascript\">/*\n* @target 目标文本\n* @range 输出值\n* ToTarget(match) 匹配replace 回调函数\n*\n*/\nfunction ToLetterUpper(target){\n    var reg = /[&quot;a-zA-Z0-9]+[,.!-&#39;—&quot;&quot;]*\\s?\\n?/g;\n    var range = &#39;&#39;;//转化后的内容\n    //匹配的内容大写\n    function ToTarget(match){\n        return match.toUpperCase();\n    }\n    while(match = reg.exec(target)){\n        range += match[0].replace(/^[a-z]{1}/,ToTarget);//调用方法\n    }\n    return range;\n}\n</code></pre>\n<h3 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h3><pre><code class=\"javascript\">var str = &#39;At least 36, people. have been killed&#39;;\nToLetterUpper(str);\n//At Least 36, People. Have Been Killed\n</code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace\" target=\"_blank\" rel=\"external\">MDN</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong> 周末无事，刚好最近一直在温习正则,就写了个小demo，匹配替换英文字符中首字母,并进行大写转换</strong></p>\n</blockquote>","more":"<h3 id=\"Demo演示\"><a href=\"#Demo演示\" class=\"headerlink\" title=\"Demo演示\"></a><font color=\"#FF0000\">Demo演示</font></h3><p><a href=\"https://biyuqi.github.io/demo/src/html/letToUper.html\" target=\"_blank\" rel=\"external\">点击查看demo</a></p>\n<h3 id=\"需求实现一篇英文文稿中单词首字母大写化\"><a href=\"#需求实现一篇英文文稿中单词首字母大写化\" class=\"headerlink\" title=\"需求实现一篇英文文稿中单词首字母大写化\"></a>需求实现一篇英文文稿中单词首字母大写化</h3><p>第一步首先得匹配上每个单词，包括紧跟着单词后面的标点符号</p>\n<pre><code class=\"javascript\">//正则\n//考虑了单词中会有数字,标点,换行,引用\n//规则如下\n/[&quot;a-zA-Z0-9]+[,.!-&#39;—&quot;&quot;]*\\s?\\n?/g;\n</code></pre>\n<h3 id=\"封装函数\"><a href=\"#封装函数\" class=\"headerlink\" title=\"封装函数\"></a>封装函数</h3><pre><code class=\"javascript\">/*\n* @target 目标文本\n* @range 输出值\n* ToTarget(match) 匹配replace 回调函数\n*\n*/\nfunction ToLetterUpper(target){\n    var reg = /[&quot;a-zA-Z0-9]+[,.!-&#39;—&quot;&quot;]*\\s?\\n?/g;\n    var range = &#39;&#39;;//转化后的内容\n    //匹配的内容大写\n    function ToTarget(match){\n        return match.toUpperCase();\n    }\n    while(match = reg.exec(target)){\n        range += match[0].replace(/^[a-z]{1}/,ToTarget);//调用方法\n    }\n    return range;\n}\n</code></pre>\n<h3 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h3><pre><code class=\"javascript\">var str = &#39;At least 36, people. have been killed&#39;;\nToLetterUpper(str);\n//At Least 36, People. Have Been Killed\n</code></pre>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace\" target=\"_blank\" rel=\"external\">MDN</a></li>\n</ul>"},{"title":"正则实现代码高亮","date":"2017-03-18T07:52:23.000Z","_content":"> 最近鼓捣了个markdown在线预览的编辑器,基于vue2.0实现,对vue的理解程度还没有那么深,所以代码高亮,断行没有用插件来实现,于是决定用正则来简单实现.\n\n## 场景\n经常写代码，写业务难免要查询某些数据和字符串打交道,其中正则便是一个提高编程效率的实用工具,还没了解正则的建议好好学一学.** [编辑器在这里][0]** | ** [正则表达式30分钟入门教程][1]**\n<!-- more -->\n## 第一步取html\n示例代码,给代码块加高亮,断行,前提是在整个HTML文档中先取出代码块，再对代码块进行操作\n** 取数据：**\n```javascript\n//这就是我所用到的正则\n//<code[^>]+>  找到code代码段 包含里面含有class 等属性的情况\n//[\\s\\S]+? [\\s\\S]代表匹配文档中任何一个位置 +不止一处  ?非贪婪模式\n//非贪婪模式可以匹配每一段code的内容，如不加？ 诸位可以试下会匹配到什么\nvar regCode = /<code[^>]+>([\\s\\S]+?)<\\/code>/g;\n```\n** 取出的数据源:**\n```html\n<code class=\"javascript language-javascript\">\n    function loadStyle(href){\n        var link = document.createElement(\"link\");   \n        link.type = \"text/css\";\n        link.rel = \"stylesheet\";\n        link.href = href;   \n        var head = document.getElementsByTagName(\"head\")[0];   \n        head.appendChild(link);\n    }\n    loadStyle(demo.css);\n</code>\n```\n\n## 第二步写规则\n这里我把正则分开写了,分别配置了不同关键词,对应的颜色,考虑到性能,复杂度可以把这些正则写在一起,用|隔开也行,这里我就偷懒了，先这样\n```javascript\nvar config = {\n    regs:[\n        /\\b(var|function|return|new|try|exec|match|catch|break|continue|case|for|if|else|while|switch)\\b/g,\n        /(this)/g,\n        /(true|false)/g,\n        /([+])/g,\n        /\\b(document|innerHTML)\\b/g,\n        /\\b(createElement|getElementsByTagName|appendChild|querySelector|querySelectorAll|getElementById)\\b/g\n    ],\n    fontColor:[\n        '#9E70DD',\n        '#9B2C34',\n        '#D19A66',\n        '#42A2EF',\n        '#E06A6C',\n        '#50B2BC'\n    ]\n};\n```\n\n## 第三步 处理关键词\n假设我们的html数命名为 s 现在来替换s中的代码段里面的关键词\n我们的配置项为6个  所以直接for循环\n```javascript\nfor(var i=0;i<6;i++){\n    //对codes 进行循环替换\n    s = s.replace(config.regs[i],function(m){\n        return '<span style=\"color:'+config.fontColor[i]+'\">'+m+'</span>'\n    })\n}\n```\n## 第四步 处理函数名高亮\n```javascript\n//函数名高亮\n//匹配代码块内函数名\nvar regName = /\\s(\\w+)\\(/g;\nvar res = [];\nwhile(m = regName.exec(s)){\n    res.push(m[1])\n}\nfor(var i=0;i<res.length;i++){\n    s = s.replace(res[i],'<span style=\"color:#3081E3\">'+res[i]+'</span>')\n}\n```\n## 第五步 处理函数断行加<br>\n```javascript\nvar regCode = /<code[^>]+>([\\s\\S]+?)<\\/code>/g;\nvar content;\n//收集每一行代码\nvar conStr=[];\nwhile(content = regCode.exec(s)){\n    conStr.push(content[1])\n}\nfor(var i=0;i<conStr.length;i++){\n    //代码换行处进行添加<br>\n    s = s.replace(conStr[i],conStr[i].replace(/\\n/g, \"<br>\"));\n}\n```\n## 结语\n处理结束后就可以把s放到页面了,试试效果，效果在这里[效果在这里][0]\n\n\n[0]: http://loadingmore.com/v-markdown\n[1]: http://www.jb51.net/tools/zhengze.html#mission\n","source":"_posts/正则实现代码高亮.md","raw":"---\ntitle: 正则实现代码高亮\ndate: 2017-03-18 15:52:23\ntags: [javascript,\"正则\",RegExp]\ncategories: Javascript\n---\n> 最近鼓捣了个markdown在线预览的编辑器,基于vue2.0实现,对vue的理解程度还没有那么深,所以代码高亮,断行没有用插件来实现,于是决定用正则来简单实现.\n\n## 场景\n经常写代码，写业务难免要查询某些数据和字符串打交道,其中正则便是一个提高编程效率的实用工具,还没了解正则的建议好好学一学.** [编辑器在这里][0]** | ** [正则表达式30分钟入门教程][1]**\n<!-- more -->\n## 第一步取html\n示例代码,给代码块加高亮,断行,前提是在整个HTML文档中先取出代码块，再对代码块进行操作\n** 取数据：**\n```javascript\n//这就是我所用到的正则\n//<code[^>]+>  找到code代码段 包含里面含有class 等属性的情况\n//[\\s\\S]+? [\\s\\S]代表匹配文档中任何一个位置 +不止一处  ?非贪婪模式\n//非贪婪模式可以匹配每一段code的内容，如不加？ 诸位可以试下会匹配到什么\nvar regCode = /<code[^>]+>([\\s\\S]+?)<\\/code>/g;\n```\n** 取出的数据源:**\n```html\n<code class=\"javascript language-javascript\">\n    function loadStyle(href){\n        var link = document.createElement(\"link\");   \n        link.type = \"text/css\";\n        link.rel = \"stylesheet\";\n        link.href = href;   \n        var head = document.getElementsByTagName(\"head\")[0];   \n        head.appendChild(link);\n    }\n    loadStyle(demo.css);\n</code>\n```\n\n## 第二步写规则\n这里我把正则分开写了,分别配置了不同关键词,对应的颜色,考虑到性能,复杂度可以把这些正则写在一起,用|隔开也行,这里我就偷懒了，先这样\n```javascript\nvar config = {\n    regs:[\n        /\\b(var|function|return|new|try|exec|match|catch|break|continue|case|for|if|else|while|switch)\\b/g,\n        /(this)/g,\n        /(true|false)/g,\n        /([+])/g,\n        /\\b(document|innerHTML)\\b/g,\n        /\\b(createElement|getElementsByTagName|appendChild|querySelector|querySelectorAll|getElementById)\\b/g\n    ],\n    fontColor:[\n        '#9E70DD',\n        '#9B2C34',\n        '#D19A66',\n        '#42A2EF',\n        '#E06A6C',\n        '#50B2BC'\n    ]\n};\n```\n\n## 第三步 处理关键词\n假设我们的html数命名为 s 现在来替换s中的代码段里面的关键词\n我们的配置项为6个  所以直接for循环\n```javascript\nfor(var i=0;i<6;i++){\n    //对codes 进行循环替换\n    s = s.replace(config.regs[i],function(m){\n        return '<span style=\"color:'+config.fontColor[i]+'\">'+m+'</span>'\n    })\n}\n```\n## 第四步 处理函数名高亮\n```javascript\n//函数名高亮\n//匹配代码块内函数名\nvar regName = /\\s(\\w+)\\(/g;\nvar res = [];\nwhile(m = regName.exec(s)){\n    res.push(m[1])\n}\nfor(var i=0;i<res.length;i++){\n    s = s.replace(res[i],'<span style=\"color:#3081E3\">'+res[i]+'</span>')\n}\n```\n## 第五步 处理函数断行加<br>\n```javascript\nvar regCode = /<code[^>]+>([\\s\\S]+?)<\\/code>/g;\nvar content;\n//收集每一行代码\nvar conStr=[];\nwhile(content = regCode.exec(s)){\n    conStr.push(content[1])\n}\nfor(var i=0;i<conStr.length;i++){\n    //代码换行处进行添加<br>\n    s = s.replace(conStr[i],conStr[i].replace(/\\n/g, \"<br>\"));\n}\n```\n## 结语\n处理结束后就可以把s放到页面了,试试效果，效果在这里[效果在这里][0]\n\n\n[0]: http://loadingmore.com/v-markdown\n[1]: http://www.jb51.net/tools/zhengze.html#mission\n","slug":"正则实现代码高亮","published":1,"updated":"2019-09-25T15:10:25.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pt005bla2emuzrx69e","content":"<blockquote>\n<p>最近鼓捣了个markdown在线预览的编辑器,基于vue2.0实现,对vue的理解程度还没有那么深,所以代码高亮,断行没有用插件来实现,于是决定用正则来简单实现.</p>\n</blockquote>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>经常写代码，写业务难免要查询某些数据和字符串打交道,其中正则便是一个提高编程效率的实用工具,还没了解正则的建议好好学一学.<strong> <a href=\"http://loadingmore.com/v-markdown\">编辑器在这里</a></strong> | <strong> <a href=\"http://www.jb51.net/tools/zhengze.html#mission\" target=\"_blank\" rel=\"external\">正则表达式30分钟入门教程</a></strong><br><a id=\"more\"></a></p>\n<h2 id=\"第一步取html\"><a href=\"#第一步取html\" class=\"headerlink\" title=\"第一步取html\"></a>第一步取html</h2><p>示例代码,给代码块加高亮,断行,前提是在整个HTML文档中先取出代码块，再对代码块进行操作<br><strong> 取数据：</strong></p>\n<pre><code class=\"javascript\">//这就是我所用到的正则\n//&lt;code[^&gt;]+&gt;  找到code代码段 包含里面含有class 等属性的情况\n//[\\s\\S]+? [\\s\\S]代表匹配文档中任何一个位置 +不止一处  ?非贪婪模式\n//非贪婪模式可以匹配每一段code的内容，如不加？ 诸位可以试下会匹配到什么\nvar regCode = /&lt;code[^&gt;]+&gt;([\\s\\S]+?)&lt;\\/code&gt;/g;\n</code></pre>\n<p><strong> 取出的数据源:</strong></p>\n<pre><code class=\"html\">&lt;code class=&quot;javascript language-javascript&quot;&gt;\n    function loadStyle(href){\n        var link = document.createElement(&quot;link&quot;);   \n        link.type = &quot;text/css&quot;;\n        link.rel = &quot;stylesheet&quot;;\n        link.href = href;   \n        var head = document.getElementsByTagName(&quot;head&quot;)[0];   \n        head.appendChild(link);\n    }\n    loadStyle(demo.css);\n&lt;/code&gt;\n</code></pre>\n<h2 id=\"第二步写规则\"><a href=\"#第二步写规则\" class=\"headerlink\" title=\"第二步写规则\"></a>第二步写规则</h2><p>这里我把正则分开写了,分别配置了不同关键词,对应的颜色,考虑到性能,复杂度可以把这些正则写在一起,用|隔开也行,这里我就偷懒了，先这样</p>\n<pre><code class=\"javascript\">var config = {\n    regs:[\n        /\\b(var|function|return|new|try|exec|match|catch|break|continue|case|for|if|else|while|switch)\\b/g,\n        /(this)/g,\n        /(true|false)/g,\n        /([+])/g,\n        /\\b(document|innerHTML)\\b/g,\n        /\\b(createElement|getElementsByTagName|appendChild|querySelector|querySelectorAll|getElementById)\\b/g\n    ],\n    fontColor:[\n        &#39;#9E70DD&#39;,\n        &#39;#9B2C34&#39;,\n        &#39;#D19A66&#39;,\n        &#39;#42A2EF&#39;,\n        &#39;#E06A6C&#39;,\n        &#39;#50B2BC&#39;\n    ]\n};\n</code></pre>\n<h2 id=\"第三步-处理关键词\"><a href=\"#第三步-处理关键词\" class=\"headerlink\" title=\"第三步 处理关键词\"></a>第三步 处理关键词</h2><p>假设我们的html数命名为 s 现在来替换s中的代码段里面的关键词<br>我们的配置项为6个  所以直接for循环</p>\n<pre><code class=\"javascript\">for(var i=0;i&lt;6;i++){\n    //对codes 进行循环替换\n    s = s.replace(config.regs[i],function(m){\n        return &#39;&lt;span style=&quot;color:&#39;+config.fontColor[i]+&#39;&quot;&gt;&#39;+m+&#39;&lt;/span&gt;&#39;\n    })\n}\n</code></pre>\n<h2 id=\"第四步-处理函数名高亮\"><a href=\"#第四步-处理函数名高亮\" class=\"headerlink\" title=\"第四步 处理函数名高亮\"></a>第四步 处理函数名高亮</h2><pre><code class=\"javascript\">//函数名高亮\n//匹配代码块内函数名\nvar regName = /\\s(\\w+)\\(/g;\nvar res = [];\nwhile(m = regName.exec(s)){\n    res.push(m[1])\n}\nfor(var i=0;i&lt;res.length;i++){\n    s = s.replace(res[i],&#39;&lt;span style=&quot;color:#3081E3&quot;&gt;&#39;+res[i]+&#39;&lt;/span&gt;&#39;)\n}\n</code></pre>\n<h2 id=\"第五步-处理函数断行加\"><a href=\"#第五步-处理函数断行加\" class=\"headerlink\" title=\"第五步 处理函数断行加\"></a>第五步 处理函数断行加<br></h2><pre><code class=\"javascript\">var regCode = /&lt;code[^&gt;]+&gt;([\\s\\S]+?)&lt;\\/code&gt;/g;\nvar content;\n//收集每一行代码\nvar conStr=[];\nwhile(content = regCode.exec(s)){\n    conStr.push(content[1])\n}\nfor(var i=0;i&lt;conStr.length;i++){\n    //代码换行处进行添加&lt;br&gt;\n    s = s.replace(conStr[i],conStr[i].replace(/\\n/g, &quot;&lt;br&gt;&quot;));\n}\n</code></pre>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>处理结束后就可以把s放到页面了,试试效果，效果在这里<a href=\"http://loadingmore.com/v-markdown\">效果在这里</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近鼓捣了个markdown在线预览的编辑器,基于vue2.0实现,对vue的理解程度还没有那么深,所以代码高亮,断行没有用插件来实现,于是决定用正则来简单实现.</p>\n</blockquote>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>经常写代码，写业务难免要查询某些数据和字符串打交道,其中正则便是一个提高编程效率的实用工具,还没了解正则的建议好好学一学.<strong> <a href=\"http://loadingmore.com/v-markdown\">编辑器在这里</a></strong> | <strong> <a href=\"http://www.jb51.net/tools/zhengze.html#mission\" target=\"_blank\" rel=\"external\">正则表达式30分钟入门教程</a></strong><br>","more":"</p>\n<h2 id=\"第一步取html\"><a href=\"#第一步取html\" class=\"headerlink\" title=\"第一步取html\"></a>第一步取html</h2><p>示例代码,给代码块加高亮,断行,前提是在整个HTML文档中先取出代码块，再对代码块进行操作<br><strong> 取数据：</strong></p>\n<pre><code class=\"javascript\">//这就是我所用到的正则\n//&lt;code[^&gt;]+&gt;  找到code代码段 包含里面含有class 等属性的情况\n//[\\s\\S]+? [\\s\\S]代表匹配文档中任何一个位置 +不止一处  ?非贪婪模式\n//非贪婪模式可以匹配每一段code的内容，如不加？ 诸位可以试下会匹配到什么\nvar regCode = /&lt;code[^&gt;]+&gt;([\\s\\S]+?)&lt;\\/code&gt;/g;\n</code></pre>\n<p><strong> 取出的数据源:</strong></p>\n<pre><code class=\"html\">&lt;code class=&quot;javascript language-javascript&quot;&gt;\n    function loadStyle(href){\n        var link = document.createElement(&quot;link&quot;);   \n        link.type = &quot;text/css&quot;;\n        link.rel = &quot;stylesheet&quot;;\n        link.href = href;   \n        var head = document.getElementsByTagName(&quot;head&quot;)[0];   \n        head.appendChild(link);\n    }\n    loadStyle(demo.css);\n&lt;/code&gt;\n</code></pre>\n<h2 id=\"第二步写规则\"><a href=\"#第二步写规则\" class=\"headerlink\" title=\"第二步写规则\"></a>第二步写规则</h2><p>这里我把正则分开写了,分别配置了不同关键词,对应的颜色,考虑到性能,复杂度可以把这些正则写在一起,用|隔开也行,这里我就偷懒了，先这样</p>\n<pre><code class=\"javascript\">var config = {\n    regs:[\n        /\\b(var|function|return|new|try|exec|match|catch|break|continue|case|for|if|else|while|switch)\\b/g,\n        /(this)/g,\n        /(true|false)/g,\n        /([+])/g,\n        /\\b(document|innerHTML)\\b/g,\n        /\\b(createElement|getElementsByTagName|appendChild|querySelector|querySelectorAll|getElementById)\\b/g\n    ],\n    fontColor:[\n        &#39;#9E70DD&#39;,\n        &#39;#9B2C34&#39;,\n        &#39;#D19A66&#39;,\n        &#39;#42A2EF&#39;,\n        &#39;#E06A6C&#39;,\n        &#39;#50B2BC&#39;\n    ]\n};\n</code></pre>\n<h2 id=\"第三步-处理关键词\"><a href=\"#第三步-处理关键词\" class=\"headerlink\" title=\"第三步 处理关键词\"></a>第三步 处理关键词</h2><p>假设我们的html数命名为 s 现在来替换s中的代码段里面的关键词<br>我们的配置项为6个  所以直接for循环</p>\n<pre><code class=\"javascript\">for(var i=0;i&lt;6;i++){\n    //对codes 进行循环替换\n    s = s.replace(config.regs[i],function(m){\n        return &#39;&lt;span style=&quot;color:&#39;+config.fontColor[i]+&#39;&quot;&gt;&#39;+m+&#39;&lt;/span&gt;&#39;\n    })\n}\n</code></pre>\n<h2 id=\"第四步-处理函数名高亮\"><a href=\"#第四步-处理函数名高亮\" class=\"headerlink\" title=\"第四步 处理函数名高亮\"></a>第四步 处理函数名高亮</h2><pre><code class=\"javascript\">//函数名高亮\n//匹配代码块内函数名\nvar regName = /\\s(\\w+)\\(/g;\nvar res = [];\nwhile(m = regName.exec(s)){\n    res.push(m[1])\n}\nfor(var i=0;i&lt;res.length;i++){\n    s = s.replace(res[i],&#39;&lt;span style=&quot;color:#3081E3&quot;&gt;&#39;+res[i]+&#39;&lt;/span&gt;&#39;)\n}\n</code></pre>\n<h2 id=\"第五步-处理函数断行加\"><a href=\"#第五步-处理函数断行加\" class=\"headerlink\" title=\"第五步 处理函数断行加\"></a>第五步 处理函数断行加<br></h2><pre><code class=\"javascript\">var regCode = /&lt;code[^&gt;]+&gt;([\\s\\S]+?)&lt;\\/code&gt;/g;\nvar content;\n//收集每一行代码\nvar conStr=[];\nwhile(content = regCode.exec(s)){\n    conStr.push(content[1])\n}\nfor(var i=0;i&lt;conStr.length;i++){\n    //代码换行处进行添加&lt;br&gt;\n    s = s.replace(conStr[i],conStr[i].replace(/\\n/g, &quot;&lt;br&gt;&quot;));\n}\n</code></pre>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>处理结束后就可以把s放到页面了,试试效果，效果在这里<a href=\"http://loadingmore.com/v-markdown\">效果在这里</a></p>"},{"title":"正则表达式必须包含数字和字母两种组合","date":"2017-02-21T03:13:12.000Z","_content":"> ** 做表单验证经常做判断密码的组合，强度之类的校验，最近仔细研究了下正则，体会到了正则的强大，所以用几种方法来实现这一需求 **\n\n\n<!-- more -->\n### 分析\n** 正则表达式中必须包含字母数字(不能纯数字或纯字母)，那么就必须要判断该字符串中：**\n* 必须包含数字\n* 必须包含字母\n\n### 实现\n这里会用到正则的环视(零宽断言):(?=exp)和(?!exp),所以我们的正则可以写为：\n第一种实现用(?=exp)：\n```javascript\n//(?=exp) 必须包含?=exp 后面的字符(意味着必须有至少一个字母，一个数字)\n/^(?=.*?[0-9])(?=.*?[a-z])[0-9a-z]+$/\n```\n第二种实现用(?!exp)：\n```javascript\n//(?!exp)不包含?!exp后面的字符(意味着不能是纯数字 纯字母)\n/(?!^[0-9]+$)(?!^[a-z]+$)^[0-9a-z]+$/\n```\n当然,如果需要限定字符串长度,我们后面的[a-z0-9]+可以改为一个长度范围,+改为如{5,16};\n### 改需求 必须包含字母数字特殊字符\n** 其实就是在上面的正则中加入特殊字符即可 这里只输入_-@&=几个字符，根据需要可自行扩充 **\n第一种实现用(?=exp)：\n```javascript\n//(?=exp) 必须包含?=exp 后面的字符(意味着必须有至少一个字母，一个数字，一个特殊字符)\n/^(?=.*?[0-9])(?=.*?[a-z])(?=.*?[_\\-@&=])[0-9a-z_\\-@&=]+$/\n```\n第二种实现用混合\n```javascript\n//(?=exp)\n//必须包含?=exp 后面的字符(意味着必须有至有字母，数字，不全是字母数字\n//(意味着有特殊字符))\n /^(?=.*?\\d)(?=.*?[a-z])(?!^[a-z\\d]+$).+$/;\n```\n### 改需求 必须包含字母数字特殊字符中任意两种组合\n** 其实就是在上面的正则中加入特殊字符即可 这里只输入_-@&=几个字符，根据需要可自行扩充 **\n实现用(?!exp)：\n```javascript\n//(?!exp)不包含?!exp后面的字符(意味着不能是纯数字 纯字母 纯特殊字符)\n/(?!^[0-9]+$)(?!^[a-z]+$)(?!^[_\\-@&=]]+$)^[0-9a-z_\\-@&=]+$/\n```\n\n###解读正则\n\n** 正则以^开始，限定匹配字符串是从开始位置进行匹配，(?=.*?[a-z])是肯定型顺序环视，限定当前位置的后面，能匹配.*?[a-z]，也就是，能够匹配到一个字母，同理，(?=.*?[0-9])表示限定当前位置的后面，能匹配一个数字，(?=.*?[_\\-@&=])表示限定当前位置的后面，能匹配一个特殊字符，而[a-z0-9_\\-@&=]+就是前面那些环视限定的位置，即表示[a-z0-9_\\-@&=]+中，至少匹配一个字母、一个数字、一个特殊字符，最终匹配到达字符串结束位置$。**\n\n### 参考\n[30分钟入门正则表达式][1]\n\n[1]: http://deerchao.net/tutorials/regex/regex-1.htm\n[2]: http://oiukswkar.bkt.clouddn.com/regexp-1.jpg\n","source":"_posts/正则表达式必须包含数字字母两种组合.md","raw":"---\ntitle: 正则表达式必须包含数字和字母两种组合\ndate: 2017-02-21 11:13:12\ntags: [javascript,\"正则\"]\ncategories: Javascript\n---\n> ** 做表单验证经常做判断密码的组合，强度之类的校验，最近仔细研究了下正则，体会到了正则的强大，所以用几种方法来实现这一需求 **\n\n\n<!-- more -->\n### 分析\n** 正则表达式中必须包含字母数字(不能纯数字或纯字母)，那么就必须要判断该字符串中：**\n* 必须包含数字\n* 必须包含字母\n\n### 实现\n这里会用到正则的环视(零宽断言):(?=exp)和(?!exp),所以我们的正则可以写为：\n第一种实现用(?=exp)：\n```javascript\n//(?=exp) 必须包含?=exp 后面的字符(意味着必须有至少一个字母，一个数字)\n/^(?=.*?[0-9])(?=.*?[a-z])[0-9a-z]+$/\n```\n第二种实现用(?!exp)：\n```javascript\n//(?!exp)不包含?!exp后面的字符(意味着不能是纯数字 纯字母)\n/(?!^[0-9]+$)(?!^[a-z]+$)^[0-9a-z]+$/\n```\n当然,如果需要限定字符串长度,我们后面的[a-z0-9]+可以改为一个长度范围,+改为如{5,16};\n### 改需求 必须包含字母数字特殊字符\n** 其实就是在上面的正则中加入特殊字符即可 这里只输入_-@&=几个字符，根据需要可自行扩充 **\n第一种实现用(?=exp)：\n```javascript\n//(?=exp) 必须包含?=exp 后面的字符(意味着必须有至少一个字母，一个数字，一个特殊字符)\n/^(?=.*?[0-9])(?=.*?[a-z])(?=.*?[_\\-@&=])[0-9a-z_\\-@&=]+$/\n```\n第二种实现用混合\n```javascript\n//(?=exp)\n//必须包含?=exp 后面的字符(意味着必须有至有字母，数字，不全是字母数字\n//(意味着有特殊字符))\n /^(?=.*?\\d)(?=.*?[a-z])(?!^[a-z\\d]+$).+$/;\n```\n### 改需求 必须包含字母数字特殊字符中任意两种组合\n** 其实就是在上面的正则中加入特殊字符即可 这里只输入_-@&=几个字符，根据需要可自行扩充 **\n实现用(?!exp)：\n```javascript\n//(?!exp)不包含?!exp后面的字符(意味着不能是纯数字 纯字母 纯特殊字符)\n/(?!^[0-9]+$)(?!^[a-z]+$)(?!^[_\\-@&=]]+$)^[0-9a-z_\\-@&=]+$/\n```\n\n###解读正则\n\n** 正则以^开始，限定匹配字符串是从开始位置进行匹配，(?=.*?[a-z])是肯定型顺序环视，限定当前位置的后面，能匹配.*?[a-z]，也就是，能够匹配到一个字母，同理，(?=.*?[0-9])表示限定当前位置的后面，能匹配一个数字，(?=.*?[_\\-@&=])表示限定当前位置的后面，能匹配一个特殊字符，而[a-z0-9_\\-@&=]+就是前面那些环视限定的位置，即表示[a-z0-9_\\-@&=]+中，至少匹配一个字母、一个数字、一个特殊字符，最终匹配到达字符串结束位置$。**\n\n### 参考\n[30分钟入门正则表达式][1]\n\n[1]: http://deerchao.net/tutorials/regex/regex-1.htm\n[2]: http://oiukswkar.bkt.clouddn.com/regexp-1.jpg\n","slug":"正则表达式必须包含数字字母两种组合","published":1,"updated":"2019-09-25T15:10:25.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pu005ela2eoqclzosd","content":"<blockquote>\n<p><strong> 做表单验证经常做判断密码的组合，强度之类的校验，最近仔细研究了下正则，体会到了正则的强大，所以用几种方法来实现这一需求 </strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p><strong> 正则表达式中必须包含字母数字(不能纯数字或纯字母)，那么就必须要判断该字符串中：</strong></p>\n<ul>\n<li>必须包含数字</li>\n<li>必须包含字母</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>这里会用到正则的环视(零宽断言):(?=exp)和(?!exp),所以我们的正则可以写为：<br>第一种实现用(?=exp)：</p>\n<pre><code class=\"javascript\">//(?=exp) 必须包含?=exp 后面的字符(意味着必须有至少一个字母，一个数字)\n/^(?=.*?[0-9])(?=.*?[a-z])[0-9a-z]+$/\n</code></pre>\n<p>第二种实现用(?!exp)：</p>\n<pre><code class=\"javascript\">//(?!exp)不包含?!exp后面的字符(意味着不能是纯数字 纯字母)\n/(?!^[0-9]+$)(?!^[a-z]+$)^[0-9a-z]+$/\n</code></pre>\n<p>当然,如果需要限定字符串长度,我们后面的[a-z0-9]+可以改为一个长度范围,+改为如{5,16};</p>\n<h3 id=\"改需求-必须包含字母数字特殊字符\"><a href=\"#改需求-必须包含字母数字特殊字符\" class=\"headerlink\" title=\"改需求 必须包含字母数字特殊字符\"></a>改需求 必须包含字母数字特殊字符</h3><p><strong> 其实就是在上面的正则中加入特殊字符即可 这里只输入_-@&amp;=几个字符，根据需要可自行扩充 </strong><br>第一种实现用(?=exp)：</p>\n<pre><code class=\"javascript\">//(?=exp) 必须包含?=exp 后面的字符(意味着必须有至少一个字母，一个数字，一个特殊字符)\n/^(?=.*?[0-9])(?=.*?[a-z])(?=.*?[_\\-@&amp;=])[0-9a-z_\\-@&amp;=]+$/\n</code></pre>\n<p>第二种实现用混合</p>\n<pre><code class=\"javascript\">//(?=exp)\n//必须包含?=exp 后面的字符(意味着必须有至有字母，数字，不全是字母数字\n//(意味着有特殊字符))\n /^(?=.*?\\d)(?=.*?[a-z])(?!^[a-z\\d]+$).+$/;\n</code></pre>\n<h3 id=\"改需求-必须包含字母数字特殊字符中任意两种组合\"><a href=\"#改需求-必须包含字母数字特殊字符中任意两种组合\" class=\"headerlink\" title=\"改需求 必须包含字母数字特殊字符中任意两种组合\"></a>改需求 必须包含字母数字特殊字符中任意两种组合</h3><p><strong> 其实就是在上面的正则中加入特殊字符即可 这里只输入_-@&amp;=几个字符，根据需要可自行扩充 </strong><br>实现用(?!exp)：</p>\n<pre><code class=\"javascript\">//(?!exp)不包含?!exp后面的字符(意味着不能是纯数字 纯字母 纯特殊字符)\n/(?!^[0-9]+$)(?!^[a-z]+$)(?!^[_\\-@&amp;=]]+$)^[0-9a-z_\\-@&amp;=]+$/\n</code></pre>\n<p>###解读正则</p>\n<p><strong> 正则以^开始，限定匹配字符串是从开始位置进行匹配，(?=.<em>?[a-z])是肯定型顺序环视，限定当前位置的后面，能匹配.</em>?[a-z]，也就是，能够匹配到一个字母，同理，(?=.<em>?[0-9])表示限定当前位置的后面，能匹配一个数字，(?=.</em>?[<em>-@&amp;=])表示限定当前位置的后面，能匹配一个特殊字符，而[a-z0-9</em>-@&amp;=]+就是前面那些环视限定的位置，即表示[a-z0-9_-@&amp;=]+中，至少匹配一个字母、一个数字、一个特殊字符，最终匹配到达字符串结束位置$。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://deerchao.net/tutorials/regex/regex-1.htm\" target=\"_blank\" rel=\"external\">30分钟入门正则表达式</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong> 做表单验证经常做判断密码的组合，强度之类的校验，最近仔细研究了下正则，体会到了正则的强大，所以用几种方法来实现这一需求 </strong></p>\n</blockquote>","more":"<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p><strong> 正则表达式中必须包含字母数字(不能纯数字或纯字母)，那么就必须要判断该字符串中：</strong></p>\n<ul>\n<li>必须包含数字</li>\n<li>必须包含字母</li>\n</ul>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>这里会用到正则的环视(零宽断言):(?=exp)和(?!exp),所以我们的正则可以写为：<br>第一种实现用(?=exp)：</p>\n<pre><code class=\"javascript\">//(?=exp) 必须包含?=exp 后面的字符(意味着必须有至少一个字母，一个数字)\n/^(?=.*?[0-9])(?=.*?[a-z])[0-9a-z]+$/\n</code></pre>\n<p>第二种实现用(?!exp)：</p>\n<pre><code class=\"javascript\">//(?!exp)不包含?!exp后面的字符(意味着不能是纯数字 纯字母)\n/(?!^[0-9]+$)(?!^[a-z]+$)^[0-9a-z]+$/\n</code></pre>\n<p>当然,如果需要限定字符串长度,我们后面的[a-z0-9]+可以改为一个长度范围,+改为如{5,16};</p>\n<h3 id=\"改需求-必须包含字母数字特殊字符\"><a href=\"#改需求-必须包含字母数字特殊字符\" class=\"headerlink\" title=\"改需求 必须包含字母数字特殊字符\"></a>改需求 必须包含字母数字特殊字符</h3><p><strong> 其实就是在上面的正则中加入特殊字符即可 这里只输入_-@&amp;=几个字符，根据需要可自行扩充 </strong><br>第一种实现用(?=exp)：</p>\n<pre><code class=\"javascript\">//(?=exp) 必须包含?=exp 后面的字符(意味着必须有至少一个字母，一个数字，一个特殊字符)\n/^(?=.*?[0-9])(?=.*?[a-z])(?=.*?[_\\-@&amp;=])[0-9a-z_\\-@&amp;=]+$/\n</code></pre>\n<p>第二种实现用混合</p>\n<pre><code class=\"javascript\">//(?=exp)\n//必须包含?=exp 后面的字符(意味着必须有至有字母，数字，不全是字母数字\n//(意味着有特殊字符))\n /^(?=.*?\\d)(?=.*?[a-z])(?!^[a-z\\d]+$).+$/;\n</code></pre>\n<h3 id=\"改需求-必须包含字母数字特殊字符中任意两种组合\"><a href=\"#改需求-必须包含字母数字特殊字符中任意两种组合\" class=\"headerlink\" title=\"改需求 必须包含字母数字特殊字符中任意两种组合\"></a>改需求 必须包含字母数字特殊字符中任意两种组合</h3><p><strong> 其实就是在上面的正则中加入特殊字符即可 这里只输入_-@&amp;=几个字符，根据需要可自行扩充 </strong><br>实现用(?!exp)：</p>\n<pre><code class=\"javascript\">//(?!exp)不包含?!exp后面的字符(意味着不能是纯数字 纯字母 纯特殊字符)\n/(?!^[0-9]+$)(?!^[a-z]+$)(?!^[_\\-@&amp;=]]+$)^[0-9a-z_\\-@&amp;=]+$/\n</code></pre>\n<p>###解读正则</p>\n<p><strong> 正则以^开始，限定匹配字符串是从开始位置进行匹配，(?=.<em>?[a-z])是肯定型顺序环视，限定当前位置的后面，能匹配.</em>?[a-z]，也就是，能够匹配到一个字母，同理，(?=.<em>?[0-9])表示限定当前位置的后面，能匹配一个数字，(?=.</em>?[<em>-@&amp;=])表示限定当前位置的后面，能匹配一个特殊字符，而[a-z0-9</em>-@&amp;=]+就是前面那些环视限定的位置，即表示[a-z0-9_-@&amp;=]+中，至少匹配一个字母、一个数字、一个特殊字符，最终匹配到达字符串结束位置$。</strong></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://deerchao.net/tutorials/regex/regex-1.htm\" target=\"_blank\" rel=\"external\">30分钟入门正则表达式</a></p>"},{"title":"每隔四个字符添加一个空格的正则怎么写?","date":"2017-03-11T09:14:44.000Z","_content":"> 最近有懒惰不少,好久没写博客了,今天在一群里看到有小伙伴问怎用正则规律的添加空格,花了几分钟写了下,做下记录\n\n## 需求\n这样的效果在填写银行卡的时候十分常见，这也是非常人性化的举措,动笔写吧,起初我想用js实现，可想想各种字符串,各种循环,我决定还是得正则靠谱.\n<!-- more -->\n## 实现\n试了下,一个正则我还搞不定,水平有限就用俩吧：\n分析：\n* 首先肯定是得把4n个字符找出来\n* 其次把剩余的字符找出来\n\n```javascript\n//取前4n个字符\nvar reg = /(\\w{4})/g;\n//拿到最后剩余的字符\nvar reg2 = /(?:\\w{4})+(\\w+)/g;\n```\n## 封装\n接下来我们这这些代码组织一下,封装一个通用的方法，进而只需要传字符,可自动输出想要的字符：\n```javascript\nfunction getSpace(s){\n    //过滤了空格的存在\n    //实际中根据需求是否必须去掉空格\n    s = s.replace(/\\s*/g,'');\n    if(s.length === 0){\n        return '';\n    }\n    if(s.length < 4 && s.length !== 0){\n        return s;\n    }\n    var m,n,res = '';\n    var reg = /(\\w{4})/g;\n    var reg2 = /(?:\\w{4})+(\\w+)/;\n    while(m = reg.exec(s)){\n        //循环加空格\n        res += m[1] +' ';\n    }\n    //做下判断是否是4的整数倍\n    if(s.length%4 == 0){\n        //整数倍会多一个空格 去除\n        return res.replace(/\\s$/,'');\n    }else{\n        //否则用俩正则\n        var n = reg2.exec(s);\n        return (res+n[1]);\n    }\n}\n//Demo\nvar str = '1234567890';\nconsole.log(getSpace(str));\n//1234 5678 90\n```\n## 实战\n下面是支付宝的绑定银行卡界面:\n监听oninput事件,进行实时的提示用户输入的卡号\n![][1]\n咱们模拟下：\n```javascript\n//html\n<input type=\"text\" id=\"get\">\n<div class=\"show\"></div>\n\n//js\nvar box = document.querySelector('#get');\nvar show = document.querySelector('.show');\nbox.oninput = function(){\n    show.innerHTML =getSpace(box.value);\n}\n//ok大功告成 自己测试去吧\n```\n![][2]\n## 通用模块封装\n```javascript\n/*\n*@param s 即将被转化的字符  String\n*@param num 字符的间隔    Number\n*@param type 字符的类型  String\n*/\nfunction getSpace(s,num,type){\n    //过滤了空格的存在\n    //实际中根据需求是否必须去掉空格\n    s = s.replace(/\\s*/g,'');\n    if(s.length === 0){\n        return '';\n    }\n    if(s.length < num && s.length !== 0){\n        return s;\n    }\n    var m,n,res = '';\n    var reg = new RegExp('(\\\\w{'+num+'})','g');\n    var reg2 = new RegExp('(?:\\\\w{'+num+'})+(\\\\w+)','g');\n    var reg3 = new RegExp(''+type+'$');\n    while(m = reg.exec(s)){\n        res += m[1] + type;\n    }\n    if(s.length%num == 0){\n        return res.replace(reg3,'');\n    }else{\n        var n = reg2.exec(s);\n        return (res+n[1]);\n    }\n}\n//用法\nvar st = '1234567890';\ngetSpace(st,3,',');\n//123,456,789,0\ngetSpace(st,4,'.');\n//1234.5678.90\ngetSpace(st,2,'$');\n//12$34$56$78$90\n\n//诸位发挥想象力吧...........\n//想怎么用就怎么用....\n```\n## 说明\n本文所写的函数,适用于数字字母下划线,没有做只允许数字的判断,如果需要只需在函数开始对s进行判断，return 即可;如有问题,请评论区留言\n\n[1]: http://oiukswkar.bkt.clouddn.com/bank-number.png\n[2]: http://oiukswkar.bkt.clouddn.com/bank-number2.png\n","source":"_posts/每隔四个字符添加一个空格的正则怎么写.md","raw":"---\ntitle: 每隔四个字符添加一个空格的正则怎么写?\ndate: 2017-03-11 17:14:44\ntags: [javascript,RegExp,\"正则\"]\ncategories: Javascript\n---\n> 最近有懒惰不少,好久没写博客了,今天在一群里看到有小伙伴问怎用正则规律的添加空格,花了几分钟写了下,做下记录\n\n## 需求\n这样的效果在填写银行卡的时候十分常见，这也是非常人性化的举措,动笔写吧,起初我想用js实现，可想想各种字符串,各种循环,我决定还是得正则靠谱.\n<!-- more -->\n## 实现\n试了下,一个正则我还搞不定,水平有限就用俩吧：\n分析：\n* 首先肯定是得把4n个字符找出来\n* 其次把剩余的字符找出来\n\n```javascript\n//取前4n个字符\nvar reg = /(\\w{4})/g;\n//拿到最后剩余的字符\nvar reg2 = /(?:\\w{4})+(\\w+)/g;\n```\n## 封装\n接下来我们这这些代码组织一下,封装一个通用的方法，进而只需要传字符,可自动输出想要的字符：\n```javascript\nfunction getSpace(s){\n    //过滤了空格的存在\n    //实际中根据需求是否必须去掉空格\n    s = s.replace(/\\s*/g,'');\n    if(s.length === 0){\n        return '';\n    }\n    if(s.length < 4 && s.length !== 0){\n        return s;\n    }\n    var m,n,res = '';\n    var reg = /(\\w{4})/g;\n    var reg2 = /(?:\\w{4})+(\\w+)/;\n    while(m = reg.exec(s)){\n        //循环加空格\n        res += m[1] +' ';\n    }\n    //做下判断是否是4的整数倍\n    if(s.length%4 == 0){\n        //整数倍会多一个空格 去除\n        return res.replace(/\\s$/,'');\n    }else{\n        //否则用俩正则\n        var n = reg2.exec(s);\n        return (res+n[1]);\n    }\n}\n//Demo\nvar str = '1234567890';\nconsole.log(getSpace(str));\n//1234 5678 90\n```\n## 实战\n下面是支付宝的绑定银行卡界面:\n监听oninput事件,进行实时的提示用户输入的卡号\n![][1]\n咱们模拟下：\n```javascript\n//html\n<input type=\"text\" id=\"get\">\n<div class=\"show\"></div>\n\n//js\nvar box = document.querySelector('#get');\nvar show = document.querySelector('.show');\nbox.oninput = function(){\n    show.innerHTML =getSpace(box.value);\n}\n//ok大功告成 自己测试去吧\n```\n![][2]\n## 通用模块封装\n```javascript\n/*\n*@param s 即将被转化的字符  String\n*@param num 字符的间隔    Number\n*@param type 字符的类型  String\n*/\nfunction getSpace(s,num,type){\n    //过滤了空格的存在\n    //实际中根据需求是否必须去掉空格\n    s = s.replace(/\\s*/g,'');\n    if(s.length === 0){\n        return '';\n    }\n    if(s.length < num && s.length !== 0){\n        return s;\n    }\n    var m,n,res = '';\n    var reg = new RegExp('(\\\\w{'+num+'})','g');\n    var reg2 = new RegExp('(?:\\\\w{'+num+'})+(\\\\w+)','g');\n    var reg3 = new RegExp(''+type+'$');\n    while(m = reg.exec(s)){\n        res += m[1] + type;\n    }\n    if(s.length%num == 0){\n        return res.replace(reg3,'');\n    }else{\n        var n = reg2.exec(s);\n        return (res+n[1]);\n    }\n}\n//用法\nvar st = '1234567890';\ngetSpace(st,3,',');\n//123,456,789,0\ngetSpace(st,4,'.');\n//1234.5678.90\ngetSpace(st,2,'$');\n//12$34$56$78$90\n\n//诸位发挥想象力吧...........\n//想怎么用就怎么用....\n```\n## 说明\n本文所写的函数,适用于数字字母下划线,没有做只允许数字的判断,如果需要只需在函数开始对s进行判断，return 即可;如有问题,请评论区留言\n\n[1]: http://oiukswkar.bkt.clouddn.com/bank-number.png\n[2]: http://oiukswkar.bkt.clouddn.com/bank-number2.png\n","slug":"每隔四个字符添加一个空格的正则怎么写","published":1,"updated":"2019-09-25T15:10:25.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pv005gla2ekjb0cpj1","content":"<blockquote>\n<p>最近有懒惰不少,好久没写博客了,今天在一群里看到有小伙伴问怎用正则规律的添加空格,花了几分钟写了下,做下记录</p>\n</blockquote>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>这样的效果在填写银行卡的时候十分常见，这也是非常人性化的举措,动笔写吧,起初我想用js实现，可想想各种字符串,各种循环,我决定还是得正则靠谱.<br><a id=\"more\"></a></p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>试了下,一个正则我还搞不定,水平有限就用俩吧：<br>分析：</p>\n<ul>\n<li>首先肯定是得把4n个字符找出来</li>\n<li>其次把剩余的字符找出来</li>\n</ul>\n<pre><code class=\"javascript\">//取前4n个字符\nvar reg = /(\\w{4})/g;\n//拿到最后剩余的字符\nvar reg2 = /(?:\\w{4})+(\\w+)/g;\n</code></pre>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>接下来我们这这些代码组织一下,封装一个通用的方法，进而只需要传字符,可自动输出想要的字符：</p>\n<pre><code class=\"javascript\">function getSpace(s){\n    //过滤了空格的存在\n    //实际中根据需求是否必须去掉空格\n    s = s.replace(/\\s*/g,&#39;&#39;);\n    if(s.length === 0){\n        return &#39;&#39;;\n    }\n    if(s.length &lt; 4 &amp;&amp; s.length !== 0){\n        return s;\n    }\n    var m,n,res = &#39;&#39;;\n    var reg = /(\\w{4})/g;\n    var reg2 = /(?:\\w{4})+(\\w+)/;\n    while(m = reg.exec(s)){\n        //循环加空格\n        res += m[1] +&#39; &#39;;\n    }\n    //做下判断是否是4的整数倍\n    if(s.length%4 == 0){\n        //整数倍会多一个空格 去除\n        return res.replace(/\\s$/,&#39;&#39;);\n    }else{\n        //否则用俩正则\n        var n = reg2.exec(s);\n        return (res+n[1]);\n    }\n}\n//Demo\nvar str = &#39;1234567890&#39;;\nconsole.log(getSpace(str));\n//1234 5678 90\n</code></pre>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>下面是支付宝的绑定银行卡界面:<br>监听oninput事件,进行实时的提示用户输入的卡号<br><img src=\"http://oiukswkar.bkt.clouddn.com/bank-number.png\" alt=\"\"><br>咱们模拟下：</p>\n<pre><code class=\"javascript\">//html\n&lt;input type=&quot;text&quot; id=&quot;get&quot;&gt;\n&lt;div class=&quot;show&quot;&gt;&lt;/div&gt;\n\n//js\nvar box = document.querySelector(&#39;#get&#39;);\nvar show = document.querySelector(&#39;.show&#39;);\nbox.oninput = function(){\n    show.innerHTML =getSpace(box.value);\n}\n//ok大功告成 自己测试去吧\n</code></pre>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/bank-number2.png\" alt=\"\"></p>\n<h2 id=\"通用模块封装\"><a href=\"#通用模块封装\" class=\"headerlink\" title=\"通用模块封装\"></a>通用模块封装</h2><pre><code class=\"javascript\">/*\n*@param s 即将被转化的字符  String\n*@param num 字符的间隔    Number\n*@param type 字符的类型  String\n*/\nfunction getSpace(s,num,type){\n    //过滤了空格的存在\n    //实际中根据需求是否必须去掉空格\n    s = s.replace(/\\s*/g,&#39;&#39;);\n    if(s.length === 0){\n        return &#39;&#39;;\n    }\n    if(s.length &lt; num &amp;&amp; s.length !== 0){\n        return s;\n    }\n    var m,n,res = &#39;&#39;;\n    var reg = new RegExp(&#39;(\\\\w{&#39;+num+&#39;})&#39;,&#39;g&#39;);\n    var reg2 = new RegExp(&#39;(?:\\\\w{&#39;+num+&#39;})+(\\\\w+)&#39;,&#39;g&#39;);\n    var reg3 = new RegExp(&#39;&#39;+type+&#39;$&#39;);\n    while(m = reg.exec(s)){\n        res += m[1] + type;\n    }\n    if(s.length%num == 0){\n        return res.replace(reg3,&#39;&#39;);\n    }else{\n        var n = reg2.exec(s);\n        return (res+n[1]);\n    }\n}\n//用法\nvar st = &#39;1234567890&#39;;\ngetSpace(st,3,&#39;,&#39;);\n//123,456,789,0\ngetSpace(st,4,&#39;.&#39;);\n//1234.5678.90\ngetSpace(st,2,&#39;$&#39;);\n//12$34$56$78$90\n\n//诸位发挥想象力吧...........\n//想怎么用就怎么用....\n</code></pre>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>本文所写的函数,适用于数字字母下划线,没有做只允许数字的判断,如果需要只需在函数开始对s进行判断，return 即可;如有问题,请评论区留言</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近有懒惰不少,好久没写博客了,今天在一群里看到有小伙伴问怎用正则规律的添加空格,花了几分钟写了下,做下记录</p>\n</blockquote>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>这样的效果在填写银行卡的时候十分常见，这也是非常人性化的举措,动笔写吧,起初我想用js实现，可想想各种字符串,各种循环,我决定还是得正则靠谱.<br>","more":"</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>试了下,一个正则我还搞不定,水平有限就用俩吧：<br>分析：</p>\n<ul>\n<li>首先肯定是得把4n个字符找出来</li>\n<li>其次把剩余的字符找出来</li>\n</ul>\n<pre><code class=\"javascript\">//取前4n个字符\nvar reg = /(\\w{4})/g;\n//拿到最后剩余的字符\nvar reg2 = /(?:\\w{4})+(\\w+)/g;\n</code></pre>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><p>接下来我们这这些代码组织一下,封装一个通用的方法，进而只需要传字符,可自动输出想要的字符：</p>\n<pre><code class=\"javascript\">function getSpace(s){\n    //过滤了空格的存在\n    //实际中根据需求是否必须去掉空格\n    s = s.replace(/\\s*/g,&#39;&#39;);\n    if(s.length === 0){\n        return &#39;&#39;;\n    }\n    if(s.length &lt; 4 &amp;&amp; s.length !== 0){\n        return s;\n    }\n    var m,n,res = &#39;&#39;;\n    var reg = /(\\w{4})/g;\n    var reg2 = /(?:\\w{4})+(\\w+)/;\n    while(m = reg.exec(s)){\n        //循环加空格\n        res += m[1] +&#39; &#39;;\n    }\n    //做下判断是否是4的整数倍\n    if(s.length%4 == 0){\n        //整数倍会多一个空格 去除\n        return res.replace(/\\s$/,&#39;&#39;);\n    }else{\n        //否则用俩正则\n        var n = reg2.exec(s);\n        return (res+n[1]);\n    }\n}\n//Demo\nvar str = &#39;1234567890&#39;;\nconsole.log(getSpace(str));\n//1234 5678 90\n</code></pre>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>下面是支付宝的绑定银行卡界面:<br>监听oninput事件,进行实时的提示用户输入的卡号<br><img src=\"http://oiukswkar.bkt.clouddn.com/bank-number.png\" alt=\"\"><br>咱们模拟下：</p>\n<pre><code class=\"javascript\">//html\n&lt;input type=&quot;text&quot; id=&quot;get&quot;&gt;\n&lt;div class=&quot;show&quot;&gt;&lt;/div&gt;\n\n//js\nvar box = document.querySelector(&#39;#get&#39;);\nvar show = document.querySelector(&#39;.show&#39;);\nbox.oninput = function(){\n    show.innerHTML =getSpace(box.value);\n}\n//ok大功告成 自己测试去吧\n</code></pre>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/bank-number2.png\" alt=\"\"></p>\n<h2 id=\"通用模块封装\"><a href=\"#通用模块封装\" class=\"headerlink\" title=\"通用模块封装\"></a>通用模块封装</h2><pre><code class=\"javascript\">/*\n*@param s 即将被转化的字符  String\n*@param num 字符的间隔    Number\n*@param type 字符的类型  String\n*/\nfunction getSpace(s,num,type){\n    //过滤了空格的存在\n    //实际中根据需求是否必须去掉空格\n    s = s.replace(/\\s*/g,&#39;&#39;);\n    if(s.length === 0){\n        return &#39;&#39;;\n    }\n    if(s.length &lt; num &amp;&amp; s.length !== 0){\n        return s;\n    }\n    var m,n,res = &#39;&#39;;\n    var reg = new RegExp(&#39;(\\\\w{&#39;+num+&#39;})&#39;,&#39;g&#39;);\n    var reg2 = new RegExp(&#39;(?:\\\\w{&#39;+num+&#39;})+(\\\\w+)&#39;,&#39;g&#39;);\n    var reg3 = new RegExp(&#39;&#39;+type+&#39;$&#39;);\n    while(m = reg.exec(s)){\n        res += m[1] + type;\n    }\n    if(s.length%num == 0){\n        return res.replace(reg3,&#39;&#39;);\n    }else{\n        var n = reg2.exec(s);\n        return (res+n[1]);\n    }\n}\n//用法\nvar st = &#39;1234567890&#39;;\ngetSpace(st,3,&#39;,&#39;);\n//123,456,789,0\ngetSpace(st,4,&#39;.&#39;);\n//1234.5678.90\ngetSpace(st,2,&#39;$&#39;);\n//12$34$56$78$90\n\n//诸位发挥想象力吧...........\n//想怎么用就怎么用....\n</code></pre>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>本文所写的函数,适用于数字字母下划线,没有做只允许数字的判断,如果需要只需在函数开始对s进行判断，return 即可;如有问题,请评论区留言</p>"},{"title":"浅谈jsvascript随机函数Math.random()","date":"2016-12-27T13:13:12.000Z","_content":"\n<!-- more -->\n## 背景\n** Math.random() 方法可返回介于 0 ~ 1 之间的一个随机数。**\n** 返回指定范围的随机数(m-n)之间)的公式：Math.random()*(n-m)+m；**\n\n## 随机数\n随机数是统计学领域的一个概念，对于游戏来说也是意义非凡（不玩游戏的我~ ~ ~），用好随机数，其实可以实现很多有意思的效果.\n\n炒个栗子：抽奖大转盘程序，每当转盘停止转动的时候，指针恰好指向奖品图片的正中点，有人会觉得这不自然，不符合随机的规律。指向一个随机的位置可能更能让人容易接受。\n\n学过 JavaScript 的人都知道，应用随机数很简单，只要一个 Math.random() 就可以获得一个大于等于 0 小于 1 的浮点数。从一个集合中随机选择对象时，使用浮点数离散化后的结果作为选择集的索引：\n如下：\n```javascript\nvar arr = [...];//很多组数据的集合\nvar ranIndex = parseInt( Math.random() * arr.length );\nvar result = arr[ranIndex];\n```\n## 产生符合指定概率模型的随机数\n就像我们做一些特效一样，缓慢的节奏可以是动画更加动感，应用合适的概率分布也能让页面更具有表现力。而概率分布需要足够大的样本集才能体现效果，在** [codepen][2](因为还没有弄好图片，大家可以移步去这里一探究竟)**经常可以看到各种粒子效果（烟花，火焰，炫光）都离不开概率分布.\n\n讲个比较贴近现实的栗子，平常开发过程中，抽奖需求应该用的蛮多的，抽奖活动中所有的奖品中，苹果电脑 和 移动电源中奖概率会一样么？为每一种奖品配置不同的概率是任何一款抽奖平台的基本功能。\n举个例子：假设某次抽奖活动，奖品概率设置如下：\n* 小米背包:0.01\n* 旅行箱:0.03\n* 移动电源:0.06\n* 不中奖（也看作一种商品）:0.9\n\n意思就是在10000次抽奖中，抽中100个移动电源，300个旅行箱，600个移动电源，9000次不中奖.\n基本设计思路：设计一个returnRandom()函数，返回一个大于0小于1的浮点数，将0到1之间等分成四段，每一段对应一个奖品，根据函数的返回值来决定命中那个奖品；所以returnRandom()函数的返回值要满足如下：\n* 返回值区间 [0,0.25],概率 0.01\n* 返回值区间[0.25,0.5],概率0.03\n* 返回值区间[0.5,0.75],概率0.06\n* 返回值区间[0.75,1],概率0.9\n\n\n```javascript\nfunction  returnRandom(){\n\tvar m = Math.random(),\n\tn = Math.random()/4;\n\tif(m < 0.01){\n\t\treturn 0 + n;\n\t}\n\tif(m < 0.03){\n\t\treturn 0.25 + n;\n\t}\n\tif(m < 0.06){\n\t\treturn 0.5 + n;\n\t}\n\tif(m < 1){\n\t\treturn 0.75 + n;\n\t}\n}\n```\n使用的时候，可以用熟悉的调用方式:\n```javascript\nvar arr = [\"小米背包\",\"旅行箱\",\"移动电源\",\"谢谢参与\"];\nvar ranIndex = parseInt( returnRandom() * arr.length );\nvar result = arr[ranIndex];\n```\n具体实现：\n用博客中之前写的数组去重函数来实现统计运算一百万次的概率\n```javascript\nvar test = [];//一个新的临时数组\nfor(let i=0;i<1000000;i++){\n\ttest.push(parseInt( returnRandom()*4 ))//储存运算十万次后得到的数据\n}\nfunction unique1(){\n\tvar obj = {};\n\tvar result = [];//用来接收测到的数据\n\tfor(var i=0;i<test.length;i++){//遍历当前数组\n\t\tif(!obj[test[i]]){//如果没有当前项\n\t\t\tresult[test[i]] = 1\n\t\t}else{\n\t\t\tresult[test[i]] ++;\n\t}\n}\n```\n数据导入echart3.0后得出如下图：\n![Math.random()测试概率][3]\n## 概率的可配置化\n\n上一段代码演示了如何生成符合指定概率模型的随机浮点数，它的缺限在于模型的数据硬编码在函数体内，维护起来有困难。\n\n如果设计一个工厂函数，根据输入的权重数据来动态创建随机函数，会给实际应用中带来很大便利。\n后续在更.....\n\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/mathran.jpg\n  [2]: http://codepen.io/taobaofed/full/VeYZvL/?count=10000\n  [3]: http://oiukswkar.bkt.clouddn.com/mathrandom.png\n","source":"_posts/浅析js随机数Math.random().md","raw":"---\ntitle: 浅谈jsvascript随机函数Math.random()\ndate: 2016-12-27 21:13:12\ntags: [javascript]\ncategories: Javascript\n---\n\n<!-- more -->\n## 背景\n** Math.random() 方法可返回介于 0 ~ 1 之间的一个随机数。**\n** 返回指定范围的随机数(m-n)之间)的公式：Math.random()*(n-m)+m；**\n\n## 随机数\n随机数是统计学领域的一个概念，对于游戏来说也是意义非凡（不玩游戏的我~ ~ ~），用好随机数，其实可以实现很多有意思的效果.\n\n炒个栗子：抽奖大转盘程序，每当转盘停止转动的时候，指针恰好指向奖品图片的正中点，有人会觉得这不自然，不符合随机的规律。指向一个随机的位置可能更能让人容易接受。\n\n学过 JavaScript 的人都知道，应用随机数很简单，只要一个 Math.random() 就可以获得一个大于等于 0 小于 1 的浮点数。从一个集合中随机选择对象时，使用浮点数离散化后的结果作为选择集的索引：\n如下：\n```javascript\nvar arr = [...];//很多组数据的集合\nvar ranIndex = parseInt( Math.random() * arr.length );\nvar result = arr[ranIndex];\n```\n## 产生符合指定概率模型的随机数\n就像我们做一些特效一样，缓慢的节奏可以是动画更加动感，应用合适的概率分布也能让页面更具有表现力。而概率分布需要足够大的样本集才能体现效果，在** [codepen][2](因为还没有弄好图片，大家可以移步去这里一探究竟)**经常可以看到各种粒子效果（烟花，火焰，炫光）都离不开概率分布.\n\n讲个比较贴近现实的栗子，平常开发过程中，抽奖需求应该用的蛮多的，抽奖活动中所有的奖品中，苹果电脑 和 移动电源中奖概率会一样么？为每一种奖品配置不同的概率是任何一款抽奖平台的基本功能。\n举个例子：假设某次抽奖活动，奖品概率设置如下：\n* 小米背包:0.01\n* 旅行箱:0.03\n* 移动电源:0.06\n* 不中奖（也看作一种商品）:0.9\n\n意思就是在10000次抽奖中，抽中100个移动电源，300个旅行箱，600个移动电源，9000次不中奖.\n基本设计思路：设计一个returnRandom()函数，返回一个大于0小于1的浮点数，将0到1之间等分成四段，每一段对应一个奖品，根据函数的返回值来决定命中那个奖品；所以returnRandom()函数的返回值要满足如下：\n* 返回值区间 [0,0.25],概率 0.01\n* 返回值区间[0.25,0.5],概率0.03\n* 返回值区间[0.5,0.75],概率0.06\n* 返回值区间[0.75,1],概率0.9\n\n\n```javascript\nfunction  returnRandom(){\n\tvar m = Math.random(),\n\tn = Math.random()/4;\n\tif(m < 0.01){\n\t\treturn 0 + n;\n\t}\n\tif(m < 0.03){\n\t\treturn 0.25 + n;\n\t}\n\tif(m < 0.06){\n\t\treturn 0.5 + n;\n\t}\n\tif(m < 1){\n\t\treturn 0.75 + n;\n\t}\n}\n```\n使用的时候，可以用熟悉的调用方式:\n```javascript\nvar arr = [\"小米背包\",\"旅行箱\",\"移动电源\",\"谢谢参与\"];\nvar ranIndex = parseInt( returnRandom() * arr.length );\nvar result = arr[ranIndex];\n```\n具体实现：\n用博客中之前写的数组去重函数来实现统计运算一百万次的概率\n```javascript\nvar test = [];//一个新的临时数组\nfor(let i=0;i<1000000;i++){\n\ttest.push(parseInt( returnRandom()*4 ))//储存运算十万次后得到的数据\n}\nfunction unique1(){\n\tvar obj = {};\n\tvar result = [];//用来接收测到的数据\n\tfor(var i=0;i<test.length;i++){//遍历当前数组\n\t\tif(!obj[test[i]]){//如果没有当前项\n\t\t\tresult[test[i]] = 1\n\t\t}else{\n\t\t\tresult[test[i]] ++;\n\t}\n}\n```\n数据导入echart3.0后得出如下图：\n![Math.random()测试概率][3]\n## 概率的可配置化\n\n上一段代码演示了如何生成符合指定概率模型的随机浮点数，它的缺限在于模型的数据硬编码在函数体内，维护起来有困难。\n\n如果设计一个工厂函数，根据输入的权重数据来动态创建随机函数，会给实际应用中带来很大便利。\n后续在更.....\n\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/mathran.jpg\n  [2]: http://codepen.io/taobaofed/full/VeYZvL/?count=10000\n  [3]: http://oiukswkar.bkt.clouddn.com/mathrandom.png\n","slug":"浅析js随机数Math.random()","published":1,"updated":"2019-09-25T15:10:25.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pw005kla2eksv4vevl","content":"<a id=\"more\"></a>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><strong> Math.random() 方法可返回介于 0 ~ 1 之间的一个随机数。</strong><br><strong> 返回指定范围的随机数(m-n)之间)的公式：Math.random()*(n-m)+m；</strong></p>\n<h2 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h2><p>随机数是统计学领域的一个概念，对于游戏来说也是意义非凡（不玩游戏的我~ ~ ~），用好随机数，其实可以实现很多有意思的效果.</p>\n<p>炒个栗子：抽奖大转盘程序，每当转盘停止转动的时候，指针恰好指向奖品图片的正中点，有人会觉得这不自然，不符合随机的规律。指向一个随机的位置可能更能让人容易接受。</p>\n<p>学过 JavaScript 的人都知道，应用随机数很简单，只要一个 Math.random() 就可以获得一个大于等于 0 小于 1 的浮点数。从一个集合中随机选择对象时，使用浮点数离散化后的结果作为选择集的索引：<br>如下：</p>\n<pre><code class=\"javascript\">var arr = [...];//很多组数据的集合\nvar ranIndex = parseInt( Math.random() * arr.length );\nvar result = arr[ranIndex];\n</code></pre>\n<h2 id=\"产生符合指定概率模型的随机数\"><a href=\"#产生符合指定概率模型的随机数\" class=\"headerlink\" title=\"产生符合指定概率模型的随机数\"></a>产生符合指定概率模型的随机数</h2><p>就像我们做一些特效一样，缓慢的节奏可以是动画更加动感，应用合适的概率分布也能让页面更具有表现力。而概率分布需要足够大的样本集才能体现效果，在<strong> <a href=\"http://codepen.io/taobaofed/full/VeYZvL/?count=10000\" target=\"_blank\" rel=\"external\">codepen</a>(因为还没有弄好图片，大家可以移步去这里一探究竟)</strong>经常可以看到各种粒子效果（烟花，火焰，炫光）都离不开概率分布.</p>\n<p>讲个比较贴近现实的栗子，平常开发过程中，抽奖需求应该用的蛮多的，抽奖活动中所有的奖品中，苹果电脑 和 移动电源中奖概率会一样么？为每一种奖品配置不同的概率是任何一款抽奖平台的基本功能。<br>举个例子：假设某次抽奖活动，奖品概率设置如下：</p>\n<ul>\n<li>小米背包:0.01</li>\n<li>旅行箱:0.03</li>\n<li>移动电源:0.06</li>\n<li>不中奖（也看作一种商品）:0.9</li>\n</ul>\n<p>意思就是在10000次抽奖中，抽中100个移动电源，300个旅行箱，600个移动电源，9000次不中奖.<br>基本设计思路：设计一个returnRandom()函数，返回一个大于0小于1的浮点数，将0到1之间等分成四段，每一段对应一个奖品，根据函数的返回值来决定命中那个奖品；所以returnRandom()函数的返回值要满足如下：</p>\n<ul>\n<li>返回值区间 [0,0.25],概率 0.01</li>\n<li>返回值区间[0.25,0.5],概率0.03</li>\n<li>返回值区间[0.5,0.75],概率0.06</li>\n<li>返回值区间[0.75,1],概率0.9</li>\n</ul>\n<pre><code class=\"javascript\">function  returnRandom(){\n    var m = Math.random(),\n    n = Math.random()/4;\n    if(m &lt; 0.01){\n        return 0 + n;\n    }\n    if(m &lt; 0.03){\n        return 0.25 + n;\n    }\n    if(m &lt; 0.06){\n        return 0.5 + n;\n    }\n    if(m &lt; 1){\n        return 0.75 + n;\n    }\n}\n</code></pre>\n<p>使用的时候，可以用熟悉的调用方式:</p>\n<pre><code class=\"javascript\">var arr = [&quot;小米背包&quot;,&quot;旅行箱&quot;,&quot;移动电源&quot;,&quot;谢谢参与&quot;];\nvar ranIndex = parseInt( returnRandom() * arr.length );\nvar result = arr[ranIndex];\n</code></pre>\n<p>具体实现：<br>用博客中之前写的数组去重函数来实现统计运算一百万次的概率</p>\n<pre><code class=\"javascript\">var test = [];//一个新的临时数组\nfor(let i=0;i&lt;1000000;i++){\n    test.push(parseInt( returnRandom()*4 ))//储存运算十万次后得到的数据\n}\nfunction unique1(){\n    var obj = {};\n    var result = [];//用来接收测到的数据\n    for(var i=0;i&lt;test.length;i++){//遍历当前数组\n        if(!obj[test[i]]){//如果没有当前项\n            result[test[i]] = 1\n        }else{\n            result[test[i]] ++;\n    }\n}\n</code></pre>\n<p>数据导入echart3.0后得出如下图：<br><img src=\"http://oiukswkar.bkt.clouddn.com/mathrandom.png\" alt=\"Math.random()测试概率\"></p>\n<h2 id=\"概率的可配置化\"><a href=\"#概率的可配置化\" class=\"headerlink\" title=\"概率的可配置化\"></a>概率的可配置化</h2><p>上一段代码演示了如何生成符合指定概率模型的随机浮点数，它的缺限在于模型的数据硬编码在函数体内，维护起来有困难。</p>\n<p>如果设计一个工厂函数，根据输入的权重数据来动态创建随机函数，会给实际应用中带来很大便利。<br>后续在更…..</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p><strong> Math.random() 方法可返回介于 0 ~ 1 之间的一个随机数。</strong><br><strong> 返回指定范围的随机数(m-n)之间)的公式：Math.random()*(n-m)+m；</strong></p>\n<h2 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h2><p>随机数是统计学领域的一个概念，对于游戏来说也是意义非凡（不玩游戏的我~ ~ ~），用好随机数，其实可以实现很多有意思的效果.</p>\n<p>炒个栗子：抽奖大转盘程序，每当转盘停止转动的时候，指针恰好指向奖品图片的正中点，有人会觉得这不自然，不符合随机的规律。指向一个随机的位置可能更能让人容易接受。</p>\n<p>学过 JavaScript 的人都知道，应用随机数很简单，只要一个 Math.random() 就可以获得一个大于等于 0 小于 1 的浮点数。从一个集合中随机选择对象时，使用浮点数离散化后的结果作为选择集的索引：<br>如下：</p>\n<pre><code class=\"javascript\">var arr = [...];//很多组数据的集合\nvar ranIndex = parseInt( Math.random() * arr.length );\nvar result = arr[ranIndex];\n</code></pre>\n<h2 id=\"产生符合指定概率模型的随机数\"><a href=\"#产生符合指定概率模型的随机数\" class=\"headerlink\" title=\"产生符合指定概率模型的随机数\"></a>产生符合指定概率模型的随机数</h2><p>就像我们做一些特效一样，缓慢的节奏可以是动画更加动感，应用合适的概率分布也能让页面更具有表现力。而概率分布需要足够大的样本集才能体现效果，在<strong> <a href=\"http://codepen.io/taobaofed/full/VeYZvL/?count=10000\" target=\"_blank\" rel=\"external\">codepen</a>(因为还没有弄好图片，大家可以移步去这里一探究竟)</strong>经常可以看到各种粒子效果（烟花，火焰，炫光）都离不开概率分布.</p>\n<p>讲个比较贴近现实的栗子，平常开发过程中，抽奖需求应该用的蛮多的，抽奖活动中所有的奖品中，苹果电脑 和 移动电源中奖概率会一样么？为每一种奖品配置不同的概率是任何一款抽奖平台的基本功能。<br>举个例子：假设某次抽奖活动，奖品概率设置如下：</p>\n<ul>\n<li>小米背包:0.01</li>\n<li>旅行箱:0.03</li>\n<li>移动电源:0.06</li>\n<li>不中奖（也看作一种商品）:0.9</li>\n</ul>\n<p>意思就是在10000次抽奖中，抽中100个移动电源，300个旅行箱，600个移动电源，9000次不中奖.<br>基本设计思路：设计一个returnRandom()函数，返回一个大于0小于1的浮点数，将0到1之间等分成四段，每一段对应一个奖品，根据函数的返回值来决定命中那个奖品；所以returnRandom()函数的返回值要满足如下：</p>\n<ul>\n<li>返回值区间 [0,0.25],概率 0.01</li>\n<li>返回值区间[0.25,0.5],概率0.03</li>\n<li>返回值区间[0.5,0.75],概率0.06</li>\n<li>返回值区间[0.75,1],概率0.9</li>\n</ul>\n<pre><code class=\"javascript\">function  returnRandom(){\n    var m = Math.random(),\n    n = Math.random()/4;\n    if(m &lt; 0.01){\n        return 0 + n;\n    }\n    if(m &lt; 0.03){\n        return 0.25 + n;\n    }\n    if(m &lt; 0.06){\n        return 0.5 + n;\n    }\n    if(m &lt; 1){\n        return 0.75 + n;\n    }\n}\n</code></pre>\n<p>使用的时候，可以用熟悉的调用方式:</p>\n<pre><code class=\"javascript\">var arr = [&quot;小米背包&quot;,&quot;旅行箱&quot;,&quot;移动电源&quot;,&quot;谢谢参与&quot;];\nvar ranIndex = parseInt( returnRandom() * arr.length );\nvar result = arr[ranIndex];\n</code></pre>\n<p>具体实现：<br>用博客中之前写的数组去重函数来实现统计运算一百万次的概率</p>\n<pre><code class=\"javascript\">var test = [];//一个新的临时数组\nfor(let i=0;i&lt;1000000;i++){\n    test.push(parseInt( returnRandom()*4 ))//储存运算十万次后得到的数据\n}\nfunction unique1(){\n    var obj = {};\n    var result = [];//用来接收测到的数据\n    for(var i=0;i&lt;test.length;i++){//遍历当前数组\n        if(!obj[test[i]]){//如果没有当前项\n            result[test[i]] = 1\n        }else{\n            result[test[i]] ++;\n    }\n}\n</code></pre>\n<p>数据导入echart3.0后得出如下图：<br><img src=\"http://oiukswkar.bkt.clouddn.com/mathrandom.png\" alt=\"Math.random()测试概率\"></p>\n<h2 id=\"概率的可配置化\"><a href=\"#概率的可配置化\" class=\"headerlink\" title=\"概率的可配置化\"></a>概率的可配置化</h2><p>上一段代码演示了如何生成符合指定概率模型的随机浮点数，它的缺限在于模型的数据硬编码在函数体内，维护起来有困难。</p>\n<p>如果设计一个工厂函数，根据输入的权重数据来动态创建随机函数，会给实际应用中带来很大便利。<br>后续在更…..</p>"},{"title":"浅谈LocalStorage响应事件","date":"2017-02-21T09:13:12.000Z","_content":"> ** 前几天群里看到有朋友提了一个这样的需求；A页面看视频,又在B页面打开相同视频，B页面视频看完时，A页面状态自动改变 **\n\n\n<!-- more -->\n### 回顾\n** localStorage API有哪些？**\n* localStorage.setItem()该方法接受两个参数——要创建/修改的数据项的键，和对应的值\n* localStorage.getItem()可以从存储中获取一个数据项。该方法接受数据项的键作为参数，并返回数据值\n* localStorage.removeItem() 接受一个参数——你想要移除的数据项的键，然后会将对应的数据项从域名对应的存储对象中移除\n* localStorage.clear() 不接受参数，只是简单地清空域名对应的整个存储对象\n\n具体的实践先不写了,后续有时间再写...(会有时间么)\n### StorageEvent 响应存储的变化\n先看下MDN的介绍:\n>无论何时,Storage对象发生变化时(即创建/更新/删除数据项时,重复设置相同的键值不会触发该事件，Storage.clear() 方法至多触发一次该事件),StorageEvent事件会触发.在同一个页面内发生的改变不会起作用——在相同域名下的其他页面(如一个新标签或iframe)发生的改变才会起作用.在其他域名下的页面不能访问相同的Storage对象。\n\n** 根据mdn的描述，说明该方法只能在通域名下使用 **\n\n写个样板DEMO\n```javascript\nwindow.addEventListener('storage',function(e){\n    e.key;//改变的数据项的键\n    e.oldValue;//改变前的旧值\n    e.newValue;//改变后的新值\n    e.url;//改变的存储对象所在的文档的 URL\n    e.storageArea;//以及存储对象本身\n})\n```\n** 该方法给予了我们很多想象力,像开头所说不同页面同域名下,所发生的的变化都可以通过该方法进行捕捉，进而更新相应数据 **\n### 演示DEMO\n[DEMO地址](http://loadingmore.com/demo/src/html/localstorage/page1.html)\n### 参考\n* [Web Storage API][1]\n* [LocalStorage][2]\n\n\n\n[1]: https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\n[2]: https://developer.mozilla.org/zh-CN/docs/Web/API/Storage\n[3]: http://oiukswkar.bkt.clouddn.com/localstorage.jpg\n","source":"_posts/浅谈LocalStorage响应事件.md","raw":"---\ntitle: 浅谈LocalStorage响应事件\ndate: 2017-02-21 17:13:12\ntags: [javascript,localStorage]\ncategories: Javascript\n---\n> ** 前几天群里看到有朋友提了一个这样的需求；A页面看视频,又在B页面打开相同视频，B页面视频看完时，A页面状态自动改变 **\n\n\n<!-- more -->\n### 回顾\n** localStorage API有哪些？**\n* localStorage.setItem()该方法接受两个参数——要创建/修改的数据项的键，和对应的值\n* localStorage.getItem()可以从存储中获取一个数据项。该方法接受数据项的键作为参数，并返回数据值\n* localStorage.removeItem() 接受一个参数——你想要移除的数据项的键，然后会将对应的数据项从域名对应的存储对象中移除\n* localStorage.clear() 不接受参数，只是简单地清空域名对应的整个存储对象\n\n具体的实践先不写了,后续有时间再写...(会有时间么)\n### StorageEvent 响应存储的变化\n先看下MDN的介绍:\n>无论何时,Storage对象发生变化时(即创建/更新/删除数据项时,重复设置相同的键值不会触发该事件，Storage.clear() 方法至多触发一次该事件),StorageEvent事件会触发.在同一个页面内发生的改变不会起作用——在相同域名下的其他页面(如一个新标签或iframe)发生的改变才会起作用.在其他域名下的页面不能访问相同的Storage对象。\n\n** 根据mdn的描述，说明该方法只能在通域名下使用 **\n\n写个样板DEMO\n```javascript\nwindow.addEventListener('storage',function(e){\n    e.key;//改变的数据项的键\n    e.oldValue;//改变前的旧值\n    e.newValue;//改变后的新值\n    e.url;//改变的存储对象所在的文档的 URL\n    e.storageArea;//以及存储对象本身\n})\n```\n** 该方法给予了我们很多想象力,像开头所说不同页面同域名下,所发生的的变化都可以通过该方法进行捕捉，进而更新相应数据 **\n### 演示DEMO\n[DEMO地址](http://loadingmore.com/demo/src/html/localstorage/page1.html)\n### 参考\n* [Web Storage API][1]\n* [LocalStorage][2]\n\n\n\n[1]: https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\n[2]: https://developer.mozilla.org/zh-CN/docs/Web/API/Storage\n[3]: http://oiukswkar.bkt.clouddn.com/localstorage.jpg\n","slug":"浅谈LocalStorage响应事件","published":1,"updated":"2019-09-25T15:10:25.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91px005nla2e1xopg3fn","content":"<blockquote>\n<p><strong> 前几天群里看到有朋友提了一个这样的需求；A页面看视频,又在B页面打开相同视频，B页面视频看完时，A页面状态自动改变 </strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h3><p><strong> localStorage API有哪些？</strong></p>\n<ul>\n<li>localStorage.setItem()该方法接受两个参数——要创建/修改的数据项的键，和对应的值</li>\n<li>localStorage.getItem()可以从存储中获取一个数据项。该方法接受数据项的键作为参数，并返回数据值</li>\n<li>localStorage.removeItem() 接受一个参数——你想要移除的数据项的键，然后会将对应的数据项从域名对应的存储对象中移除</li>\n<li>localStorage.clear() 不接受参数，只是简单地清空域名对应的整个存储对象</li>\n</ul>\n<p>具体的实践先不写了,后续有时间再写…(会有时间么)</p>\n<h3 id=\"StorageEvent-响应存储的变化\"><a href=\"#StorageEvent-响应存储的变化\" class=\"headerlink\" title=\"StorageEvent 响应存储的变化\"></a>StorageEvent 响应存储的变化</h3><p>先看下MDN的介绍:</p>\n<blockquote>\n<p>无论何时,Storage对象发生变化时(即创建/更新/删除数据项时,重复设置相同的键值不会触发该事件，Storage.clear() 方法至多触发一次该事件),StorageEvent事件会触发.在同一个页面内发生的改变不会起作用——在相同域名下的其他页面(如一个新标签或iframe)发生的改变才会起作用.在其他域名下的页面不能访问相同的Storage对象。</p>\n</blockquote>\n<p><strong> 根据mdn的描述，说明该方法只能在通域名下使用 </strong></p>\n<p>写个样板DEMO</p>\n<pre><code class=\"javascript\">window.addEventListener(&#39;storage&#39;,function(e){\n    e.key;//改变的数据项的键\n    e.oldValue;//改变前的旧值\n    e.newValue;//改变后的新值\n    e.url;//改变的存储对象所在的文档的 URL\n    e.storageArea;//以及存储对象本身\n})\n</code></pre>\n<p><strong> 该方法给予了我们很多想象力,像开头所说不同页面同域名下,所发生的的变化都可以通过该方法进行捕捉，进而更新相应数据 </strong></p>\n<h3 id=\"演示DEMO\"><a href=\"#演示DEMO\" class=\"headerlink\" title=\"演示DEMO\"></a>演示DEMO</h3><p><a href=\"http://loadingmore.com/demo/src/html/localstorage/page1.html\">DEMO地址</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\" target=\"_blank\" rel=\"external\">Web Storage API</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Storage\" target=\"_blank\" rel=\"external\">LocalStorage</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong> 前几天群里看到有朋友提了一个这样的需求；A页面看视频,又在B页面打开相同视频，B页面视频看完时，A页面状态自动改变 </strong></p>\n</blockquote>","more":"<h3 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h3><p><strong> localStorage API有哪些？</strong></p>\n<ul>\n<li>localStorage.setItem()该方法接受两个参数——要创建/修改的数据项的键，和对应的值</li>\n<li>localStorage.getItem()可以从存储中获取一个数据项。该方法接受数据项的键作为参数，并返回数据值</li>\n<li>localStorage.removeItem() 接受一个参数——你想要移除的数据项的键，然后会将对应的数据项从域名对应的存储对象中移除</li>\n<li>localStorage.clear() 不接受参数，只是简单地清空域名对应的整个存储对象</li>\n</ul>\n<p>具体的实践先不写了,后续有时间再写…(会有时间么)</p>\n<h3 id=\"StorageEvent-响应存储的变化\"><a href=\"#StorageEvent-响应存储的变化\" class=\"headerlink\" title=\"StorageEvent 响应存储的变化\"></a>StorageEvent 响应存储的变化</h3><p>先看下MDN的介绍:</p>\n<blockquote>\n<p>无论何时,Storage对象发生变化时(即创建/更新/删除数据项时,重复设置相同的键值不会触发该事件，Storage.clear() 方法至多触发一次该事件),StorageEvent事件会触发.在同一个页面内发生的改变不会起作用——在相同域名下的其他页面(如一个新标签或iframe)发生的改变才会起作用.在其他域名下的页面不能访问相同的Storage对象。</p>\n</blockquote>\n<p><strong> 根据mdn的描述，说明该方法只能在通域名下使用 </strong></p>\n<p>写个样板DEMO</p>\n<pre><code class=\"javascript\">window.addEventListener(&#39;storage&#39;,function(e){\n    e.key;//改变的数据项的键\n    e.oldValue;//改变前的旧值\n    e.newValue;//改变后的新值\n    e.url;//改变的存储对象所在的文档的 URL\n    e.storageArea;//以及存储对象本身\n})\n</code></pre>\n<p><strong> 该方法给予了我们很多想象力,像开头所说不同页面同域名下,所发生的的变化都可以通过该方法进行捕捉，进而更新相应数据 </strong></p>\n<h3 id=\"演示DEMO\"><a href=\"#演示DEMO\" class=\"headerlink\" title=\"演示DEMO\"></a>演示DEMO</h3><p><a href=\"http://loadingmore.com/demo/src/html/localstorage/page1.html\">DEMO地址</a></p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API\" target=\"_blank\" rel=\"external\">Web Storage API</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Storage\" target=\"_blank\" rel=\"external\">LocalStorage</a></li>\n</ul>"},{"title":"纯手工打造一款无缝滚动轮播插件","date":"2017-01-05T13:10:10.000Z","_content":">项目上经常会用到轮播，为避免重复劳动，遂决定实现一个灵活的无缝滚动轮播效果，注意：此插件依赖jquery；直接看代码。本文引入jq版本为1.11；\n\n![enter description here][1]\n<!-- more -->\n### [Demo演示][2]\n### 无缝滚动轮播原理\n```javascript\n/*\n\t无缝滚动原理：\n\t\t1、前后各加一张图片\n\t\t2、每次改变ss-inner盒子的位置（margin-left）\n\t\t3、自动轮播\n\t\t4、小圆圈点击切换\n*/\n```\n### HTML结构\n```html\n<div class=\"ss-wrapper\"><!-- 外层盒子 -->\n    <div class=\"ss-inner clearfix\"><!-- 内层盒子 -->\n        <div class=\"ss-item\"><!-- 图片盒子，数量自定 -->\n            <img src=\"img/banner01.jpg\">\n        </div>\n        <div class=\"ss-item\">\n            <img src=\"img/banner02.jpg\">\n        </div>\n        <div class=\"ss-item\">\n            <img src=\"img/banner03.jpg\">\n        </div>\n        <div class=\"ss-item\">\n            <img src=\"img/banner04.jpg\">\n        </div>\n        <div class=\"ss-item\">\n            <img src=\"img/banner05.jpg\">\n        </div>\n    </div>\n    <div class=\"ss-circle\"><!-- 小圆点盒子 -->\n        <span class=\"ss-circle-item active\"></span> <!-- 小圆点 数量自定 -->\n        <span class=\"ss-circle-item\"></span>\n        <span class=\"ss-circle-item\"></span>\n        <span class=\"ss-circle-item\"></span>\n        <span class=\"ss-circle-item\"></span>\n    </div>\n    <div class=\"ss-arrow-left ss-arrow\"></div><!-- 左点击 -->\n    <div class=\"ss-arrow-right ss-arrow\"></div><!-- 右点击 -->\n</div>\n```\n说明：html结构必须按照规范，但是图片的数量可以随便增删，小圆点根据图片的数量随意增删\n### CSS部分\n```css\n/*这里用*号，清除默认样式，实属偷懒，可自行写reset*/\n*{\n    margin: 0;\n    padding: 0;\n}\nhtml,body{\n    margin: 0;\n    padding: 0;\n    width: 100%;\n}\n.ss-wrapper{\n    width: 1000px;\n    margin: 0 auto;\n    height:564px;\n    overflow: hidden;\n    position: relative;\n}\n/*\n初始5张 后面会用js计算，不用在意此处\n五张默认5000,一张1000，根据自己需要写\n*/\n.ss-inner{\n    width: 5000px;\n}\n.clearfix{\n    display: block;\n    content: '';\n    overflow: hidden;\n    clear: both;\n}\n.ss-item{\n    float: left;\n    width: 1000px;\n    overflow: hidden;\n}\n.ss-item img{\n    display: block;\n    width: 100%;\n}\n/*小圆圈*/\n.ss-circle{\n    position: absolute;\n    left: 0;\n    bottom: 1%;\n    width: 100%;\n    text-align: center;\n\n}\n.ss-circle .ss-circle-item{\n    display: inline-block;\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    background-color: #fff;\n    cursor: pointer;\n}\n.ss-circle-item.active{\n    background-color: #c33;\n}\n/*左右点击*/\n.ss-arrow{\n    position: absolute;\n    top: 50%;\n    margin-top: -40px;\n    width: 40px;\n    height: 60px;\n    cursor: pointer;\n    background-color: rgba(0,0,0,.6);\n    display: none;\n}\n.ss-arrow-left{\n    left: 2%;\n}\n.ss-arrow-right{\n    right: 2%;\n}\n.ss-arrow-left:hover{\n    background-color: rgba(0,0,0,.4);\n}\n.ss-arrow-right:hover{\n    background-color: rgba(0,0,0,.4);\n}\n```\n### Javascript部分\n```javascript\nvar module = (function(){\n    function Slideshow(obj){\n        this.slideShow = obj;//传的形参，当做对象用\n        this.wrapperWidth = $('.ss-wrapper');\n        this.imgWrapper = $('.ss-inner');\n        this.circleItem = $('.ss-circle-item');\n        this.arrowBtn = $('.ss-arrow');\n        this.arrowBtnLeft = $('.ss-arrow-left');\n        this.arrowBtnRight = $('.ss-arrow-right');\n        this.imgs = this.imgWrapper.find('.ss-item');//图片所在盒子\n        this.index = 1;//\n        this.imgWidth = obj.imgWidth || this.imgs.eq(0).width();//设置图片宽度 有默认值\n        this.imgHeight = obj.imgHeight || this.imgs.eq(0).height();//设置高度 有默认值\n        this.gapTime = obj.time || 3000;//轮播间隔时间\n        this.isAutoPlay = obj.isFlag || false;//可选择是否自动轮播\n\tthis.mobileBtn = obj.mobileBtn || false;//移动端是否显示 左右点击按钮\n        this.timer = null;//初始化\n    }\n    Slideshow.prototype = {\n\tconstructor:Slideshow,\n        init:function(){\n            //拷贝首尾图片\n            var firstImg = this.imgs.eq(0).clone();\n            var lastImg = this.imgs.eq(this.imgs.length-1).clone();\n            //分别插入\n            this.imgWrapper.append(firstImg);\n            lastImg.insertBefore(this.imgs.eq(0));\n            //储存图片个数\n            var imgLength = $('.ss-item').length;\n            //重新赋予大盒子宽度\n            this.imgWrapper.css({\n                width:this.imgWidth * imgLength\n            });\n            //改变盒子的margin-left  显示第一张图片\n            this.imgWrapper.css({\n                marginLeft: -this.imgWidth\n            });\n            //自定义宽高\n            this.wrapperWidth.css({\n                width: this.imgWidth,\n                height: this.imgHeight\n            });\n            //自定义宽高\n            $('.ss-item').css({\n                width: this.imgWidth,\n                height: this.imgHeight\n            });\n\t//是否显示移动端点击按钮\n            if(!this.mobileBtn){\n                this.arrowBtn.hide();\n            }\n\n            //初始化后，下面的事件在此调用\n            this.addAutoPlay();\n            this.stopAutoPlay();\n            this.arrowRightClick();\n            this.arrowLeftClick();\n            this.circleClick();\n        },\n\t/*自动轮播*/\n        addAutoPlay:function(){\n            var that = this;\n            if(!this.isAutoPlay){\n                this.timer = setInterval(function(){\n                    that.index++;\n                    that.addAnimate();\n                },that.gapTime)\n            }\n        },\n        stopAutoPlay:function(){\n            \tvar that = this;\n\t\tif(!this.mobileBtn){//移动端点击按钮 开关\n\t\t\tthis.arrowBtn.hide();\n\t\t}else{//\n\t\t\tthis.arrowBtn.show();\n\t\t\tthis.wrapperWidth.on('mouseenter',function(e){\n\t\t\t\tthat.arrowBtn.fadeIn();//鼠标滑过，显示按钮\n\t\t\t\tclearInterval(that.timer);\n\t\t\t});\n\t\t\tthis.wrapperWidth.on('mouseleave',function(e){\n\t\t\t\tthat.arrowBtn.fadeOut();//鼠标离开，隐藏按钮\n\t\t\t\tthat.addAutoPlay();\n\t\t\t})\n\t\t}\n        },\n        arrowRightClick:function(){\n\t\tvar that = this;\n\t\t//防止点击过快，造成的问题  保存初始时间戳\n\t\tvar _thistime = Date.now();\n\t\tthis.arrowBtnRight.on('click',function(){\n\t\t\t//比较两次点击之间的时间，如果点击过快，return\n\t\t\tif((Date.now() - _thistime) < 700){\n\t\t\t\treturn false;\n\t\t\t}else{//符合点击范围，执行动画\n\t\t\t\t//时间保留到上次点击的地方\n\t\t\t\tthat.index++;\n\t\t\t\t_thistime = Date.now();\n\t\t\t\t//运动函数里面 已经处理好index的问题\n\t\t\t\tthat.addAnimate();\n\t\t\t}\n\t\t})\n        },\n        arrowLeftClick:function(){\n\t\tvar that = this;\n\t\t//防止点击过快，造成的问题  保存初始时间戳\n\t\tvar _thistime = Date.now();\n\t\tthis.arrowBtnLeft.on('click',function(){\n\t\t\t//比较两次点击之间的时间，如果点击过快，return\n\t\t\tif((Date.now() - _thistime) < 700){\n\t\t\t\treturn false;\n\t\t\t}else{//符合点击范围，执行动画\n\t\t\t\t//时间保留到上次点击的地方\n\t\t\t\tthat.index--;\n\t\t\t\t_thistime = Date.now();\n\t\t\t\t//运动函数里面 已经处理好index的问题\n\t\t\t\tthat.addAnimate();\n\t\t\t}\n\t\t})\n        },\n        circleClick:function(){\n\t\tvar that = this;\n\t\tthis.circleItem.each(function(k,v){\n\t\t\t$(v).on('click',function(){\n\t\t\t//点击时当前的next 等于当前的索引k\n\t\t\tthat.index = k+1;\n\t\t\tthat.addAnimate();\n\t\t\t})\n\t\t});\n        },\n        addAnimate:function(){\n            var that = this;\n            var boxWrapper = $('.ss-item');//图片容器 用来计算图片数量\n            this.imgWrapper.animate({\n                marginLeft:-this.imgWidth*that.index\n            },700,function(){//轮播一张的动画时间\n\t\t//最后一张时\n                if(that.index >= boxWrapper.length-1){\n    \t\t\t\tthat.index = 1;\n    \t\t\t}\n\t\t//第一张往前\n                if(that.index <= 0){\n    \t\t\t\tthat.index = boxWrapper.length-2;\n    \t\t\t}\n\t\t//同时设置相应的位置\n                that.imgWrapper.css({\n                    marginLeft: -that.imgWidth*that.index\n                });\n\n                //小圆圈高亮跟随 处理\n                for(var i=0; i<that.circleItem.length; i++){\n                    that.circleItem.eq(i).removeClass('active');\n                }\n                that.circleItem.eq(that.index-1).addClass('active');\n            })\n        }\n    }\n\t//导出接口\n    return {\n        Slideshow:Slideshow\n    }\n})()\n```\n### 使用方法\n如何在项目中使用\n```javascript\n//根据自己项目，引入正确路径\n//引入jquery\n<script src=\"js/jquery.min.js\"></script>\n\n//引入轮播插件(轮播起名为slideshow，遂写如下)\n<script src=\"js/slideshow.js\"></script>\n\n//引入后就可以直接调用啦.....\n<script>\nvar slideShow = new module.Slideshow({\n    time:4000,//轮播时间间隔\n    imgWidth:1200,//图片宽度 or 图片所在容器宽度\n    imgHeight:450,//图片高度 or 图片所在容器高度\n    isFlag:false, //false 为自动轮播\n    mobileBtn:true//打开PC端按钮点击 hover事件 false为移动端取消这些功能\n})\nslideShow.init();\n</script>\n```\n具体效果请点击文章开头的DEMO演示\n说明：\n* time:number 轮播时间间隔(可选 默认3s)\n* imgWidth: number 图片宽度 or 图片所在容器宽度(可选 默认1000)，如果想实现全屏轮播，该项目值为$('body').width();  (css里面记得写body{width:100%})\n* imgHeight: number 图片高度 or 图片所在容器高度(可选 有默认值)\n* isFlag:false //false 为自动轮播 ；true 为禁止自动轮播。(可选，默认自动轮播)\n\n### 结语\n本插件还有不太完善之处，如有遇到bug，请与我留言。\n** 后期考虑添加功能**\n* 实现样式可定制，包括调整布局\n* 实现多轮播共存\n* ~~移动端可关闭左右点击按钮，~~已完成 具体请看demo演示 ，查看源码\n* 增加滑动功能\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/slide-show.jpg\n  [2]: https://biyuqi.github.io/demo/src/html/slideShow.html","source":"_posts/纯手工打造一款无缝滚动轮播插件.md","raw":"---\ntitle: 纯手工打造一款无缝滚动轮播插件\ndate: 2017-01-05 21:10:10\ntags: [javascript,\"Js插件\"]\ncategories: Javascript\n---\n>项目上经常会用到轮播，为避免重复劳动，遂决定实现一个灵活的无缝滚动轮播效果，注意：此插件依赖jquery；直接看代码。本文引入jq版本为1.11；\n\n![enter description here][1]\n<!-- more -->\n### [Demo演示][2]\n### 无缝滚动轮播原理\n```javascript\n/*\n\t无缝滚动原理：\n\t\t1、前后各加一张图片\n\t\t2、每次改变ss-inner盒子的位置（margin-left）\n\t\t3、自动轮播\n\t\t4、小圆圈点击切换\n*/\n```\n### HTML结构\n```html\n<div class=\"ss-wrapper\"><!-- 外层盒子 -->\n    <div class=\"ss-inner clearfix\"><!-- 内层盒子 -->\n        <div class=\"ss-item\"><!-- 图片盒子，数量自定 -->\n            <img src=\"img/banner01.jpg\">\n        </div>\n        <div class=\"ss-item\">\n            <img src=\"img/banner02.jpg\">\n        </div>\n        <div class=\"ss-item\">\n            <img src=\"img/banner03.jpg\">\n        </div>\n        <div class=\"ss-item\">\n            <img src=\"img/banner04.jpg\">\n        </div>\n        <div class=\"ss-item\">\n            <img src=\"img/banner05.jpg\">\n        </div>\n    </div>\n    <div class=\"ss-circle\"><!-- 小圆点盒子 -->\n        <span class=\"ss-circle-item active\"></span> <!-- 小圆点 数量自定 -->\n        <span class=\"ss-circle-item\"></span>\n        <span class=\"ss-circle-item\"></span>\n        <span class=\"ss-circle-item\"></span>\n        <span class=\"ss-circle-item\"></span>\n    </div>\n    <div class=\"ss-arrow-left ss-arrow\"></div><!-- 左点击 -->\n    <div class=\"ss-arrow-right ss-arrow\"></div><!-- 右点击 -->\n</div>\n```\n说明：html结构必须按照规范，但是图片的数量可以随便增删，小圆点根据图片的数量随意增删\n### CSS部分\n```css\n/*这里用*号，清除默认样式，实属偷懒，可自行写reset*/\n*{\n    margin: 0;\n    padding: 0;\n}\nhtml,body{\n    margin: 0;\n    padding: 0;\n    width: 100%;\n}\n.ss-wrapper{\n    width: 1000px;\n    margin: 0 auto;\n    height:564px;\n    overflow: hidden;\n    position: relative;\n}\n/*\n初始5张 后面会用js计算，不用在意此处\n五张默认5000,一张1000，根据自己需要写\n*/\n.ss-inner{\n    width: 5000px;\n}\n.clearfix{\n    display: block;\n    content: '';\n    overflow: hidden;\n    clear: both;\n}\n.ss-item{\n    float: left;\n    width: 1000px;\n    overflow: hidden;\n}\n.ss-item img{\n    display: block;\n    width: 100%;\n}\n/*小圆圈*/\n.ss-circle{\n    position: absolute;\n    left: 0;\n    bottom: 1%;\n    width: 100%;\n    text-align: center;\n\n}\n.ss-circle .ss-circle-item{\n    display: inline-block;\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    background-color: #fff;\n    cursor: pointer;\n}\n.ss-circle-item.active{\n    background-color: #c33;\n}\n/*左右点击*/\n.ss-arrow{\n    position: absolute;\n    top: 50%;\n    margin-top: -40px;\n    width: 40px;\n    height: 60px;\n    cursor: pointer;\n    background-color: rgba(0,0,0,.6);\n    display: none;\n}\n.ss-arrow-left{\n    left: 2%;\n}\n.ss-arrow-right{\n    right: 2%;\n}\n.ss-arrow-left:hover{\n    background-color: rgba(0,0,0,.4);\n}\n.ss-arrow-right:hover{\n    background-color: rgba(0,0,0,.4);\n}\n```\n### Javascript部分\n```javascript\nvar module = (function(){\n    function Slideshow(obj){\n        this.slideShow = obj;//传的形参，当做对象用\n        this.wrapperWidth = $('.ss-wrapper');\n        this.imgWrapper = $('.ss-inner');\n        this.circleItem = $('.ss-circle-item');\n        this.arrowBtn = $('.ss-arrow');\n        this.arrowBtnLeft = $('.ss-arrow-left');\n        this.arrowBtnRight = $('.ss-arrow-right');\n        this.imgs = this.imgWrapper.find('.ss-item');//图片所在盒子\n        this.index = 1;//\n        this.imgWidth = obj.imgWidth || this.imgs.eq(0).width();//设置图片宽度 有默认值\n        this.imgHeight = obj.imgHeight || this.imgs.eq(0).height();//设置高度 有默认值\n        this.gapTime = obj.time || 3000;//轮播间隔时间\n        this.isAutoPlay = obj.isFlag || false;//可选择是否自动轮播\n\tthis.mobileBtn = obj.mobileBtn || false;//移动端是否显示 左右点击按钮\n        this.timer = null;//初始化\n    }\n    Slideshow.prototype = {\n\tconstructor:Slideshow,\n        init:function(){\n            //拷贝首尾图片\n            var firstImg = this.imgs.eq(0).clone();\n            var lastImg = this.imgs.eq(this.imgs.length-1).clone();\n            //分别插入\n            this.imgWrapper.append(firstImg);\n            lastImg.insertBefore(this.imgs.eq(0));\n            //储存图片个数\n            var imgLength = $('.ss-item').length;\n            //重新赋予大盒子宽度\n            this.imgWrapper.css({\n                width:this.imgWidth * imgLength\n            });\n            //改变盒子的margin-left  显示第一张图片\n            this.imgWrapper.css({\n                marginLeft: -this.imgWidth\n            });\n            //自定义宽高\n            this.wrapperWidth.css({\n                width: this.imgWidth,\n                height: this.imgHeight\n            });\n            //自定义宽高\n            $('.ss-item').css({\n                width: this.imgWidth,\n                height: this.imgHeight\n            });\n\t//是否显示移动端点击按钮\n            if(!this.mobileBtn){\n                this.arrowBtn.hide();\n            }\n\n            //初始化后，下面的事件在此调用\n            this.addAutoPlay();\n            this.stopAutoPlay();\n            this.arrowRightClick();\n            this.arrowLeftClick();\n            this.circleClick();\n        },\n\t/*自动轮播*/\n        addAutoPlay:function(){\n            var that = this;\n            if(!this.isAutoPlay){\n                this.timer = setInterval(function(){\n                    that.index++;\n                    that.addAnimate();\n                },that.gapTime)\n            }\n        },\n        stopAutoPlay:function(){\n            \tvar that = this;\n\t\tif(!this.mobileBtn){//移动端点击按钮 开关\n\t\t\tthis.arrowBtn.hide();\n\t\t}else{//\n\t\t\tthis.arrowBtn.show();\n\t\t\tthis.wrapperWidth.on('mouseenter',function(e){\n\t\t\t\tthat.arrowBtn.fadeIn();//鼠标滑过，显示按钮\n\t\t\t\tclearInterval(that.timer);\n\t\t\t});\n\t\t\tthis.wrapperWidth.on('mouseleave',function(e){\n\t\t\t\tthat.arrowBtn.fadeOut();//鼠标离开，隐藏按钮\n\t\t\t\tthat.addAutoPlay();\n\t\t\t})\n\t\t}\n        },\n        arrowRightClick:function(){\n\t\tvar that = this;\n\t\t//防止点击过快，造成的问题  保存初始时间戳\n\t\tvar _thistime = Date.now();\n\t\tthis.arrowBtnRight.on('click',function(){\n\t\t\t//比较两次点击之间的时间，如果点击过快，return\n\t\t\tif((Date.now() - _thistime) < 700){\n\t\t\t\treturn false;\n\t\t\t}else{//符合点击范围，执行动画\n\t\t\t\t//时间保留到上次点击的地方\n\t\t\t\tthat.index++;\n\t\t\t\t_thistime = Date.now();\n\t\t\t\t//运动函数里面 已经处理好index的问题\n\t\t\t\tthat.addAnimate();\n\t\t\t}\n\t\t})\n        },\n        arrowLeftClick:function(){\n\t\tvar that = this;\n\t\t//防止点击过快，造成的问题  保存初始时间戳\n\t\tvar _thistime = Date.now();\n\t\tthis.arrowBtnLeft.on('click',function(){\n\t\t\t//比较两次点击之间的时间，如果点击过快，return\n\t\t\tif((Date.now() - _thistime) < 700){\n\t\t\t\treturn false;\n\t\t\t}else{//符合点击范围，执行动画\n\t\t\t\t//时间保留到上次点击的地方\n\t\t\t\tthat.index--;\n\t\t\t\t_thistime = Date.now();\n\t\t\t\t//运动函数里面 已经处理好index的问题\n\t\t\t\tthat.addAnimate();\n\t\t\t}\n\t\t})\n        },\n        circleClick:function(){\n\t\tvar that = this;\n\t\tthis.circleItem.each(function(k,v){\n\t\t\t$(v).on('click',function(){\n\t\t\t//点击时当前的next 等于当前的索引k\n\t\t\tthat.index = k+1;\n\t\t\tthat.addAnimate();\n\t\t\t})\n\t\t});\n        },\n        addAnimate:function(){\n            var that = this;\n            var boxWrapper = $('.ss-item');//图片容器 用来计算图片数量\n            this.imgWrapper.animate({\n                marginLeft:-this.imgWidth*that.index\n            },700,function(){//轮播一张的动画时间\n\t\t//最后一张时\n                if(that.index >= boxWrapper.length-1){\n    \t\t\t\tthat.index = 1;\n    \t\t\t}\n\t\t//第一张往前\n                if(that.index <= 0){\n    \t\t\t\tthat.index = boxWrapper.length-2;\n    \t\t\t}\n\t\t//同时设置相应的位置\n                that.imgWrapper.css({\n                    marginLeft: -that.imgWidth*that.index\n                });\n\n                //小圆圈高亮跟随 处理\n                for(var i=0; i<that.circleItem.length; i++){\n                    that.circleItem.eq(i).removeClass('active');\n                }\n                that.circleItem.eq(that.index-1).addClass('active');\n            })\n        }\n    }\n\t//导出接口\n    return {\n        Slideshow:Slideshow\n    }\n})()\n```\n### 使用方法\n如何在项目中使用\n```javascript\n//根据自己项目，引入正确路径\n//引入jquery\n<script src=\"js/jquery.min.js\"></script>\n\n//引入轮播插件(轮播起名为slideshow，遂写如下)\n<script src=\"js/slideshow.js\"></script>\n\n//引入后就可以直接调用啦.....\n<script>\nvar slideShow = new module.Slideshow({\n    time:4000,//轮播时间间隔\n    imgWidth:1200,//图片宽度 or 图片所在容器宽度\n    imgHeight:450,//图片高度 or 图片所在容器高度\n    isFlag:false, //false 为自动轮播\n    mobileBtn:true//打开PC端按钮点击 hover事件 false为移动端取消这些功能\n})\nslideShow.init();\n</script>\n```\n具体效果请点击文章开头的DEMO演示\n说明：\n* time:number 轮播时间间隔(可选 默认3s)\n* imgWidth: number 图片宽度 or 图片所在容器宽度(可选 默认1000)，如果想实现全屏轮播，该项目值为$('body').width();  (css里面记得写body{width:100%})\n* imgHeight: number 图片高度 or 图片所在容器高度(可选 有默认值)\n* isFlag:false //false 为自动轮播 ；true 为禁止自动轮播。(可选，默认自动轮播)\n\n### 结语\n本插件还有不太完善之处，如有遇到bug，请与我留言。\n** 后期考虑添加功能**\n* 实现样式可定制，包括调整布局\n* 实现多轮播共存\n* ~~移动端可关闭左右点击按钮，~~已完成 具体请看demo演示 ，查看源码\n* 增加滑动功能\n\n\n  [1]: http://oiukswkar.bkt.clouddn.com/slide-show.jpg\n  [2]: https://biyuqi.github.io/demo/src/html/slideShow.html","slug":"纯手工打造一款无缝滚动轮播插件","published":1,"updated":"2019-09-25T15:10:25.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91py005rla2e4pk7ruwl","content":"<blockquote>\n<p>项目上经常会用到轮播，为避免重复劳动，遂决定实现一个灵活的无缝滚动轮播效果，注意：此插件依赖jquery；直接看代码。本文引入jq版本为1.11；</p>\n</blockquote>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/slide-show.jpg\" alt=\"enter description here\"><br><a id=\"more\"></a></p>\n<h3 id=\"Demo演示\"><a href=\"#Demo演示\" class=\"headerlink\" title=\"Demo演示\"></a><a href=\"https://biyuqi.github.io/demo/src/html/slideShow.html\" target=\"_blank\" rel=\"external\">Demo演示</a></h3><h3 id=\"无缝滚动轮播原理\"><a href=\"#无缝滚动轮播原理\" class=\"headerlink\" title=\"无缝滚动轮播原理\"></a>无缝滚动轮播原理</h3><pre><code class=\"javascript\">/*\n    无缝滚动原理：\n        1、前后各加一张图片\n        2、每次改变ss-inner盒子的位置（margin-left）\n        3、自动轮播\n        4、小圆圈点击切换\n*/\n</code></pre>\n<h3 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h3><pre><code class=\"html\">&lt;div class=&quot;ss-wrapper&quot;&gt;&lt;!-- 外层盒子 --&gt;\n    &lt;div class=&quot;ss-inner clearfix&quot;&gt;&lt;!-- 内层盒子 --&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;&lt;!-- 图片盒子，数量自定 --&gt;\n            &lt;img src=&quot;img/banner01.jpg&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;\n            &lt;img src=&quot;img/banner02.jpg&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;\n            &lt;img src=&quot;img/banner03.jpg&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;\n            &lt;img src=&quot;img/banner04.jpg&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;\n            &lt;img src=&quot;img/banner05.jpg&quot;&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;ss-circle&quot;&gt;&lt;!-- 小圆点盒子 --&gt;\n        &lt;span class=&quot;ss-circle-item active&quot;&gt;&lt;/span&gt; &lt;!-- 小圆点 数量自定 --&gt;\n        &lt;span class=&quot;ss-circle-item&quot;&gt;&lt;/span&gt;\n        &lt;span class=&quot;ss-circle-item&quot;&gt;&lt;/span&gt;\n        &lt;span class=&quot;ss-circle-item&quot;&gt;&lt;/span&gt;\n        &lt;span class=&quot;ss-circle-item&quot;&gt;&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;ss-arrow-left ss-arrow&quot;&gt;&lt;/div&gt;&lt;!-- 左点击 --&gt;\n    &lt;div class=&quot;ss-arrow-right ss-arrow&quot;&gt;&lt;/div&gt;&lt;!-- 右点击 --&gt;\n&lt;/div&gt;\n</code></pre>\n<p>说明：html结构必须按照规范，但是图片的数量可以随便增删，小圆点根据图片的数量随意增删</p>\n<h3 id=\"CSS部分\"><a href=\"#CSS部分\" class=\"headerlink\" title=\"CSS部分\"></a>CSS部分</h3><pre><code class=\"css\">/*这里用*号，清除默认样式，实属偷懒，可自行写reset*/\n*{\n    margin: 0;\n    padding: 0;\n}\nhtml,body{\n    margin: 0;\n    padding: 0;\n    width: 100%;\n}\n.ss-wrapper{\n    width: 1000px;\n    margin: 0 auto;\n    height:564px;\n    overflow: hidden;\n    position: relative;\n}\n/*\n初始5张 后面会用js计算，不用在意此处\n五张默认5000,一张1000，根据自己需要写\n*/\n.ss-inner{\n    width: 5000px;\n}\n.clearfix{\n    display: block;\n    content: &#39;&#39;;\n    overflow: hidden;\n    clear: both;\n}\n.ss-item{\n    float: left;\n    width: 1000px;\n    overflow: hidden;\n}\n.ss-item img{\n    display: block;\n    width: 100%;\n}\n/*小圆圈*/\n.ss-circle{\n    position: absolute;\n    left: 0;\n    bottom: 1%;\n    width: 100%;\n    text-align: center;\n\n}\n.ss-circle .ss-circle-item{\n    display: inline-block;\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    background-color: #fff;\n    cursor: pointer;\n}\n.ss-circle-item.active{\n    background-color: #c33;\n}\n/*左右点击*/\n.ss-arrow{\n    position: absolute;\n    top: 50%;\n    margin-top: -40px;\n    width: 40px;\n    height: 60px;\n    cursor: pointer;\n    background-color: rgba(0,0,0,.6);\n    display: none;\n}\n.ss-arrow-left{\n    left: 2%;\n}\n.ss-arrow-right{\n    right: 2%;\n}\n.ss-arrow-left:hover{\n    background-color: rgba(0,0,0,.4);\n}\n.ss-arrow-right:hover{\n    background-color: rgba(0,0,0,.4);\n}\n</code></pre>\n<h3 id=\"Javascript部分\"><a href=\"#Javascript部分\" class=\"headerlink\" title=\"Javascript部分\"></a>Javascript部分</h3><pre><code class=\"javascript\">var module = (function(){\n    function Slideshow(obj){\n        this.slideShow = obj;//传的形参，当做对象用\n        this.wrapperWidth = $(&#39;.ss-wrapper&#39;);\n        this.imgWrapper = $(&#39;.ss-inner&#39;);\n        this.circleItem = $(&#39;.ss-circle-item&#39;);\n        this.arrowBtn = $(&#39;.ss-arrow&#39;);\n        this.arrowBtnLeft = $(&#39;.ss-arrow-left&#39;);\n        this.arrowBtnRight = $(&#39;.ss-arrow-right&#39;);\n        this.imgs = this.imgWrapper.find(&#39;.ss-item&#39;);//图片所在盒子\n        this.index = 1;//\n        this.imgWidth = obj.imgWidth || this.imgs.eq(0).width();//设置图片宽度 有默认值\n        this.imgHeight = obj.imgHeight || this.imgs.eq(0).height();//设置高度 有默认值\n        this.gapTime = obj.time || 3000;//轮播间隔时间\n        this.isAutoPlay = obj.isFlag || false;//可选择是否自动轮播\n    this.mobileBtn = obj.mobileBtn || false;//移动端是否显示 左右点击按钮\n        this.timer = null;//初始化\n    }\n    Slideshow.prototype = {\n    constructor:Slideshow,\n        init:function(){\n            //拷贝首尾图片\n            var firstImg = this.imgs.eq(0).clone();\n            var lastImg = this.imgs.eq(this.imgs.length-1).clone();\n            //分别插入\n            this.imgWrapper.append(firstImg);\n            lastImg.insertBefore(this.imgs.eq(0));\n            //储存图片个数\n            var imgLength = $(&#39;.ss-item&#39;).length;\n            //重新赋予大盒子宽度\n            this.imgWrapper.css({\n                width:this.imgWidth * imgLength\n            });\n            //改变盒子的margin-left  显示第一张图片\n            this.imgWrapper.css({\n                marginLeft: -this.imgWidth\n            });\n            //自定义宽高\n            this.wrapperWidth.css({\n                width: this.imgWidth,\n                height: this.imgHeight\n            });\n            //自定义宽高\n            $(&#39;.ss-item&#39;).css({\n                width: this.imgWidth,\n                height: this.imgHeight\n            });\n    //是否显示移动端点击按钮\n            if(!this.mobileBtn){\n                this.arrowBtn.hide();\n            }\n\n            //初始化后，下面的事件在此调用\n            this.addAutoPlay();\n            this.stopAutoPlay();\n            this.arrowRightClick();\n            this.arrowLeftClick();\n            this.circleClick();\n        },\n    /*自动轮播*/\n        addAutoPlay:function(){\n            var that = this;\n            if(!this.isAutoPlay){\n                this.timer = setInterval(function(){\n                    that.index++;\n                    that.addAnimate();\n                },that.gapTime)\n            }\n        },\n        stopAutoPlay:function(){\n                var that = this;\n        if(!this.mobileBtn){//移动端点击按钮 开关\n            this.arrowBtn.hide();\n        }else{//\n            this.arrowBtn.show();\n            this.wrapperWidth.on(&#39;mouseenter&#39;,function(e){\n                that.arrowBtn.fadeIn();//鼠标滑过，显示按钮\n                clearInterval(that.timer);\n            });\n            this.wrapperWidth.on(&#39;mouseleave&#39;,function(e){\n                that.arrowBtn.fadeOut();//鼠标离开，隐藏按钮\n                that.addAutoPlay();\n            })\n        }\n        },\n        arrowRightClick:function(){\n        var that = this;\n        //防止点击过快，造成的问题  保存初始时间戳\n        var _thistime = Date.now();\n        this.arrowBtnRight.on(&#39;click&#39;,function(){\n            //比较两次点击之间的时间，如果点击过快，return\n            if((Date.now() - _thistime) &lt; 700){\n                return false;\n            }else{//符合点击范围，执行动画\n                //时间保留到上次点击的地方\n                that.index++;\n                _thistime = Date.now();\n                //运动函数里面 已经处理好index的问题\n                that.addAnimate();\n            }\n        })\n        },\n        arrowLeftClick:function(){\n        var that = this;\n        //防止点击过快，造成的问题  保存初始时间戳\n        var _thistime = Date.now();\n        this.arrowBtnLeft.on(&#39;click&#39;,function(){\n            //比较两次点击之间的时间，如果点击过快，return\n            if((Date.now() - _thistime) &lt; 700){\n                return false;\n            }else{//符合点击范围，执行动画\n                //时间保留到上次点击的地方\n                that.index--;\n                _thistime = Date.now();\n                //运动函数里面 已经处理好index的问题\n                that.addAnimate();\n            }\n        })\n        },\n        circleClick:function(){\n        var that = this;\n        this.circleItem.each(function(k,v){\n            $(v).on(&#39;click&#39;,function(){\n            //点击时当前的next 等于当前的索引k\n            that.index = k+1;\n            that.addAnimate();\n            })\n        });\n        },\n        addAnimate:function(){\n            var that = this;\n            var boxWrapper = $(&#39;.ss-item&#39;);//图片容器 用来计算图片数量\n            this.imgWrapper.animate({\n                marginLeft:-this.imgWidth*that.index\n            },700,function(){//轮播一张的动画时间\n        //最后一张时\n                if(that.index &gt;= boxWrapper.length-1){\n                    that.index = 1;\n                }\n        //第一张往前\n                if(that.index &lt;= 0){\n                    that.index = boxWrapper.length-2;\n                }\n        //同时设置相应的位置\n                that.imgWrapper.css({\n                    marginLeft: -that.imgWidth*that.index\n                });\n\n                //小圆圈高亮跟随 处理\n                for(var i=0; i&lt;that.circleItem.length; i++){\n                    that.circleItem.eq(i).removeClass(&#39;active&#39;);\n                }\n                that.circleItem.eq(that.index-1).addClass(&#39;active&#39;);\n            })\n        }\n    }\n    //导出接口\n    return {\n        Slideshow:Slideshow\n    }\n})()\n</code></pre>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><p>如何在项目中使用</p>\n<pre><code class=\"javascript\">//根据自己项目，引入正确路径\n//引入jquery\n&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;\n\n//引入轮播插件(轮播起名为slideshow，遂写如下)\n&lt;script src=&quot;js/slideshow.js&quot;&gt;&lt;/script&gt;\n\n//引入后就可以直接调用啦.....\n&lt;script&gt;\nvar slideShow = new module.Slideshow({\n    time:4000,//轮播时间间隔\n    imgWidth:1200,//图片宽度 or 图片所在容器宽度\n    imgHeight:450,//图片高度 or 图片所在容器高度\n    isFlag:false, //false 为自动轮播\n    mobileBtn:true//打开PC端按钮点击 hover事件 false为移动端取消这些功能\n})\nslideShow.init();\n&lt;/script&gt;\n</code></pre>\n<p>具体效果请点击文章开头的DEMO演示<br>说明：</p>\n<ul>\n<li>time:number 轮播时间间隔(可选 默认3s)</li>\n<li>imgWidth: number 图片宽度 or 图片所在容器宽度(可选 默认1000)，如果想实现全屏轮播，该项目值为$(‘body’).width();  (css里面记得写body{width:100%})</li>\n<li>imgHeight: number 图片高度 or 图片所在容器高度(可选 有默认值)</li>\n<li>isFlag:false //false 为自动轮播 ；true 为禁止自动轮播。(可选，默认自动轮播)</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>本插件还有不太完善之处，如有遇到bug，请与我留言。<br><strong> 后期考虑添加功能</strong></p>\n<ul>\n<li>实现样式可定制，包括调整布局</li>\n<li>实现多轮播共存</li>\n<li><del>移动端可关闭左右点击按钮，</del>已完成 具体请看demo演示 ，查看源码</li>\n<li>增加滑动功能</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>项目上经常会用到轮播，为避免重复劳动，遂决定实现一个灵活的无缝滚动轮播效果，注意：此插件依赖jquery；直接看代码。本文引入jq版本为1.11；</p>\n</blockquote>\n<p><img src=\"http://oiukswkar.bkt.clouddn.com/slide-show.jpg\" alt=\"enter description here\"><br>","more":"</p>\n<h3 id=\"Demo演示\"><a href=\"#Demo演示\" class=\"headerlink\" title=\"Demo演示\"></a><a href=\"https://biyuqi.github.io/demo/src/html/slideShow.html\" target=\"_blank\" rel=\"external\">Demo演示</a></h3><h3 id=\"无缝滚动轮播原理\"><a href=\"#无缝滚动轮播原理\" class=\"headerlink\" title=\"无缝滚动轮播原理\"></a>无缝滚动轮播原理</h3><pre><code class=\"javascript\">/*\n    无缝滚动原理：\n        1、前后各加一张图片\n        2、每次改变ss-inner盒子的位置（margin-left）\n        3、自动轮播\n        4、小圆圈点击切换\n*/\n</code></pre>\n<h3 id=\"HTML结构\"><a href=\"#HTML结构\" class=\"headerlink\" title=\"HTML结构\"></a>HTML结构</h3><pre><code class=\"html\">&lt;div class=&quot;ss-wrapper&quot;&gt;&lt;!-- 外层盒子 --&gt;\n    &lt;div class=&quot;ss-inner clearfix&quot;&gt;&lt;!-- 内层盒子 --&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;&lt;!-- 图片盒子，数量自定 --&gt;\n            &lt;img src=&quot;img/banner01.jpg&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;\n            &lt;img src=&quot;img/banner02.jpg&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;\n            &lt;img src=&quot;img/banner03.jpg&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;\n            &lt;img src=&quot;img/banner04.jpg&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;ss-item&quot;&gt;\n            &lt;img src=&quot;img/banner05.jpg&quot;&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;ss-circle&quot;&gt;&lt;!-- 小圆点盒子 --&gt;\n        &lt;span class=&quot;ss-circle-item active&quot;&gt;&lt;/span&gt; &lt;!-- 小圆点 数量自定 --&gt;\n        &lt;span class=&quot;ss-circle-item&quot;&gt;&lt;/span&gt;\n        &lt;span class=&quot;ss-circle-item&quot;&gt;&lt;/span&gt;\n        &lt;span class=&quot;ss-circle-item&quot;&gt;&lt;/span&gt;\n        &lt;span class=&quot;ss-circle-item&quot;&gt;&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;ss-arrow-left ss-arrow&quot;&gt;&lt;/div&gt;&lt;!-- 左点击 --&gt;\n    &lt;div class=&quot;ss-arrow-right ss-arrow&quot;&gt;&lt;/div&gt;&lt;!-- 右点击 --&gt;\n&lt;/div&gt;\n</code></pre>\n<p>说明：html结构必须按照规范，但是图片的数量可以随便增删，小圆点根据图片的数量随意增删</p>\n<h3 id=\"CSS部分\"><a href=\"#CSS部分\" class=\"headerlink\" title=\"CSS部分\"></a>CSS部分</h3><pre><code class=\"css\">/*这里用*号，清除默认样式，实属偷懒，可自行写reset*/\n*{\n    margin: 0;\n    padding: 0;\n}\nhtml,body{\n    margin: 0;\n    padding: 0;\n    width: 100%;\n}\n.ss-wrapper{\n    width: 1000px;\n    margin: 0 auto;\n    height:564px;\n    overflow: hidden;\n    position: relative;\n}\n/*\n初始5张 后面会用js计算，不用在意此处\n五张默认5000,一张1000，根据自己需要写\n*/\n.ss-inner{\n    width: 5000px;\n}\n.clearfix{\n    display: block;\n    content: &#39;&#39;;\n    overflow: hidden;\n    clear: both;\n}\n.ss-item{\n    float: left;\n    width: 1000px;\n    overflow: hidden;\n}\n.ss-item img{\n    display: block;\n    width: 100%;\n}\n/*小圆圈*/\n.ss-circle{\n    position: absolute;\n    left: 0;\n    bottom: 1%;\n    width: 100%;\n    text-align: center;\n\n}\n.ss-circle .ss-circle-item{\n    display: inline-block;\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    background-color: #fff;\n    cursor: pointer;\n}\n.ss-circle-item.active{\n    background-color: #c33;\n}\n/*左右点击*/\n.ss-arrow{\n    position: absolute;\n    top: 50%;\n    margin-top: -40px;\n    width: 40px;\n    height: 60px;\n    cursor: pointer;\n    background-color: rgba(0,0,0,.6);\n    display: none;\n}\n.ss-arrow-left{\n    left: 2%;\n}\n.ss-arrow-right{\n    right: 2%;\n}\n.ss-arrow-left:hover{\n    background-color: rgba(0,0,0,.4);\n}\n.ss-arrow-right:hover{\n    background-color: rgba(0,0,0,.4);\n}\n</code></pre>\n<h3 id=\"Javascript部分\"><a href=\"#Javascript部分\" class=\"headerlink\" title=\"Javascript部分\"></a>Javascript部分</h3><pre><code class=\"javascript\">var module = (function(){\n    function Slideshow(obj){\n        this.slideShow = obj;//传的形参，当做对象用\n        this.wrapperWidth = $(&#39;.ss-wrapper&#39;);\n        this.imgWrapper = $(&#39;.ss-inner&#39;);\n        this.circleItem = $(&#39;.ss-circle-item&#39;);\n        this.arrowBtn = $(&#39;.ss-arrow&#39;);\n        this.arrowBtnLeft = $(&#39;.ss-arrow-left&#39;);\n        this.arrowBtnRight = $(&#39;.ss-arrow-right&#39;);\n        this.imgs = this.imgWrapper.find(&#39;.ss-item&#39;);//图片所在盒子\n        this.index = 1;//\n        this.imgWidth = obj.imgWidth || this.imgs.eq(0).width();//设置图片宽度 有默认值\n        this.imgHeight = obj.imgHeight || this.imgs.eq(0).height();//设置高度 有默认值\n        this.gapTime = obj.time || 3000;//轮播间隔时间\n        this.isAutoPlay = obj.isFlag || false;//可选择是否自动轮播\n    this.mobileBtn = obj.mobileBtn || false;//移动端是否显示 左右点击按钮\n        this.timer = null;//初始化\n    }\n    Slideshow.prototype = {\n    constructor:Slideshow,\n        init:function(){\n            //拷贝首尾图片\n            var firstImg = this.imgs.eq(0).clone();\n            var lastImg = this.imgs.eq(this.imgs.length-1).clone();\n            //分别插入\n            this.imgWrapper.append(firstImg);\n            lastImg.insertBefore(this.imgs.eq(0));\n            //储存图片个数\n            var imgLength = $(&#39;.ss-item&#39;).length;\n            //重新赋予大盒子宽度\n            this.imgWrapper.css({\n                width:this.imgWidth * imgLength\n            });\n            //改变盒子的margin-left  显示第一张图片\n            this.imgWrapper.css({\n                marginLeft: -this.imgWidth\n            });\n            //自定义宽高\n            this.wrapperWidth.css({\n                width: this.imgWidth,\n                height: this.imgHeight\n            });\n            //自定义宽高\n            $(&#39;.ss-item&#39;).css({\n                width: this.imgWidth,\n                height: this.imgHeight\n            });\n    //是否显示移动端点击按钮\n            if(!this.mobileBtn){\n                this.arrowBtn.hide();\n            }\n\n            //初始化后，下面的事件在此调用\n            this.addAutoPlay();\n            this.stopAutoPlay();\n            this.arrowRightClick();\n            this.arrowLeftClick();\n            this.circleClick();\n        },\n    /*自动轮播*/\n        addAutoPlay:function(){\n            var that = this;\n            if(!this.isAutoPlay){\n                this.timer = setInterval(function(){\n                    that.index++;\n                    that.addAnimate();\n                },that.gapTime)\n            }\n        },\n        stopAutoPlay:function(){\n                var that = this;\n        if(!this.mobileBtn){//移动端点击按钮 开关\n            this.arrowBtn.hide();\n        }else{//\n            this.arrowBtn.show();\n            this.wrapperWidth.on(&#39;mouseenter&#39;,function(e){\n                that.arrowBtn.fadeIn();//鼠标滑过，显示按钮\n                clearInterval(that.timer);\n            });\n            this.wrapperWidth.on(&#39;mouseleave&#39;,function(e){\n                that.arrowBtn.fadeOut();//鼠标离开，隐藏按钮\n                that.addAutoPlay();\n            })\n        }\n        },\n        arrowRightClick:function(){\n        var that = this;\n        //防止点击过快，造成的问题  保存初始时间戳\n        var _thistime = Date.now();\n        this.arrowBtnRight.on(&#39;click&#39;,function(){\n            //比较两次点击之间的时间，如果点击过快，return\n            if((Date.now() - _thistime) &lt; 700){\n                return false;\n            }else{//符合点击范围，执行动画\n                //时间保留到上次点击的地方\n                that.index++;\n                _thistime = Date.now();\n                //运动函数里面 已经处理好index的问题\n                that.addAnimate();\n            }\n        })\n        },\n        arrowLeftClick:function(){\n        var that = this;\n        //防止点击过快，造成的问题  保存初始时间戳\n        var _thistime = Date.now();\n        this.arrowBtnLeft.on(&#39;click&#39;,function(){\n            //比较两次点击之间的时间，如果点击过快，return\n            if((Date.now() - _thistime) &lt; 700){\n                return false;\n            }else{//符合点击范围，执行动画\n                //时间保留到上次点击的地方\n                that.index--;\n                _thistime = Date.now();\n                //运动函数里面 已经处理好index的问题\n                that.addAnimate();\n            }\n        })\n        },\n        circleClick:function(){\n        var that = this;\n        this.circleItem.each(function(k,v){\n            $(v).on(&#39;click&#39;,function(){\n            //点击时当前的next 等于当前的索引k\n            that.index = k+1;\n            that.addAnimate();\n            })\n        });\n        },\n        addAnimate:function(){\n            var that = this;\n            var boxWrapper = $(&#39;.ss-item&#39;);//图片容器 用来计算图片数量\n            this.imgWrapper.animate({\n                marginLeft:-this.imgWidth*that.index\n            },700,function(){//轮播一张的动画时间\n        //最后一张时\n                if(that.index &gt;= boxWrapper.length-1){\n                    that.index = 1;\n                }\n        //第一张往前\n                if(that.index &lt;= 0){\n                    that.index = boxWrapper.length-2;\n                }\n        //同时设置相应的位置\n                that.imgWrapper.css({\n                    marginLeft: -that.imgWidth*that.index\n                });\n\n                //小圆圈高亮跟随 处理\n                for(var i=0; i&lt;that.circleItem.length; i++){\n                    that.circleItem.eq(i).removeClass(&#39;active&#39;);\n                }\n                that.circleItem.eq(that.index-1).addClass(&#39;active&#39;);\n            })\n        }\n    }\n    //导出接口\n    return {\n        Slideshow:Slideshow\n    }\n})()\n</code></pre>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><p>如何在项目中使用</p>\n<pre><code class=\"javascript\">//根据自己项目，引入正确路径\n//引入jquery\n&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;\n\n//引入轮播插件(轮播起名为slideshow，遂写如下)\n&lt;script src=&quot;js/slideshow.js&quot;&gt;&lt;/script&gt;\n\n//引入后就可以直接调用啦.....\n&lt;script&gt;\nvar slideShow = new module.Slideshow({\n    time:4000,//轮播时间间隔\n    imgWidth:1200,//图片宽度 or 图片所在容器宽度\n    imgHeight:450,//图片高度 or 图片所在容器高度\n    isFlag:false, //false 为自动轮播\n    mobileBtn:true//打开PC端按钮点击 hover事件 false为移动端取消这些功能\n})\nslideShow.init();\n&lt;/script&gt;\n</code></pre>\n<p>具体效果请点击文章开头的DEMO演示<br>说明：</p>\n<ul>\n<li>time:number 轮播时间间隔(可选 默认3s)</li>\n<li>imgWidth: number 图片宽度 or 图片所在容器宽度(可选 默认1000)，如果想实现全屏轮播，该项目值为$(‘body’).width();  (css里面记得写body{width:100%})</li>\n<li>imgHeight: number 图片高度 or 图片所在容器高度(可选 有默认值)</li>\n<li>isFlag:false //false 为自动轮播 ；true 为禁止自动轮播。(可选，默认自动轮播)</li>\n</ul>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>本插件还有不太完善之处，如有遇到bug，请与我留言。<br><strong> 后期考虑添加功能</strong></p>\n<ul>\n<li>实现样式可定制，包括调整布局</li>\n<li>实现多轮播共存</li>\n<li><del>移动端可关闭左右点击按钮，</del>已完成 具体请看demo演示 ，查看源码</li>\n<li>增加滑动功能</li>\n</ul>"},{"title":"组件","date":"2018-05-12T09:00:22.000Z","_content":"> 组件（Component）是对数据和方法的简单封装\n\n## 我理解的组件\n\n我认为，组件分为两种，一种是业务组件，是与业务紧密连接在一起的，是有状态的组件，一种是无状态的组件，这一步基本上就是一个小插件了。所以理解什么是组件，能够区分组件，才能更好的写高可用，可复用的组件\n","source":"_posts/组件.md","raw":"---\ntitle: 组件\ndate: 2018-05-12 17:00:22\ntags: [Vue,'组件']\ncategories: Javascript\n---\n> 组件（Component）是对数据和方法的简单封装\n\n## 我理解的组件\n\n我认为，组件分为两种，一种是业务组件，是与业务紧密连接在一起的，是有状态的组件，一种是无状态的组件，这一步基本上就是一个小插件了。所以理解什么是组件，能够区分组件，才能更好的写高可用，可复用的组件\n","slug":"组件","published":1,"updated":"2019-09-25T15:10:25.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91pz005ula2el9xa98ig","content":"<blockquote>\n<p>组件（Component）是对数据和方法的简单封装</p>\n</blockquote>\n<h2 id=\"我理解的组件\"><a href=\"#我理解的组件\" class=\"headerlink\" title=\"我理解的组件\"></a>我理解的组件</h2><p>我认为，组件分为两种，一种是业务组件，是与业务紧密连接在一起的，是有状态的组件，一种是无状态的组件，这一步基本上就是一个小插件了。所以理解什么是组件，能够区分组件，才能更好的写高可用，可复用的组件</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>组件（Component）是对数据和方法的简单封装</p>\n</blockquote>\n<h2 id=\"我理解的组件\"><a href=\"#我理解的组件\" class=\"headerlink\" title=\"我理解的组件\"></a>我理解的组件</h2><p>我认为，组件分为两种，一种是业务组件，是与业务紧密连接在一起的，是有状态的组件，一种是无状态的组件，这一步基本上就是一个小插件了。所以理解什么是组件，能够区分组件，才能更好的写高可用，可复用的组件</p>\n"},{"title":"解决Vue复用组件切换时组件不更新的问题","date":"2018-04-11T16:15:48.000Z","author":"Yuqi Bi","header-img":"form-opts.png","cdn":"header-on","_content":"> 距离上次更新已经是去年了,习惯这个东西真可怕，本文仅做个小记录\n\n## 背景\n做项目中,复用的vue组件，切换时，组件的生命周期都不执行了,查资料得知是vue的组件复用机制问题，相同的组件会被复用，也就不存在更新了\n## 解决方案\n在router-view上加上一个动态key属性值\n```html\n<router-view :key=\"key\"/>\n```\n```js\ncomputed: {\n  key () {\n    return this.$route.name !== undefined ? this.$route.name + +new Date() : this.$route + +new Date()\n  }\n}\n```\n欧克...(逃)\n","source":"_posts/解决Vue复用组件切换时组件不更新的问题.md","raw":"---\ntitle: '解决Vue复用组件切换时组件不更新的问题'\ndate: 2018-04-12 00:15:48\ntags: [vue-router, Vue, 路由]\nauthor: \"Yuqi Bi\"\nheader-img: \"form-opts.png\"\ncdn: 'header-on'\n---\n> 距离上次更新已经是去年了,习惯这个东西真可怕，本文仅做个小记录\n\n## 背景\n做项目中,复用的vue组件，切换时，组件的生命周期都不执行了,查资料得知是vue的组件复用机制问题，相同的组件会被复用，也就不存在更新了\n## 解决方案\n在router-view上加上一个动态key属性值\n```html\n<router-view :key=\"key\"/>\n```\n```js\ncomputed: {\n  key () {\n    return this.$route.name !== undefined ? this.$route.name + +new Date() : this.$route + +new Date()\n  }\n}\n```\n欧克...(逃)\n","slug":"解决Vue复用组件切换时组件不更新的问题","published":1,"updated":"2019-09-25T15:10:25.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91q0005xla2euh9ruiy8","content":"<blockquote>\n<p>距离上次更新已经是去年了,习惯这个东西真可怕，本文仅做个小记录</p>\n</blockquote>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>做项目中,复用的vue组件，切换时，组件的生命周期都不执行了,查资料得知是vue的组件复用机制问题，相同的组件会被复用，也就不存在更新了</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>在router-view上加上一个动态key属性值</p>\n<pre><code class=\"html\">&lt;router-view :key=&quot;key&quot;/&gt;\n</code></pre>\n<pre><code class=\"js\">computed: {\n  key () {\n    return this.$route.name !== undefined ? this.$route.name + +new Date() : this.$route + +new Date()\n  }\n}\n</code></pre>\n<p>欧克…(逃)</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>距离上次更新已经是去年了,习惯这个东西真可怕，本文仅做个小记录</p>\n</blockquote>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>做项目中,复用的vue组件，切换时，组件的生命周期都不执行了,查资料得知是vue的组件复用机制问题，相同的组件会被复用，也就不存在更新了</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>在router-view上加上一个动态key属性值</p>\n<pre><code class=\"html\">&lt;router-view :key=&quot;key&quot;/&gt;\n</code></pre>\n<pre><code class=\"js\">computed: {\n  key () {\n    return this.$route.name !== undefined ? this.$route.name + +new Date() : this.$route + +new Date()\n  }\n}\n</code></pre>\n<p>欧克…(逃)</p>\n"},{"title":"禁止输入框输入空格","date":"2017-04-11T11:18:38.000Z","_content":"> 做表单验证，输入框经常要做判断,群里也经常看到有朋友问,所以做了下记录,自动过滤空格,\n\n### DEMO\n[DEMO][1]\n\n<!-- more -->\n\n### 实现原理\n说下实现思路吧,其实就是监听输入框输入的类型,进行空格检测,正则一旦检测到空格,立即对当前值输入框进行赋值,赋值为过滤空格后的值\n```html\n<input type=\"text\" class=\"test\">\n```\n\n### 原生JS\n```js\nvar input = document.querySelector('.test'),\n    reg = /\\s/;\ninput.oninput = function(){\n    if(reg.test(this.value)){\n        //过滤赋值\n        input.value = this.value.replace(reg,'');\n        return;\n    }\n}\n```\n\n### JQ版\n```js\nvar input = $('.test'),\n    reg = /\\s/;\ninput.on('input',function(){\n    var val = $(this).val();\n    if(reg.test(val)){\n        //过滤赋值\n        input.val(val.replace(reg,''));\n        return;\n    }\n}\n```\n\n### Vue版本\n\n\n```html\n<input type=\"text\" class=\"test\" v-model=\"message\">\n```\n在Vue里面因为需要实时监听值得变化,所以需要在watch里面监听\n\n```js\nwatch: {\n    message: function() {\n        const reg= /\\s/;\n        if(reg.test(this.message)){\n            this.message = this.message.replace(reg,'');\n            return;\n        }\n    }\n}\n```\n\n[1]: http://loadingmore.com/demo/src/html/closespace.html\n","source":"_posts/输入框禁止输入空格.md","raw":"---\ntitle: 禁止输入框输入空格\ndate: 2017-04-11 19:18:38\ntags: [javascript,'正则','RegExp']\ncategories: Javascript\n---\n> 做表单验证，输入框经常要做判断,群里也经常看到有朋友问,所以做了下记录,自动过滤空格,\n\n### DEMO\n[DEMO][1]\n\n<!-- more -->\n\n### 实现原理\n说下实现思路吧,其实就是监听输入框输入的类型,进行空格检测,正则一旦检测到空格,立即对当前值输入框进行赋值,赋值为过滤空格后的值\n```html\n<input type=\"text\" class=\"test\">\n```\n\n### 原生JS\n```js\nvar input = document.querySelector('.test'),\n    reg = /\\s/;\ninput.oninput = function(){\n    if(reg.test(this.value)){\n        //过滤赋值\n        input.value = this.value.replace(reg,'');\n        return;\n    }\n}\n```\n\n### JQ版\n```js\nvar input = $('.test'),\n    reg = /\\s/;\ninput.on('input',function(){\n    var val = $(this).val();\n    if(reg.test(val)){\n        //过滤赋值\n        input.val(val.replace(reg,''));\n        return;\n    }\n}\n```\n\n### Vue版本\n\n\n```html\n<input type=\"text\" class=\"test\" v-model=\"message\">\n```\n在Vue里面因为需要实时监听值得变化,所以需要在watch里面监听\n\n```js\nwatch: {\n    message: function() {\n        const reg= /\\s/;\n        if(reg.test(this.message)){\n            this.message = this.message.replace(reg,'');\n            return;\n        }\n    }\n}\n```\n\n[1]: http://loadingmore.com/demo/src/html/closespace.html\n","slug":"输入框禁止输入空格","published":1,"updated":"2019-09-25T15:10:25.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91q10060la2ecsczcaa8","content":"<blockquote>\n<p>做表单验证，输入框经常要做判断,群里也经常看到有朋友问,所以做了下记录,自动过滤空格,</p>\n</blockquote>\n<h3 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h3><p><a href=\"http://loadingmore.com/demo/src/html/closespace.html\">DEMO</a></p>\n<a id=\"more\"></a>\n<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>说下实现思路吧,其实就是监听输入框输入的类型,进行空格检测,正则一旦检测到空格,立即对当前值输入框进行赋值,赋值为过滤空格后的值</p>\n<pre><code class=\"html\">&lt;input type=&quot;text&quot; class=&quot;test&quot;&gt;\n</code></pre>\n<h3 id=\"原生JS\"><a href=\"#原生JS\" class=\"headerlink\" title=\"原生JS\"></a>原生JS</h3><pre><code class=\"js\">var input = document.querySelector(&#39;.test&#39;),\n    reg = /\\s/;\ninput.oninput = function(){\n    if(reg.test(this.value)){\n        //过滤赋值\n        input.value = this.value.replace(reg,&#39;&#39;);\n        return;\n    }\n}\n</code></pre>\n<h3 id=\"JQ版\"><a href=\"#JQ版\" class=\"headerlink\" title=\"JQ版\"></a>JQ版</h3><pre><code class=\"js\">var input = $(&#39;.test&#39;),\n    reg = /\\s/;\ninput.on(&#39;input&#39;,function(){\n    var val = $(this).val();\n    if(reg.test(val)){\n        //过滤赋值\n        input.val(val.replace(reg,&#39;&#39;));\n        return;\n    }\n}\n</code></pre>\n<h3 id=\"Vue版本\"><a href=\"#Vue版本\" class=\"headerlink\" title=\"Vue版本\"></a>Vue版本</h3><pre><code class=\"html\">&lt;input type=&quot;text&quot; class=&quot;test&quot; v-model=&quot;message&quot;&gt;\n</code></pre>\n<p>在Vue里面因为需要实时监听值得变化,所以需要在watch里面监听</p>\n<pre><code class=\"js\">watch: {\n    message: function() {\n        const reg= /\\s/;\n        if(reg.test(this.message)){\n            this.message = this.message.replace(reg,&#39;&#39;);\n            return;\n        }\n    }\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>做表单验证，输入框经常要做判断,群里也经常看到有朋友问,所以做了下记录,自动过滤空格,</p>\n</blockquote>\n<h3 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h3><p><a href=\"http://loadingmore.com/demo/src/html/closespace.html\">DEMO</a></p>","more":"<h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><p>说下实现思路吧,其实就是监听输入框输入的类型,进行空格检测,正则一旦检测到空格,立即对当前值输入框进行赋值,赋值为过滤空格后的值</p>\n<pre><code class=\"html\">&lt;input type=&quot;text&quot; class=&quot;test&quot;&gt;\n</code></pre>\n<h3 id=\"原生JS\"><a href=\"#原生JS\" class=\"headerlink\" title=\"原生JS\"></a>原生JS</h3><pre><code class=\"js\">var input = document.querySelector(&#39;.test&#39;),\n    reg = /\\s/;\ninput.oninput = function(){\n    if(reg.test(this.value)){\n        //过滤赋值\n        input.value = this.value.replace(reg,&#39;&#39;);\n        return;\n    }\n}\n</code></pre>\n<h3 id=\"JQ版\"><a href=\"#JQ版\" class=\"headerlink\" title=\"JQ版\"></a>JQ版</h3><pre><code class=\"js\">var input = $(&#39;.test&#39;),\n    reg = /\\s/;\ninput.on(&#39;input&#39;,function(){\n    var val = $(this).val();\n    if(reg.test(val)){\n        //过滤赋值\n        input.val(val.replace(reg,&#39;&#39;));\n        return;\n    }\n}\n</code></pre>\n<h3 id=\"Vue版本\"><a href=\"#Vue版本\" class=\"headerlink\" title=\"Vue版本\"></a>Vue版本</h3><pre><code class=\"html\">&lt;input type=&quot;text&quot; class=&quot;test&quot; v-model=&quot;message&quot;&gt;\n</code></pre>\n<p>在Vue里面因为需要实时监听值得变化,所以需要在watch里面监听</p>\n<pre><code class=\"js\">watch: {\n    message: function() {\n        const reg= /\\s/;\n        if(reg.test(this.message)){\n            this.message = this.message.replace(reg,&#39;&#39;);\n            return;\n        }\n    }\n}\n</code></pre>"},{"title":"阿拉伯数字千分位用逗号分隔","date":"2017-03-18T12:50:30.000Z","_content":"> 上回说到字符正向加逗号或者其他字符,主要用户银行卡号等场景，而且封装成了通用代码;这回准备写点关于金钱的东西,今天写点不一样的。\n\n## 前言\n我经常在上市公司年报上看到这样的字眼:** 本公司首次向社会公众发行人民币普通股（A 股）10,720,000.00 股。募集资金总额为人民币 239,270,400.00 元.** 千分位加逗号,今天咱们用正则实现这样的效果\n<!-- more -->\n## 代码\n```javascript\n/*\n*@param s 字符\n*/\nfunction setMoney(s){\n    if(s.length < 3){\n        return;\n    }\n    //判断是否有小数位 如果有,需要多加判断\n    if(s.indexOf('.') > -1){\n        var index = s.indexOf('.');\n        var last = s.substr(index);\n        s = s.substr(0,index).replace(/\\B(?=(\\d{3})+$)/g,',');\n        s = s + last;\n        return s;\n    }else{\n        //没有小数的就直接返回\n        return s.replace(/\\B(?=(\\d{3})+$)/g,',')\n    }\n}\n//测试\nvar str = '123123123123.56';\nconsole.log(setMoney(str))\n//123,123,123,123.56\n```\n\n## 要不封装一下？\n```javascript\n/**\n*   @param {Number} num 字符\n*   @param {String} type 字符类型 , . 。等等\n*   @param {Number} len 间隔位数\n*/\nfunction setMoney(num,type,len){\n    if(num.length < 3){\n        return;\n    }\n    var reg = new RegExp('\\\\B(?=(\\\\d{'+len+'})+$)','g');\n    //判断是否有小数位 如果有,需要多加判断\n    if(num.indexOf('.') > -1){\n        var index = str.indexOf('.');\n        var last = str.substr(index);\n        num = num.substr(0,index).replace(reg,''+type+'');\n        num = num + last;\n        return num;\n    }else{\n        //没有小数的就直接返回\n        return num.replace(reg,''+type+'')\n    }\n}\n//测试\nconsole.log(setMoney2(str,',',5))\n//12,31231,23123.56\nconsole.log(setMoney2(str,',',3))\n//123,123,123,123.56\n```\n## 结语\n今天就先写到这,最近一直在研究正则,所以稍微总结了一些案例,后续可能还是以js为主,正则可能相对会减少发表,过几天写一个日常用的正则案例的博客,就正则这东西,几天不用就会遗忘,保持持续更新...以上代码都有做测试,如果有什么疑问,可以与我联系 biyuqiwan@163.com\n","source":"_posts/阿拉伯数字千分位用逗号分隔.md","raw":"---\ntitle: 阿拉伯数字千分位用逗号分隔\ndate: 2017-03-18 20:50:30\ntags: [javascript,RegExp,\"正则\"]\ncategories: Javascript\n---\n> 上回说到字符正向加逗号或者其他字符,主要用户银行卡号等场景，而且封装成了通用代码;这回准备写点关于金钱的东西,今天写点不一样的。\n\n## 前言\n我经常在上市公司年报上看到这样的字眼:** 本公司首次向社会公众发行人民币普通股（A 股）10,720,000.00 股。募集资金总额为人民币 239,270,400.00 元.** 千分位加逗号,今天咱们用正则实现这样的效果\n<!-- more -->\n## 代码\n```javascript\n/*\n*@param s 字符\n*/\nfunction setMoney(s){\n    if(s.length < 3){\n        return;\n    }\n    //判断是否有小数位 如果有,需要多加判断\n    if(s.indexOf('.') > -1){\n        var index = s.indexOf('.');\n        var last = s.substr(index);\n        s = s.substr(0,index).replace(/\\B(?=(\\d{3})+$)/g,',');\n        s = s + last;\n        return s;\n    }else{\n        //没有小数的就直接返回\n        return s.replace(/\\B(?=(\\d{3})+$)/g,',')\n    }\n}\n//测试\nvar str = '123123123123.56';\nconsole.log(setMoney(str))\n//123,123,123,123.56\n```\n\n## 要不封装一下？\n```javascript\n/**\n*   @param {Number} num 字符\n*   @param {String} type 字符类型 , . 。等等\n*   @param {Number} len 间隔位数\n*/\nfunction setMoney(num,type,len){\n    if(num.length < 3){\n        return;\n    }\n    var reg = new RegExp('\\\\B(?=(\\\\d{'+len+'})+$)','g');\n    //判断是否有小数位 如果有,需要多加判断\n    if(num.indexOf('.') > -1){\n        var index = str.indexOf('.');\n        var last = str.substr(index);\n        num = num.substr(0,index).replace(reg,''+type+'');\n        num = num + last;\n        return num;\n    }else{\n        //没有小数的就直接返回\n        return num.replace(reg,''+type+'')\n    }\n}\n//测试\nconsole.log(setMoney2(str,',',5))\n//12,31231,23123.56\nconsole.log(setMoney2(str,',',3))\n//123,123,123,123.56\n```\n## 结语\n今天就先写到这,最近一直在研究正则,所以稍微总结了一些案例,后续可能还是以js为主,正则可能相对会减少发表,过几天写一个日常用的正则案例的博客,就正则这东西,几天不用就会遗忘,保持持续更新...以上代码都有做测试,如果有什么疑问,可以与我联系 biyuqiwan@163.com\n","slug":"阿拉伯数字千分位用逗号分隔","published":1,"updated":"2019-09-25T15:10:25.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck20j91q20064la2ekouw9jeb","content":"<blockquote>\n<p>上回说到字符正向加逗号或者其他字符,主要用户银行卡号等场景，而且封装成了通用代码;这回准备写点关于金钱的东西,今天写点不一样的。</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我经常在上市公司年报上看到这样的字眼:<strong> 本公司首次向社会公众发行人民币普通股（A 股）10,720,000.00 股。募集资金总额为人民币 239,270,400.00 元.</strong> 千分位加逗号,今天咱们用正则实现这样的效果<br><a id=\"more\"></a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"javascript\">/*\n*@param s 字符\n*/\nfunction setMoney(s){\n    if(s.length &lt; 3){\n        return;\n    }\n    //判断是否有小数位 如果有,需要多加判断\n    if(s.indexOf(&#39;.&#39;) &gt; -1){\n        var index = s.indexOf(&#39;.&#39;);\n        var last = s.substr(index);\n        s = s.substr(0,index).replace(/\\B(?=(\\d{3})+$)/g,&#39;,&#39;);\n        s = s + last;\n        return s;\n    }else{\n        //没有小数的就直接返回\n        return s.replace(/\\B(?=(\\d{3})+$)/g,&#39;,&#39;)\n    }\n}\n//测试\nvar str = &#39;123123123123.56&#39;;\nconsole.log(setMoney(str))\n//123,123,123,123.56\n</code></pre>\n<h2 id=\"要不封装一下？\"><a href=\"#要不封装一下？\" class=\"headerlink\" title=\"要不封装一下？\"></a>要不封装一下？</h2><pre><code class=\"javascript\">/**\n*   @param {Number} num 字符\n*   @param {String} type 字符类型 , . 。等等\n*   @param {Number} len 间隔位数\n*/\nfunction setMoney(num,type,len){\n    if(num.length &lt; 3){\n        return;\n    }\n    var reg = new RegExp(&#39;\\\\B(?=(\\\\d{&#39;+len+&#39;})+$)&#39;,&#39;g&#39;);\n    //判断是否有小数位 如果有,需要多加判断\n    if(num.indexOf(&#39;.&#39;) &gt; -1){\n        var index = str.indexOf(&#39;.&#39;);\n        var last = str.substr(index);\n        num = num.substr(0,index).replace(reg,&#39;&#39;+type+&#39;&#39;);\n        num = num + last;\n        return num;\n    }else{\n        //没有小数的就直接返回\n        return num.replace(reg,&#39;&#39;+type+&#39;&#39;)\n    }\n}\n//测试\nconsole.log(setMoney2(str,&#39;,&#39;,5))\n//12,31231,23123.56\nconsole.log(setMoney2(str,&#39;,&#39;,3))\n//123,123,123,123.56\n</code></pre>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>今天就先写到这,最近一直在研究正则,所以稍微总结了一些案例,后续可能还是以js为主,正则可能相对会减少发表,过几天写一个日常用的正则案例的博客,就正则这东西,几天不用就会遗忘,保持持续更新…以上代码都有做测试,如果有什么疑问,可以与我联系 biyuqiwan@163.com</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上回说到字符正向加逗号或者其他字符,主要用户银行卡号等场景，而且封装成了通用代码;这回准备写点关于金钱的东西,今天写点不一样的。</p>\n</blockquote>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我经常在上市公司年报上看到这样的字眼:<strong> 本公司首次向社会公众发行人民币普通股（A 股）10,720,000.00 股。募集资金总额为人民币 239,270,400.00 元.</strong> 千分位加逗号,今天咱们用正则实现这样的效果<br>","more":"</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"javascript\">/*\n*@param s 字符\n*/\nfunction setMoney(s){\n    if(s.length &lt; 3){\n        return;\n    }\n    //判断是否有小数位 如果有,需要多加判断\n    if(s.indexOf(&#39;.&#39;) &gt; -1){\n        var index = s.indexOf(&#39;.&#39;);\n        var last = s.substr(index);\n        s = s.substr(0,index).replace(/\\B(?=(\\d{3})+$)/g,&#39;,&#39;);\n        s = s + last;\n        return s;\n    }else{\n        //没有小数的就直接返回\n        return s.replace(/\\B(?=(\\d{3})+$)/g,&#39;,&#39;)\n    }\n}\n//测试\nvar str = &#39;123123123123.56&#39;;\nconsole.log(setMoney(str))\n//123,123,123,123.56\n</code></pre>\n<h2 id=\"要不封装一下？\"><a href=\"#要不封装一下？\" class=\"headerlink\" title=\"要不封装一下？\"></a>要不封装一下？</h2><pre><code class=\"javascript\">/**\n*   @param {Number} num 字符\n*   @param {String} type 字符类型 , . 。等等\n*   @param {Number} len 间隔位数\n*/\nfunction setMoney(num,type,len){\n    if(num.length &lt; 3){\n        return;\n    }\n    var reg = new RegExp(&#39;\\\\B(?=(\\\\d{&#39;+len+&#39;})+$)&#39;,&#39;g&#39;);\n    //判断是否有小数位 如果有,需要多加判断\n    if(num.indexOf(&#39;.&#39;) &gt; -1){\n        var index = str.indexOf(&#39;.&#39;);\n        var last = str.substr(index);\n        num = num.substr(0,index).replace(reg,&#39;&#39;+type+&#39;&#39;);\n        num = num + last;\n        return num;\n    }else{\n        //没有小数的就直接返回\n        return num.replace(reg,&#39;&#39;+type+&#39;&#39;)\n    }\n}\n//测试\nconsole.log(setMoney2(str,&#39;,&#39;,5))\n//12,31231,23123.56\nconsole.log(setMoney2(str,&#39;,&#39;,3))\n//123,123,123,123.56\n</code></pre>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>今天就先写到这,最近一直在研究正则,所以稍微总结了一些案例,后续可能还是以js为主,正则可能相对会减少发表,过几天写一个日常用的正则案例的博客,就正则这东西,几天不用就会遗忘,保持持续更新…以上代码都有做测试,如果有什么疑问,可以与我联系 biyuqiwan@163.com</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck20j91nl0000la2evozba44x","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91ny000ela2ex7ijmm7u"},{"post_id":"ck20j91nx000dla2ehlr9k796","category_id":"ck20j91nw000bla2eodk3985f","_id":"ck20j91o2000kla2erjq7l4jt"},{"post_id":"ck20j91ns0006la2ekpu8swb4","category_id":"ck20j91nw000bla2eodk3985f","_id":"ck20j91o3000pla2ep6vbgigt"},{"post_id":"ck20j91ny000fla2emmdr2hna","category_id":"ck20j91nw000bla2eodk3985f","_id":"ck20j91o4000rla2e70f2zl3m"},{"post_id":"ck20j91o1000ila2erbu52add","category_id":"ck20j91nw000bla2eodk3985f","_id":"ck20j91o5000ula2e0r447o1o"},{"post_id":"ck20j91nu0008la2e5kdto8oa","category_id":"ck20j91nw000bla2eodk3985f","_id":"ck20j91o6000xla2egkmvklyx"},{"post_id":"ck20j91o2000lla2edchljveb","category_id":"ck20j91nw000bla2eodk3985f","_id":"ck20j91o70010la2enefogk1m"},{"post_id":"ck20j91o3000qla2ekq0xjc6q","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91o80013la2efgqseztm"},{"post_id":"ck20j91nw000ala2ea2etgqyw","category_id":"ck20j91nw000bla2eodk3985f","_id":"ck20j91o90015la2eafruzcse"},{"post_id":"ck20j91o4000sla2euvfg5lsr","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91oa0018la2exm9jxaip"},{"post_id":"ck20j91o5000vla2ez205nrju","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91ob001bla2egxu0enxx"},{"post_id":"ck20j91o6000yla2eag9e12oq","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91oc001fla2essof8rw6"},{"post_id":"ck20j91o70012la2en7j6uudt","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91od001ila2ei98fnifd"},{"post_id":"ck20j91o90016la2edx78tinv","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91of001mla2es40iu3d8"},{"post_id":"ck20j91oa001ala2e9m2tt58d","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91og001pla2egfjrst2k"},{"post_id":"ck20j91ob001dla2e4urxy2hj","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91oh001tla2edtz29748"},{"post_id":"ck20j91oc001hla2ewnbi608w","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91oi001wla2eweoeonn5"},{"post_id":"ck20j91od001kla2eqirv4iji","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91ol0020la2e258eeym3"},{"post_id":"ck20j91of001ola2e9p5ib6fm","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91om0023la2e4tl6fodq"},{"post_id":"ck20j91og001rla2e5kdpq8uy","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91on0028la2ew5fz7ui3"},{"post_id":"ck20j91oi001yla2eq6vthf2n","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91oo002bla2e80fbmytd"},{"post_id":"ck20j91ol0022la2e5el5j3o9","category_id":"ck20j91on0027la2erkm5gzco","_id":"ck20j91os002lla2e9n8ld3d7"},{"post_id":"ck20j91om0025la2e1kk3wgh6","category_id":"ck20j91or002hla2eyzykipyw","_id":"ck20j91ov002sla2e40bqbpdy"},{"post_id":"ck20j91os002mla2et5hx4cpd","category_id":"ck20j91nw000bla2eodk3985f","_id":"ck20j91ow002wla2eg2fhtlad"},{"post_id":"ck20j91on002ala2ev802kwwc","category_id":"ck20j91ot002nla2evlx50t7r","_id":"ck20j91oy0030la2efgtxysrt"},{"post_id":"ck20j91or002jla2ewh4dcy4w","category_id":"ck20j91ov002tla2ejmt7g6fv","_id":"ck20j91p00036la2epxe798ms"},{"post_id":"ck20j91ox002zla2ezbhc2osu","category_id":"ck20j91ot002nla2evlx50t7r","_id":"ck20j91p1003ala2ekxaf32tk"},{"post_id":"ck20j91p00034la2ecyj3bto6","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91p3003dla2e2klhlbj2"},{"post_id":"ck20j91ov002rla2eknio7xh3","category_id":"ck20j91oy0031la2ewgvc3jep","_id":"ck20j91p4003hla2e7rkqzoxp"},{"post_id":"ck20j91ow002vla2e3td5nxo7","category_id":"ck20j91p10038la2ee4we7wat","_id":"ck20j91p5003lla2eroj6nn7h"},{"post_id":"ck20j91p3003ela2e8bceqx3h","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91p7003qla2e3wpu5gwe"},{"post_id":"ck20j91p4003ila2enz6tdmhk","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91p9003tla2e2kcigwqe"},{"post_id":"ck20j91oy0032la2eoasj1tgn","category_id":"ck20j91oy0031la2ewgvc3jep","_id":"ck20j91pa003wla2elq7eu5mu"},{"post_id":"ck20j91p5003kla2eelpjygch","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pd0041la2e2simp3r0"},{"post_id":"ck20j91p10037la2eqv5dzwq3","category_id":"ck20j91p6003mla2e3s37x8vk","_id":"ck20j91pe0044la2exso9bcuf"},{"post_id":"ck20j91pd0040la2ewi8he59s","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91ph0048la2e7xwcgt5o"},{"post_id":"ck20j91pe0043la2eco6j3thh","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pj004cla2e8n5baojd"},{"post_id":"ck20j91p9003sla2e2cgfne32","category_id":"ck20j91pb003yla2epe3wsmvh","_id":"ck20j91pk004fla2exoqi2msr"},{"post_id":"ck20j91pg0047la2eh34d7hq0","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pl004jla2e6g8soeb6"},{"post_id":"ck20j91pk004hla2erk5lpiy3","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pn004pla2er5py2trb"},{"post_id":"ck20j91pl004lla2e2wvx71ih","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91po004sla2es8pg8lkv"},{"post_id":"ck20j91pm004nla2egp8uhvj4","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pq004wla2equi5k1eu"},{"post_id":"ck20j91pn004rla2eqvh495r2","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pq004zla2ejuqy32cu"},{"post_id":"ck20j91pp004ula2ew780ipj6","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pr0054la2enxkgo460"},{"post_id":"ck20j91ps0056la2ejzkifut9","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pu005cla2e08p58yig"},{"post_id":"ck20j91ps0058la2epylmckjj","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pv005fla2egip01fwy"},{"post_id":"ck20j91pq004yla2ei5qyllu1","category_id":"ck20j91pr0053la2e0phikph1","_id":"ck20j91pw005ila2eugom73ad"},{"post_id":"ck20j91pt005bla2emuzrx69e","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91px005lla2euwajl8ff"},{"post_id":"ck20j91pu005ela2eoqclzosd","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91py005pla2ev4j2zbux"},{"post_id":"ck20j91pv005gla2ekjb0cpj1","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91pz005sla2eepgahfe7"},{"post_id":"ck20j91pw005kla2eksv4vevl","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91q0005wla2er88n63hj"},{"post_id":"ck20j91px005nla2e1xopg3fn","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91q1005zla2ecn6vbxzx"},{"post_id":"ck20j91py005rla2e4pk7ruwl","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91q10062la2et8y3ltto"},{"post_id":"ck20j91pz005ula2el9xa98ig","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91q20065la2ed59sm29i"},{"post_id":"ck20j91q10060la2ecsczcaa8","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91q30066la2e6ajennnw"},{"post_id":"ck20j91q20064la2ekouw9jeb","category_id":"ck20j91nr0004la2efobeierl","_id":"ck20j91q30068la2edpe1rly9"}],"PostTag":[{"post_id":"ck20j91nl0000la2evozba44x","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91o1000jla2e3utq93yg"},{"post_id":"ck20j91nl0000la2evozba44x","tag_id":"ck20j91nw000cla2ehdb32d5c","_id":"ck20j91o2000mla2e0zpqnm41"},{"post_id":"ck20j91np0002la2e5zy1fn06","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91o6000wla2e8xym2wel"},{"post_id":"ck20j91np0002la2e5zy1fn06","tag_id":"ck20j91o3000ola2ebd5imhti","_id":"ck20j91o7000zla2eymw0kiy5"},{"post_id":"ck20j91ns0006la2ekpu8swb4","tag_id":"ck20j91o5000tla2el5q6vlyi","_id":"ck20j91oa0019la2e1fga616b"},{"post_id":"ck20j91ns0006la2ekpu8swb4","tag_id":"ck20j91o70011la2e67fl8byc","_id":"ck20j91ob001cla2eicuq02co"},{"post_id":"ck20j91o90016la2edx78tinv","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91oc001gla2eqyf3b576"},{"post_id":"ck20j91oa001ala2e9m2tt58d","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91od001jla2ee6h57zl6"},{"post_id":"ck20j91ob001dla2e4urxy2hj","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91of001nla2e18idos8j"},{"post_id":"ck20j91oc001hla2ewnbi608w","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91og001qla2eogmol88i"},{"post_id":"ck20j91nu0008la2e5kdto8oa","tag_id":"ck20j91o5000tla2el5q6vlyi","_id":"ck20j91oh001ula2edxsn9i5z"},{"post_id":"ck20j91nu0008la2e5kdto8oa","tag_id":"ck20j91o70011la2e67fl8byc","_id":"ck20j91oi001xla2ewmwkmf17"},{"post_id":"ck20j91of001ola2e9p5ib6fm","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91ol0021la2ey5mef4lw"},{"post_id":"ck20j91nw000ala2ea2etgqyw","tag_id":"ck20j91o5000tla2el5q6vlyi","_id":"ck20j91om0024la2ed47zgmex"},{"post_id":"ck20j91nw000ala2ea2etgqyw","tag_id":"ck20j91o70011la2e67fl8byc","_id":"ck20j91on0029la2e6afim2s9"},{"post_id":"ck20j91oi001yla2eq6vthf2n","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91oo002cla2ecupabqrg"},{"post_id":"ck20j91nx000dla2ehlr9k796","tag_id":"ck20j91o5000tla2el5q6vlyi","_id":"ck20j91oq002fla2ercp9o37b"},{"post_id":"ck20j91nx000dla2ehlr9k796","tag_id":"ck20j91o70011la2e67fl8byc","_id":"ck20j91or002ila2esuwgj9cz"},{"post_id":"ck20j91os002mla2et5hx4cpd","tag_id":"ck20j91o5000tla2el5q6vlyi","_id":"ck20j91ou002qla2e9yv9wl1s"},{"post_id":"ck20j91ny000fla2emmdr2hna","tag_id":"ck20j91o5000tla2el5q6vlyi","_id":"ck20j91ov002ula2ex0lo55un"},{"post_id":"ck20j91ny000fla2emmdr2hna","tag_id":"ck20j91o70011la2e67fl8byc","_id":"ck20j91ox002yla2ek2y0wmir"},{"post_id":"ck20j91o1000ila2erbu52add","tag_id":"ck20j91ou002pla2ef0t3vvqy","_id":"ck20j91p00035la2einlwmp3y"},{"post_id":"ck20j91o1000ila2erbu52add","tag_id":"ck20j91ow002xla2en7cf0vnc","_id":"ck20j91p10039la2e3van4q3k"},{"post_id":"ck20j91o2000lla2edchljveb","tag_id":"ck20j91o5000tla2el5q6vlyi","_id":"ck20j91p5003jla2emjzb6f3v"},{"post_id":"ck20j91o2000lla2edchljveb","tag_id":"ck20j91o70011la2e67fl8byc","_id":"ck20j91p6003nla2en1bx2wyr"},{"post_id":"ck20j91o3000qla2ekq0xjc6q","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91p9003rla2e7gmrgtli"},{"post_id":"ck20j91o3000qla2ekq0xjc6q","tag_id":"ck20j91p4003gla2e6ub53nzy","_id":"ck20j91pa003ula2e2zan7jop"},{"post_id":"ck20j91o4000sla2euvfg5lsr","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pb003zla2e3mp17cw3"},{"post_id":"ck20j91o4000sla2euvfg5lsr","tag_id":"ck20j91p6003ola2eoqzegonb","_id":"ck20j91pe0042la2ejdwvj64z"},{"post_id":"ck20j91o5000vla2ez205nrju","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pg0046la2ehssi1dk0"},{"post_id":"ck20j91o5000vla2ez205nrju","tag_id":"ck20j91p6003ola2eoqzegonb","_id":"ck20j91ph0049la2eypoqcpid"},{"post_id":"ck20j91o6000yla2eag9e12oq","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pj004dla2ed6d1yvra"},{"post_id":"ck20j91o6000yla2eag9e12oq","tag_id":"ck20j91p6003ola2eoqzegonb","_id":"ck20j91pk004gla2eaw37171g"},{"post_id":"ck20j91ph004ala2et5st59zv","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pl004kla2enwqe08ab"},{"post_id":"ck20j91o70012la2en7j6uudt","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pm004mla2eaxdp81to"},{"post_id":"ck20j91o70012la2en7j6uudt","tag_id":"ck20j91p6003ola2eoqzegonb","_id":"ck20j91pn004qla2e7w1o9hsa"},{"post_id":"ck20j91pk004hla2erk5lpiy3","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pp004tla2expimvatz"},{"post_id":"ck20j91o80014la2el28q70zp","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pq004xla2eo4pvxy5q"},{"post_id":"ck20j91o80014la2el28q70zp","tag_id":"ck20j91p6003ola2eoqzegonb","_id":"ck20j91pq0050la2e6s3q3n6g"},{"post_id":"ck20j91pn004rla2eqvh495r2","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91ps0055la2ed0cigb6o"},{"post_id":"ck20j91od001kla2eqirv4iji","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91ps0057la2eum9lr4e8"},{"post_id":"ck20j91od001kla2eqirv4iji","tag_id":"ck20j91pn004ola2elsukmsjs","_id":"ck20j91pt005ala2e9e2howvj"},{"post_id":"ck20j91od001kla2eqirv4iji","tag_id":"ck20j91pp004vla2e4l84led6","_id":"ck20j91pu005dla2epfu40a16"},{"post_id":"ck20j91og001rla2e5kdpq8uy","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pw005jla2eb6bavn2b"},{"post_id":"ck20j91og001rla2e5kdpq8uy","tag_id":"ck20j91pr0052la2eta3ksbiw","_id":"ck20j91px005mla2efkmom4cp"},{"post_id":"ck20j91og001rla2e5kdpq8uy","tag_id":"ck20j91pt0059la2el9q3sjgl","_id":"ck20j91py005qla2en27ep0h7"},{"post_id":"ck20j91pw005kla2eksv4vevl","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91pz005tla2esq4xlmhs"},{"post_id":"ck20j91oh001vla2e7l37fhu5","tag_id":"ck20j91pv005hla2ezx1pnmqh","_id":"ck20j91q0005yla2exjuu4tvj"},{"post_id":"ck20j91oh001vla2e7l37fhu5","tag_id":"ck20j91py005ola2eay1g1hgv","_id":"ck20j91q10061la2eb10yvcax"},{"post_id":"ck20j91ol0022la2e5el5j3o9","tag_id":"ck20j91pz005vla2em1bwcdm5","_id":"ck20j91q30069la2eeffdrb1i"},{"post_id":"ck20j91ol0022la2e5el5j3o9","tag_id":"ck20j91q10063la2eglfmpqxo","_id":"ck20j91q3006ala2ellxcdd83"},{"post_id":"ck20j91om0025la2e1kk3wgh6","tag_id":"ck20j91q30067la2esd4zg2jy","_id":"ck20j91q3006dla2eabrlo8e5"},{"post_id":"ck20j91om0025la2e1kk3wgh6","tag_id":"ck20j91q3006bla2eo59riou1","_id":"ck20j91q4006ela2e53v484q7"},{"post_id":"ck20j91on002ala2ev802kwwc","tag_id":"ck20j91q3006cla2eawtquh67","_id":"ck20j91q4006hla2ewf6n88w2"},{"post_id":"ck20j91on002ala2ev802kwwc","tag_id":"ck20j91q4006fla2eddoy2nut","_id":"ck20j91q4006ila2ece8bz0yf"},{"post_id":"ck20j91oo002dla2edi7ahfga","tag_id":"ck20j91q4006gla2eroh1fnrs","_id":"ck20j91q5006lla2ewnsqgzz6"},{"post_id":"ck20j91oo002dla2edi7ahfga","tag_id":"ck20j91q4006jla2eb0o728oh","_id":"ck20j91q5006mla2e3xy0awgb"},{"post_id":"ck20j91oq002gla2e7389znqf","tag_id":"ck20j91q4006gla2eroh1fnrs","_id":"ck20j91q5006ola2eobb85gf5"},{"post_id":"ck20j91or002jla2ewh4dcy4w","tag_id":"ck20j91q4006gla2eroh1fnrs","_id":"ck20j91q6006rla2exmhj94vw"},{"post_id":"ck20j91or002jla2ewh4dcy4w","tag_id":"ck20j91q5006pla2e5ws7h2an","_id":"ck20j91q6006sla2e55oq8pn7"},{"post_id":"ck20j91ov002rla2eknio7xh3","tag_id":"ck20j91q5006qla2evg5phpcg","_id":"ck20j91q6006wla2emdilktwi"},{"post_id":"ck20j91ov002rla2eknio7xh3","tag_id":"ck20j91q6006tla2e0vbl3vdc","_id":"ck20j91q6006xla2el72i23y0"},{"post_id":"ck20j91ov002rla2eknio7xh3","tag_id":"ck20j91q6006ula2ekkpzom3m","_id":"ck20j91q7006zla2ehttgavaz"},{"post_id":"ck20j91ow002vla2e3td5nxo7","tag_id":"ck20j91q6006vla2e048w145t","_id":"ck20j91q70070la2e1s7tdkrn"},{"post_id":"ck20j91ox002zla2ezbhc2osu","tag_id":"ck20j91q3006cla2eawtquh67","_id":"ck20j91q80073la2eflqdn79f"},{"post_id":"ck20j91ox002zla2ezbhc2osu","tag_id":"ck20j91q4006fla2eddoy2nut","_id":"ck20j91q80074la2ey060kxpd"},{"post_id":"ck20j91oy0032la2eoasj1tgn","tag_id":"ck20j91q5006qla2evg5phpcg","_id":"ck20j91q90077la2elkbd1jl5"},{"post_id":"ck20j91oy0032la2eoasj1tgn","tag_id":"ck20j91q6006ula2ekkpzom3m","_id":"ck20j91q90078la2ezp4c1vq4"},{"post_id":"ck20j91p00034la2ecyj3bto6","tag_id":"ck20j91q4006gla2eroh1fnrs","_id":"ck20j91q9007bla2ej03eu6n6"},{"post_id":"ck20j91p00034la2ecyj3bto6","tag_id":"ck20j91q90079la2em88si85k","_id":"ck20j91q9007cla2enqhjc09b"},{"post_id":"ck20j91p10037la2eqv5dzwq3","tag_id":"ck20j91q9007ala2ed6d9lgot","_id":"ck20j91qa007fla2enqzf6u1h"},{"post_id":"ck20j91p10037la2eqv5dzwq3","tag_id":"ck20j91q9007dla2e3eh8ytzq","_id":"ck20j91qa007gla2eyvizs3xt"},{"post_id":"ck20j91p2003cla2ee2ddres4","tag_id":"ck20j91q90079la2em88si85k","_id":"ck20j91qa007ila2ezpmnqo0e"},{"post_id":"ck20j91p3003ela2e8bceqx3h","tag_id":"ck20j91q4006gla2eroh1fnrs","_id":"ck20j91qb007nla2er9zf4x0h"},{"post_id":"ck20j91p3003ela2e8bceqx3h","tag_id":"ck20j91qa007jla2ebn22t3t7","_id":"ck20j91qb007ola2euwhtwya3"},{"post_id":"ck20j91p3003ela2e8bceqx3h","tag_id":"ck20j91qb007kla2e25x4q1ei","_id":"ck20j91qc007qla2ekdjzwlkt"},{"post_id":"ck20j91p3003ela2e8bceqx3h","tag_id":"ck20j91qb007lla2ea1ygue3w","_id":"ck20j91qc007rla2e049l1q5z"},{"post_id":"ck20j91p4003ila2enz6tdmhk","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qc007tla2e4wn1gpn4"},{"post_id":"ck20j91p4003ila2enz6tdmhk","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qc007ula2etibovfd3"},{"post_id":"ck20j91p4003ila2enz6tdmhk","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qd007wla2e3ystzmnx"},{"post_id":"ck20j91p5003kla2eelpjygch","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qd007yla2eswetervw"},{"post_id":"ck20j91p5003kla2eelpjygch","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qd007zla2enw5qy5bh"},{"post_id":"ck20j91p5003kla2eelpjygch","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qe0081la2e59ybuvxf"},{"post_id":"ck20j91p6003pla2edj06hv6g","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qe0083la2eqoh3sh2l"},{"post_id":"ck20j91p6003pla2edj06hv6g","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qe0084la2engbi9dbm"},{"post_id":"ck20j91p9003sla2e2cgfne32","tag_id":"ck20j91qe0082la2eo8rmm9fl","_id":"ck20j91qf0086la2eq0mz2d8p"},{"post_id":"ck20j91pa003vla2emipgbhxd","tag_id":"ck20j91q90079la2em88si85k","_id":"ck20j91qf0089la2eojbqvi5m"},{"post_id":"ck20j91pa003vla2emipgbhxd","tag_id":"ck20j91qf0087la2ehgo08llf","_id":"ck20j91qf008ala2e9fu5s8wb"},{"post_id":"ck20j91pd0040la2ewi8he59s","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qg008dla2eitc5onft"},{"post_id":"ck20j91pd0040la2ewi8he59s","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qg008ela2e7o9p4bqg"},{"post_id":"ck20j91pd0040la2ewi8he59s","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qh008gla2e3amxhum3"},{"post_id":"ck20j91pe0043la2eco6j3thh","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qh008jla2enay83r0j"},{"post_id":"ck20j91pe0043la2eco6j3thh","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qh008kla2e356eu4ud"},{"post_id":"ck20j91pe0043la2eco6j3thh","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qi008mla2e9r4orbj6"},{"post_id":"ck20j91pe0043la2eco6j3thh","tag_id":"ck20j91qh008hla2enwwcpygu","_id":"ck20j91qi008nla2eadvktnhd"},{"post_id":"ck20j91pg0047la2eh34d7hq0","tag_id":"ck20j91qh008ila2e9zki2a3p","_id":"ck20j91qi008pla2e4tmhzwjg"},{"post_id":"ck20j91pg0047la2eh34d7hq0","tag_id":"ck20j91qh008lla2eq6flc0f9","_id":"ck20j91qi008qla2e3b5v00vc"},{"post_id":"ck20j91pj004ela2ec1hon05m","tag_id":"ck20j91q90079la2em88si85k","_id":"ck20j91qj008tla2ebylr4mjg"},{"post_id":"ck20j91pj004ela2ec1hon05m","tag_id":"ck20j91qi008rla2esh3g324s","_id":"ck20j91qj008ula2e8mu24rzc"},{"post_id":"ck20j91pl004lla2e2wvx71ih","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qj008wla2e2acm18y5"},{"post_id":"ck20j91pl004lla2e2wvx71ih","tag_id":"ck20j91qj008sla2e493sdw8b","_id":"ck20j91qj008xla2e4pcbe38o"},{"post_id":"ck20j91pm004nla2egp8uhvj4","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qk0091la2eg1d6dz6p"},{"post_id":"ck20j91pm004nla2egp8uhvj4","tag_id":"ck20j91qj008vla2evokzkssa","_id":"ck20j91qk0092la2eyjwina16"},{"post_id":"ck20j91pm004nla2egp8uhvj4","tag_id":"ck20j91qj008yla2ebmjlqmgx","_id":"ck20j91ql0094la2ex8ml9nut"},{"post_id":"ck20j91pm004nla2egp8uhvj4","tag_id":"ck20j91qk008zla2e2za7jag4","_id":"ck20j91ql0095la2e7acuotdx"},{"post_id":"ck20j91pp004ula2ew780ipj6","tag_id":"ck20j91q90079la2em88si85k","_id":"ck20j91ql0097la2ezbhb1wuo"},{"post_id":"ck20j91pp004ula2ew780ipj6","tag_id":"ck20j91qk0093la2ec8a2o847","_id":"ck20j91ql0098la2eav769aoq"},{"post_id":"ck20j91pq004yla2ei5qyllu1","tag_id":"ck20j91ql0096la2exe094uiz","_id":"ck20j91qm009ala2epy8j6psi"},{"post_id":"ck20j91pr0051la2ewiigov8d","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qm009cla2eg6iczm61"},{"post_id":"ck20j91pr0051la2ewiigov8d","tag_id":"ck20j91qh008ila2e9zki2a3p","_id":"ck20j91qm009dla2e3s2yw8zx"},{"post_id":"ck20j91ps0056la2ejzkifut9","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qn009fla2ed2ete4lz"},{"post_id":"ck20j91ps0056la2ejzkifut9","tag_id":"ck20j91py005ola2eay1g1hgv","_id":"ck20j91qo009gla2ew7l0pm2g"},{"post_id":"ck20j91ps0058la2epylmckjj","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qp009jla2e642v0bih"},{"post_id":"ck20j91ps0058la2epylmckjj","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qp009kla2e8wuzpxmr"},{"post_id":"ck20j91ps0058la2epylmckjj","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qp009mla2e7t7qv8r2"},{"post_id":"ck20j91pt005bla2emuzrx69e","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qq009ola2esyr6kapf"},{"post_id":"ck20j91pt005bla2emuzrx69e","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qq009pla2ekrb6a0v8"},{"post_id":"ck20j91pt005bla2emuzrx69e","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qq009rla2e549x94cv"},{"post_id":"ck20j91pu005ela2eoqclzosd","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qq009sla2ev628ne4b"},{"post_id":"ck20j91pu005ela2eoqclzosd","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qr009ula2eou5hdlc6"},{"post_id":"ck20j91pv005gla2ekjb0cpj1","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qr009wla2ef35duwi0"},{"post_id":"ck20j91pv005gla2ekjb0cpj1","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qr009xla2egcbkg6yn"},{"post_id":"ck20j91pv005gla2ekjb0cpj1","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qs009zla2eqbm4uuww"},{"post_id":"ck20j91px005nla2e1xopg3fn","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qs00a0la2eptv7io45"},{"post_id":"ck20j91px005nla2e1xopg3fn","tag_id":"ck20j91qr009vla2ef4calgac","_id":"ck20j91qs00a2la2euogvc043"},{"post_id":"ck20j91py005rla2e4pk7ruwl","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qt00a3la2eg699dzjn"},{"post_id":"ck20j91py005rla2e4pk7ruwl","tag_id":"ck20j91qr009yla2eg6m7upsj","_id":"ck20j91qt00a5la2edurtm7pf"},{"post_id":"ck20j91pz005ula2el9xa98ig","tag_id":"ck20j91q4006gla2eroh1fnrs","_id":"ck20j91qt00a7la2ekgqq9m6f"},{"post_id":"ck20j91pz005ula2el9xa98ig","tag_id":"ck20j91qa007jla2ebn22t3t7","_id":"ck20j91qu00a8la2e0qui8zjn"},{"post_id":"ck20j91q0005xla2euh9ruiy8","tag_id":"ck20j91qt00a6la2edbwa2k30","_id":"ck20j91qv00acla2egjk6u5yh"},{"post_id":"ck20j91q0005xla2euh9ruiy8","tag_id":"ck20j91q4006gla2eroh1fnrs","_id":"ck20j91qv00adla2eebn77ycl"},{"post_id":"ck20j91q0005xla2euh9ruiy8","tag_id":"ck20j91qu00aala2ek7h4pedx","_id":"ck20j91qv00afla2eugopzzi2"},{"post_id":"ck20j91q10060la2ecsczcaa8","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qw00ahla2eac5b1ixw"},{"post_id":"ck20j91q10060la2ecsczcaa8","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qw00aila2eeco4zsyx"},{"post_id":"ck20j91q10060la2ecsczcaa8","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qw00akla2ev7q0gshi"},{"post_id":"ck20j91q20064la2ekouw9jeb","tag_id":"ck20j91ns0005la2eqt999tso","_id":"ck20j91qx00alla2e7utlxnyt"},{"post_id":"ck20j91q20064la2ekouw9jeb","tag_id":"ck20j91qb007mla2ewpa3904l","_id":"ck20j91qx00amla2ezzl9oplo"},{"post_id":"ck20j91q20064la2ekouw9jeb","tag_id":"ck20j91qb007pla2epn1cqzjh","_id":"ck20j91qx00anla2ezvlgvn7q"}],"Tag":[{"name":"javascript","_id":"ck20j91ns0005la2eqt999tso"},{"name":"Es6","_id":"ck20j91nw000cla2ehdb32d5c"},{"name":"算法","_id":"ck20j91o3000ola2ebd5imhti"},{"name":"git","_id":"ck20j91o5000tla2el5q6vlyi"},{"name":"github","_id":"ck20j91o70011la2e67fl8byc"},{"name":"Git","_id":"ck20j91ou002pla2ef0t3vvqy"},{"name":"single-clone","_id":"ck20j91ow002xla2en7cf0vnc"},{"name":"函数","_id":"ck20j91p4003gla2e6ub53nzy"},{"name":"Js技巧","_id":"ck20j91p6003ola2eoqzegonb"},{"name":"性能","_id":"ck20j91pn004ola2elsukmsjs"},{"name":"优化","_id":"ck20j91pp004vla2e4l84led6"},{"name":"fileReader","_id":"ck20j91pr0052la2eta3ksbiw"},{"name":"createObjectURL","_id":"ck20j91pt0059la2el9q3sjgl"},{"name":"Jquery","_id":"ck20j91pv005hla2ezx1pnmqh"},{"name":"select","_id":"ck20j91py005ola2eay1g1hgv"},{"name":"python","_id":"ck20j91pz005vla2em1bwcdm5"},{"name":"scrapy","_id":"ck20j91q10063la2eglfmpqxo"},{"name":"vscode","_id":"ck20j91q30067la2esd4zg2jy"},{"name":"VSCode","_id":"ck20j91q3006bla2eo59riou1"},{"name":"React","_id":"ck20j91q3006cla2eawtquh67"},{"name":"React-native","_id":"ck20j91q4006fla2eddoy2nut"},{"name":"Vue","_id":"ck20j91q4006gla2eroh1fnrs"},{"name":"chrome插件","_id":"ck20j91q4006jla2eb0o728oh"},{"name":"vue起步","_id":"ck20j91q5006pla2e5ws7h2an"},{"name":"linux","_id":"ck20j91q5006qla2evg5phpcg"},{"name":"bash","_id":"ck20j91q6006tla2e0vbl3vdc"},{"name":"shell","_id":"ck20j91q6006ula2ekkpzom3m"},{"name":"-HTML","_id":"ck20j91q6006vla2e048w145t"},{"name":"Javascript","_id":"ck20j91q90079la2em88si85k"},{"name":"window","_id":"ck20j91q9007ala2ed6d9lgot"},{"name":"java","_id":"ck20j91q9007dla2e3eh8ytzq"},{"name":"组件","_id":"ck20j91qa007jla2ebn22t3t7"},{"name":"指令","_id":"ck20j91qb007kla2e25x4q1ei"},{"name":"directive","_id":"ck20j91qb007lla2ea1ygue3w"},{"name":"RegExp","_id":"ck20j91qb007mla2ewpa3904l"},{"name":"正则","_id":"ck20j91qb007pla2epn1cqzjh"},{"name":"npm'","_id":"ck20j91qe0082la2eo8rmm9fl"},{"name":"FormData","_id":"ck20j91qf0087la2ehgo08llf"},{"name":"查询参数","_id":"ck20j91qh008hla2enwwcpygu"},{"name":"hexo","_id":"ck20j91qh008ila2e9zki2a3p"},{"name":"Travis-CI","_id":"ck20j91qh008lla2eq6flc0f9"},{"name":"CSS","_id":"ck20j91qi008rla2esh3g324s"},{"name":"小技巧","_id":"ck20j91qj008sla2e493sdw8b"},{"name":"url","_id":"ck20j91qj008vla2evokzkssa"},{"name":"URL拼接","_id":"ck20j91qj008yla2ebmjlqmgx"},{"name":"解析URL","_id":"ck20j91qk008zla2e2za7jag4"},{"name":"ES6","_id":"ck20j91qk0093la2ec8a2o847"},{"name":"other","_id":"ck20j91ql0096la2exe094uiz"},{"name":"localStorage","_id":"ck20j91qr009vla2ef4calgac"},{"name":"Js插件","_id":"ck20j91qr009yla2eg6m7upsj"},{"name":"vue-router","_id":"ck20j91qt00a6la2edbwa2k30"},{"name":"路由","_id":"ck20j91qu00aala2ek7h4pedx"}]}}