---
title: 【正则表达式系列】入门篇
date: 2017-11-26 15:50:30
tags: [javascript,RegExp,"正则"]
categories: Javascript
---
> 开始之前，我希望你能放下心中的恐惧感！

## 前言

对于一个刚接触正则的人来说，会让人觉得那么神秘，闻而生畏。

正则想要精通更是不易，需要大量反复的练习，接触正则也不少时间了，不知怎么的，我就自己走过了那段畏惧正则的时期，日常的中遇到的问题基本上都能解决

由于笔者是从事于前端开发的，所以本文中的正则都是基于Javascript的语法规则也讲述，不过不同语言之间的正则基本是相通的，只是语法表示上有点区别，我计划总结下我的一下学习的经历和心得：

** [【正则表达式系列】入门篇]() **

** [【正则表达式系列】贪婪与非贪婪模式](http://loadingmore.com/2017/12/28/【正则表达式系列】贪婪与非贪婪模式/) **

** 【正则表达式系列】零宽断言篇(待写) **

## 正文
正则字符，很多文章都会讲到，篇幅原因我就不多说，我只列举常用的：
## 元字符

元字符 | 描述
--------|--------
<code>.</code>|匹配除换行符以外的任意字符
<code>\d</code>|匹配数字, 等价于字符组[0-9]
<code>\w</code>|匹配字母, 数字, 下划线
<code>\s</code>|匹配任意的空白符(包括制表符,空格,换行等)
<code>\b</code>|匹配单词开始或结束的位置
<code>^</code>|匹配行首
<code>$</code>|匹配行尾

## 反义元字符
元字符 | 描述
--------|--------
<code>\D</code>|匹配非数字的任意字符, 等价于[^0-9]
<code>\W</code>|匹配除字母,数字,下划线之外的任意字符
<code>\S</code>|匹配非空白的任意字符
<code>\B</code>|匹配非单词开始或结束的位置
<code>[^x]</code>|匹配除x以外的任意字符
## 重复限定符
限定符 | 描述
--------|--------
<code>\*</code>|x>=0
<code>+</code>|x>=1
<code>?</code>|x=0 or x=1
<code>{n}</code>|x=n
<code>{n,}</code>|x>=n
<code>{n,m}</code>|n<=x<=m
## 修饰符
javaScript中正则表达式默认有如下五种修饰符:
* g (全文查找), 如上述截图, 实际上就开启了全文查找模式.
* i (忽略大小写查找)
* m (多行查找)
* y (ES6新增的粘连修饰符)
* u (ES6新增)

## 常用几个字符解释
### 1. <code>.</code>匹配不包括换行的任意字符

如果需要匹配包括换行的任意字符，可以使用<code>[\s\S]</code>来代替.

### 2. <code>\s</code>空格、tab、换行
<code>[\s\S]</code>表示匹配任意字符，<code>\S</code>是<code>\s</code>的反义。注意区分<code>[\s\S]</code>与<code>.</code>的区别。

### 3. <code>\*</code>匹配零个或更多个，即0~n

### 4. <code>+</code>匹配一个或更多个，即至少一个，1~n

### 5. <code>\</code> 转义
一个特殊字符前加<code>\</code>就表示转义，说明把它当普通字符用

### 6. <code>[]</code>单字符取一个，比如<code>[abc]</code>会匹配a或b或c
如果<code>[]</code>里面加上<code>^</code>则会变成排除这个字符,比如<code>[^abc]</code>就是既不包含a,也不包含b,也不包含c
在<code>[]</code>里可以使用-来表示一个范围，<code>[0-9]</code>表示从0到9，<code>[a-zA-Z]</code>包含26个字母，如果要包含-则要加上转义字符<code>[\\-]</code>
<code>[]</code>常见的错误用法是：<code>[ab|bc]</code>用来表示ab或bc，实际上，它得到的结果是[abc|]，即匹配的是a或b或c或|这4个字符（单字符）的任意一个。这里可以改成<code>(ab|bc)</code>。
** 总结：[]里面的特殊符有五个：<code>[]-\^</code>，其他字符都是普通字符，包括*.?等。**
* <code>^</code>在<code>[^</code> 的首位时候才有特殊意义
* <code>[0-9</code> <code>-</code>在不是首尾的时候有特殊意义
* <code>\\</code>本身是转义符，有特殊意义

### 7. <code>^</code> 字符串开始
注意区分，不在[]里面的是开始符，在里面的是排除
eg: <code>^http</code> vs <code>[^abs]</code>

### 8. <code>?</code> 有两个用法
* 匹配一个或零个
eg: <code>https?</code>匹配https（一个s）或者http（零个s）
* 非贪婪模式
所谓非贪婪模式，就是匹配尽可能少的内容，比如，对于源字符串


```html
<div>a</div><div>b</div>
```
使用<code>&lt;div&gt;(.\*?)&lt;/div&gt;</code>会得到2个结果（注意：如果源字符串有换行，使用[\s\S]替换 .

```html
<div>a</div>
```
和
```html
<div>a</div>
```
因为，当遇到第一个&lt;/div&gt;，非贪婪模式就不会再往后找了。
而使用<code>&lt;div&gt;(.\*)&lt;/div&gt;</code>（贪婪模式）则会得到整个字符串,因为它会匹配所有字符直到后面再找不到</div>
```html
<div>a</div><div>b</div>
```
### 9. <code>a{1,}</code> 字符a出现1次或者更多次
### 10. <code>a?</code> 字符a出现0次或者1次，等价于{0,1}
### 11. <code>(ab){0,1}</code> 字符ab出现0次或者1次，也就是说ab一起匹配
### 12. <code>(a│bc|d)e</code> 可以是ae或者是bce或者是de
### 13. <code>|</code> 多个数据选一（常用于多字符）
前面提到[]里面的字符有选一个字符功能，但是假如不是一个字符，比如：http|git|svn 就需要用|分开，|的作用域是一直往后直到遇到括号，比如，对于源字符串
匹配：
* http abc  
* git abc  
* svn abc

就可以直接使用<code>(http|git|svn)abc</code>来进行匹配
### 14. <code>()</code> 数据分界和取数据
<code>(http|git|svn)abc</code>就是一个分界的例子，匹配结果会得到一个数组集合,其中[1]也就是数组的下标1得到的是一个数组集合，这就是模式匹配，也叫分组，子模式计数是从左至右
<code>(https?):\/\/([^\/]+)</code> 就是一个匹配网址的正则，其中分组2得到的是网址主地址;
```js
/(https?):\/\/([^\/]+)/.exec('http://loadingmore.com')[2] // loadingmore.com
```
[点击这里查看匹配情况](https://regex101.com/r/LT6iPK/1)
### 15. <code>(?:)</code>非捕获组
上面提到的()作为子模式可以得到里面的数据，但是有些时候我们只是把它作为分界，不需要取数据，这个时候就需要用到非捕获概念了。比如上面匹配网址需要在分组2才能得到loadingmore.com，分组1是http；这个时候我们只需要后面的网址，就可以用非捕获来实现<code>(?:https?):\/\/([^\/]+)</code>

```js
/(?:https?):\/\/([^\/]+)/.exec('http://loadingmore.com')[1] //loadingmore.com
```
[点击这里查看匹配情况](https://regex101.com/r/LT6iPK/2)

### 16. 模式修饰符
模式修饰符很多语言都支持，js中常用的比如i不区分大小写，g全部匹配，m是多行匹配
```js
const reg = /a-z/i // 可以匹配26字母 不区分大小写
const reg2 = /http/g // httphttphttp可以匹配三个http，没有g修饰，只能匹配第一个
```
# 简单操作练习

## 定位
下面就一段html进行剖析
目标：得到 target1中inner内容 哈哈1
```html
<div class="target1">
    <div class="inner">
        哈哈1
    </div>
</div>
<div class="target2">
    <div class="inner">
        哈哈2
    </div>
</div>
```
写正则之前，首先要观察要匹配的数据结构，找出异同点，精准定位到你想要数据的位置，必须你需要一个页面的title的内容，那么title就是你的正则的关键字，所要取的数据确实无法定位一个唯一的锚点，那就可以采用分段取数据，缩小范围后，再对这个数据进行二次分解
比如上面的html片段，加入直接采用:
```js
// 很明显会得到两个inner数据段
const reg = /<div\s+class="inner">([\s\S]+?)<\/div>/
```
[点击查看详情](https://regex101.com/r/LT6iPK/3)
这个时候我们就可以考虑以class="target1"作为定位点进行匹配
```js
const reg2 = /<div class="target1">\s+<div class="inner">([\S\s]+?)<\/div>\s+<\/div>/
```
[点击查看详情](https://regex101.com/r/LT6iPK/5)

tips：采用<code>[\s\S]+</code>原因是html结构有换行；<code>.</code>不符合要求，<code>.</code>匹配不包括换行的任意字符，<code>[\s\S]+?</code>加？号的原因是非贪婪模式，否则会一致直匹配到不能匹配为止，本文只需要第一个，所以采用非贪婪模式匹配。下文会讲到贪婪与非贪婪模式

** 总结：所谓匹配数据，就是找到能唯一定位你数据的标识的锚点 **

## 去噪音
所谓去掉噪音，就是把哪些无关紧要的，迷惑你的数据果断抛弃掉，一眼抓住你想要的那个字符即可，比如：
```html
<a data-v-1b4073f4="" href="https://github.com/icepy/Front-End-Develop-Guide#fed_point_recommend" target="_blank">前端开发指南</a>
```
找出上个连接中的href链接，当然了，这用js的dom元素获取轻而易举，本文只是为了做示范，阐述一种正则思维
```js
// 首先要定位 <a href= 还有链接后面的 ” 其他的都不用关注
cosnt str = `<a data-v-1b4073f4="" href="http://loadingmore.com" target="_blank"></a>`
const reg = /<a[^>]*?href="([^"]+)"/
const result = reg.exec(str)[1]

// console.log(result)
```
[点击查看详情](https://regex101.com/r/LT6iPK/6)
** 总结：关心的留下，不关心的都是浮云 **

## 取数据
关于取数据一般都用到分组捕获上文有提及

## 最后的话
学习正则，一定要多练习，狠下心来，过一遍正则基础，收获绝对满满，一边下来，不知不觉就掌握了大部分，当然了想要精通，爱需要深入的学习和大量练习，持之以恒方得成效

## 附录
[正则表达式30分钟入门教程](http://help.locoy.com/Document/Learn_Regex_For_30_Minutes.htm)
[1小时教你学会正则表达式](http://www.cnblogs.com/beyoung/archive/2007/08/02/840139.html)
